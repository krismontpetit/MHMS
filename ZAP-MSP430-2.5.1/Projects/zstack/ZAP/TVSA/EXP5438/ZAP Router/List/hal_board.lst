###############################################################################
#                                                                             #
# IAR C/C++ Compiler V5.51.2.50607/W32 for MSP430       18/Apr/2013  16:58:50 #
# Copyright 1996-2012 IAR Systems AB.                                         #
#                                                                             #
#    __rt_version  =  3                                                       #
#    __double_size =  32                                                      #
#    __reg_r4      =  free                                                    #
#    __reg_r5      =  free                                                    #
#    __pic         =  no                                                      #
#    __core        =  430X                                                    #
#    __data_model  =  small                                                   #
#    Source file   =  C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Components\hal\target\MSP5438ZAP\hal_board.c           #
#    Command line  =  -f C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2. #
#                     5.1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\Source\zap.c #
#                     fg (-DZAP_PHY_SPI=1 -DZAP_PHY_UART=0                    #
#                     -DZAP_DEVICETYPE=ZG_DEVICETYPE_ROUTER                   #
#                     -DTVSA_DEVICE_ID=0x0016 -DTVSA_DONGLE=1 -DHAL_UART=1    #
#                     -DZAP_PHY_RESET_ZNP=TRUE -DZAP_ZNP_MT=FALSE             #
#                     -DZAP_APP_MSG=FALSE -DZAP_SBL_PROXY=FALSE               #
#                     -DZAP_AUTO_CFG=TRUE -DZAP_AUTO_START=TRUE               #
#                     -DZAP_NV_RESTORE=FALSE -DLCD_SUPPORTED                  #
#                     -DZAP_AF_DATA_REQ_FRAG=FALSE                            #
#                     -DZAP_AF_DATA_REQ_AREQ=!ZAP_AF_DATA_REQ_FRAG            #
#                     -DZAP_ZDO_STARTUP_AREQ=TRUE -DZAP_AF_FUNC               #
#                     -DZAP_SAPI_FUNC -DZAP_SYS_FUNC -DZAP_UTIL_FUNC          #
#                     -DZAP_ZDO_FUNC -DSECURE=0 -DZG_SECURE_DYNAMIC=0         #
#                     "-DDEFAULT_CHANLIST=(uint32)0x00000800"                 #
#                     -DZDAPP_CONFIG_PAN_ID=0xFFFF -DPOLL_RATE=1000           #
#                     -DNWK_START_DELAY=100 -DMAX_BINDING_CLUSTER_IDS=4)      #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Components\hal\target\MSP5438ZAP\hal_board.c -D        #
#                     ZAP_DEVICETYPE=ZG_DEVICETYPE_ROUTER -D                  #
#                     TVSA_DEVICE_ID=0x0016 -lC "C:\Users\student\Documents\G #
#                     itHub\MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EX #
#                     P5438\ZAP Router\List\" -lA                             #
#                     "C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5. #
#                     1\Projects\zstack\ZAP\TVSA\EXP5438\ZAP Router\List\"    #
#                     --remarks --diag_suppress Pe001,Pe193,Pe236,Pe826 -o    #
#                     "C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5. #
#                     1\Projects\zstack\ZAP\TVSA\EXP5438\ZAP Router\Obj\"     #
#                     --debug -D__MSP430F5438A__ -e --double=32 --clib -I     #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\ -I                   #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\Source\ -I         #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\Source\ -I      #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\hal\target\MSP5438ZAP\ -I                          #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\hal\include\ -I C:\Users\student\Documents\GitHub\ #
#                     MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\ #
#                     ..\..\..\..\..\Components\mac\include\ -I               #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\mt\ -I C:\Users\student\Documents\GitHub\MHMS\ZAP- #
#                     MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\ #
#                     ..\..\Components\osal\include\ -I                       #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\osal\mcu\msp430\ -I C:\Users\student\Documents\Git #
#                     Hub\MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5 #
#                     438\..\..\..\..\..\Components\services\saddr\ -I        #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\services\sdata\ -I C:\Users\student\Documents\GitH #
#                     ub\MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP54 #
#                     38\..\..\..\..\..\Components\stack\af\ -I               #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\stack\nwk\ -I C:\Users\student\Documents\GitHub\MH #
#                     MS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\.. #
#                     \..\..\..\..\Components\stack\sapi\ -I                  #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\stack\sec\ -I C:\Users\student\Documents\GitHub\MH #
#                     MS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\.. #
#                     \..\..\..\..\Components\stack\sys\ -I                   #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\stack\zdo\ -I C:\Users\student\Documents\GitHub\MH #
#                     MS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\.. #
#                     \..\..\..\..\Components\zmac\ -I                        #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\zmac\f8w\ --core=430X --data_model=small -Ohz      #
#                     --multiplier=32 --multiplier_location=4C0               #
#                     --require_prototypes --hw_workaround=CPU40              #
#                     --hw_workaround=CPU42                                   #
#    List file     =  C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\ZAP                   #
#                     Router\List\hal_board.lst                               #
#    Object file   =  C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\ZAP                   #
#                     Router\Obj\hal_board.r43                                #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1\Components\hal\target\MSP5438ZAP\hal_board.c
      1          /**************************************************************************************************
      2            Filename:       hal_board.c
      3            Revised:        $Date:$
      4            Revision:       $Revision:$
      5          
      6            Description:    Board specific declarations
      7            Notes:          This version targets the Texas Instruments EXP5418
      8          
      9          
     10            Copyright 2009 Texas Instruments Incorporated. All rights reserved.
     11          
     12            IMPORTANT: Your use of this Software is limited to those specific rights
     13            granted under the terms of a software license agreement between the user
     14            who downloaded the software, his/her employer (which must be your employer)
     15            and Texas Instruments Incorporated (the "License").  You may not use this
     16            Software unless you agree to abide by the terms of the License. The License
     17            limits your use, and you acknowledge, that the Software may not be modified,
     18            copied or distributed unless embedded on a Texas Instruments microcontroller
     19            or used solely and exclusively in conjunction with a Texas Instruments radio
     20            frequency transceiver, which is integrated into your product.  Other than for
     21            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     22            works of, modify, distribute, perform, display or sell this Software and/or
     23            its documentation for any purpose.
     24          
     25            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     26            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     27            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     28            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     29            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     30            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     31            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     32            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     33            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     34            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     35            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     36          
     37            Should you have any questions regarding your right to use this Software,
     38            contact Texas Instruments Incorporated at www.TI.com.
     39          **************************************************************************************************/
     40          
     41          /*********************************************************************
     42           * INCLUDES
     43           */
     44          
     45          #include "ZComDef.h"
     46          #include "OnBoard.h"

   \                                 In  segment DATA16_AN, at 0x21c
   \   union <unnamed> _A_PAIFG_L
   \                     _A_PAIFG_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x340
   \   unsigned short volatile TA0CTL
   \                     TA0CTL:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x342
   \   unsigned short volatile TA0CCTL0
   \                     TA0CCTL0:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x352
   \   unsigned short volatile TA0CCR0
   \                     TA0CCR0:
   \   000000                DS8 2
     47          #include "OSAL.h"
     48          #include "OSAL_Clock.h"
     49          #include "MT.h"
     50          #include "MT_SYS.h"
     51          #include "DebugTrace.h"
     52          #include "zap_app.h"
     53          
     54          /* Hal */
     55          #include "hal_lcd.h"
     56          #include "hal_mcu.h"
     57          #include "hal_timer.h"
     58          #include "hal_key.h"
     59          #include "hal_led.h"
     60          
     61          /*********************************************************************
     62           * MACROS
     63           */
     64          
     65          /*********************************************************************
     66           * CONSTANTS
     67           */
     68          
     69          // Task ID not initialized
     70          #define NO_TASK_ID 0xFF
     71          
     72          // Minimum length RAM "pattern" for Stack check
     73          #define MIN_RAM_INIT 12
     74          
     75          /*********************************************************************
     76           * TYPEDEFS
     77           */
     78          
     79          /*********************************************************************
     80           * GLOBAL VARIABLES
     81           */
     82          

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     83          uint8 OnboardKeyIntEnable;
   \                     OnboardKeyIntEnable:
   \   000000                DS8 1
     84          
     85          /*********************************************************************
     86           * EXTERNAL VARIABLES
     87           */
     88          
     89          /*********************************************************************
     90           * EXTERNAL FUNCTIONS
     91           */
     92          
     93          /*********************************************************************
     94           * LOCAL VARIABLES
     95           */
     96          
     97          // Registered keys task ID, initialized to NOT USED.

   \                                 In  segment DATA16_I, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
     98          static uint8 registeredKeysTaskID = NO_TASK_ID;
   \                     registeredKeysTaskID:
   \   000000                DS8 1
   \   000001                REQUIRE `?<Initializer for registeredKeysTaskID>`
     99          

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    100          static volatile uint16 halBrdTmrTick;
   \                     halBrdTmrTick:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    101          static volatile uint8 halBrdTmrDlyF;
   \                     halBrdTmrDlyF:
   \   000000                DS8 1

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    102          static uint16 halBrdTmrDly;
   \                     halBrdTmrDly:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    103          static uint16 halBrdTmrTickShdw;
   \                     halBrdTmrTickShdw:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    104          static uint8 halBrdDlySleep;
   \                     halBrdDlySleep:
   \   000000                DS8 1
    105          

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    106          static UTCTime OSAL_timeSeconds;
   \                     OSAL_timeSeconds:
   \   000000                DS8 4

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    107          static uint16 timeMSec;
   \                     timeMSec:
   \   000000                DS8 2
    108          
    109          /*********************************************************************
    110           * LOCAL FUNCTIONS
    111           */
    112          
    113          static void osalClockUpdate( uint16 elapsedMSec );
    114          
    115          /*********************************************************************
    116           * @fn      osalClockUpdate
    117           *
    118           * @brief   Updates the OSAL Clock time with elapsed milliseconds.
    119           *
    120           * @param   elapsedMSec - elapsed milliseconds
    121           *
    122           * @return  none
    123           */
    124          static void osalClockUpdate( uint16 elapsedMSec )
    125          {
    126            // Add elapsed milliseconds to the saved millisecond portion of time
    127            timeMSec += elapsedMSec;
    128          
    129            // Roll up milliseconds to the number of seconds
    130            if ( timeMSec > 1000 )
    131            {
    132              OSAL_timeSeconds += timeMSec / 1000;
    133              timeMSec = timeMSec % 1000;
    134            }
    135          }
    136          
    137          /*********************************************************************
    138           * @fn      InitClock()
    139           * @brief   Initialize the CC2420DB Board Peripherals
    140           * @param   None
    141           * @return  None
    142           */

   \                                 In  segment CODE, align 2
    143          void InitClock(void)
   \                     InitClock:
    144          {
    145            // Configure TimerA as 1-KHz HAL Board timer to drive OSAL timers and block waiting/sleeping.
    146            TA0CCR0 = HAL_CPU_CLOCK_MHZ * 1000;
   \   000000   B240E02E5203 MOV.W   #0x2ee0, &0x352
    147            TA0CTL = TASSEL_2 + MC_1;  // SMCLK, upmode
   \   000006   B24010024003 MOV.W   #0x210, &0x340
    148            TA0CCTL0 = CCIE;
   \   00000C   B24010004203 MOV.W   #0x10, &0x342
    149          }
   \   000012   1001         RETA
   \   000014                REQUIRE TA0CCR0
   \   000014                REQUIRE TA0CTL
   \   000014                REQUIRE TA0CCTL0
    150          
    151          /*********************************************************************
    152           * @fn      InitBoard()
    153           * @brief   Initialize the CC2420DB Board Peripherals
    154           * @param   None
    155           * @return  None
    156           */

   \                                 In  segment CODE, align 2
    157          void InitBoard(void)
   \                     InitBoard:
    158          {
    159            OnboardKeyIntEnable = HAL_KEY_INTERRUPT_DISABLE;
   \   000000   C243....     MOV.B   #0x0, &OnboardKeyIntEnable
    160            HalKeyConfig( OnboardKeyIntEnable, OnBoard_KeyCallback);
   \   000004   3E40....     MOV.W   #LWRD(OnBoard_KeyCallback), R14
   \   000008   3F40....     MOV.W   #HWRD(OnBoard_KeyCallback), R15
   \   00000C   4C43         MOV.B   #0x0, R12
   \   00000E   ........     BRA     #HalKeyConfig
    161          }
    162          
    163          /*********************************************************************
    164           * Keyboard Register function
    165           *
    166           * The keyboard handler is setup to send all keyboard changes to
    167           * one task (if a task is registered).
    168           *
    169           * If a task registers, it will get all the keys. You can change this
    170           * to register for individual keys.
    171           *********************************************************************/

   \                                 In  segment CODE, align 2
    172          void RegisterForKeys( uint8 task_id )
   \                     RegisterForKeys:
    173          {
    174            registeredKeysTaskID = task_id;
   \   000000   C24C....     MOV.B   R12, &registeredKeysTaskID
    175          }
   \   000004   1001         RETA
    176          
    177          /*********************************************************************
    178           * @fn      OnBoard_SendKeys
    179           *
    180           * @brief   Send "Key Pressed" message to application.
    181           *
    182           * @param   keys  - keys that were pressed
    183           *          state - shifted
    184           *
    185           * @return  status
    186           *********************************************************************/

   \                                 In  segment CODE, align 2
    187          uint8 OnBoard_SendKeys( uint8 keys, uint8 state )
   \                     OnBoard_SendKeys:
    188          {
   \   000000   1B15         PUSHM.W #0x2, R11
   \   000002   4A4C         MOV.B   R12, R10
   \   000004   4B4D         MOV.B   R13, R11
    189            keyChange_t *msgPtr;
    190          
    191            if ( registeredKeysTaskID != NO_TASK_ID )
   \   000006   F293....     CMP.B   #0xff, &registeredKeysTaskID
   \   00000A   1324         JEQ     ??OnBoard_SendKeys_0
    192            {
    193              // Send the address to the task
    194              msgPtr = (keyChange_t *)osal_msg_allocate( sizeof(keyChange_t) );
   \   00000C   2C42         MOV.W   #0x4, R12
   \   00000E   ........     CALLA   #osal_msg_allocate
    195              if ( msgPtr )
   \   000012   0C93         CMP.W   #0x0, R12
   \   000014   0C24         JEQ     ??OnBoard_SendKeys_1
    196              {
    197                msgPtr->hdr.event = KEY_CHANGE;
   \   000016   FC40C0000000 MOV.B   #0xc0, 0(R12)
    198                msgPtr->state = state;
   \   00001C   CC4B0200     MOV.B   R11, 0x2(R12)
    199                msgPtr->keys = keys;
   \   000020   CC4A0300     MOV.B   R10, 0x3(R12)
    200          
    201                osal_msg_send( registeredKeysTaskID, (uint8 *)msgPtr );
   \   000024   0D4C         MOV.W   R12, R13
   \   000026   5C42....     MOV.B   &registeredKeysTaskID, R12
   \   00002A   ........     CALLA   #osal_msg_send
    202              }
    203              return ( ZSuccess );
   \                     ??OnBoard_SendKeys_1:
   \   00002E   4C43         MOV.B   #0x0, R12
   \   000030   013C         JMP     ??OnBoard_SendKeys_2
    204            }
    205            else
    206              return ( ZFailure );
   \                     ??OnBoard_SendKeys_0:
   \   000032   5C43         MOV.B   #0x1, R12
   \                     ??OnBoard_SendKeys_2:
   \   000034   1A17         POPM.W  #0x2, R11
   \   000036   1001         RETA
    207          }
    208          
    209          /*********************************************************************
    210           * @fn      OnBoard_KeyCallback
    211           *
    212           * @brief   Callback service for keys
    213           *
    214           * @param   keys  - keys that were pressed
    215           *          state - shifted
    216           *
    217           * @return  void
    218           *********************************************************************/

   \                                 In  segment CODE, align 2
    219          void OnBoard_KeyCallback ( uint8 keys, uint8 state )
   \                     OnBoard_KeyCallback:
    220          {
    221            uint8 shift;
    222            (void)state;
    223          
    224            shift = (keys & HAL_KEY_SW_6) ? true : false;
    225          
    226            if ( OnBoard_SendKeys( keys, shift ) != ZSuccess )
   \   000000   7CB02000     BIT.B   #0x20, R12
   \   000004   4D7D         SUBC.B  R13, R13
   \   000006   5D53         ADD.B   #0x1, R13
   \   000008   ........     BRA     #OnBoard_SendKeys
    227            {
    228              // Process SW1 here
    229              if ( keys & HAL_KEY_SW_1 )  // Switch 1
    230              {
    231              }
    232              // Process SW2 here
    233              if ( keys & HAL_KEY_SW_2 )  // Switch 2
    234              {
    235              }
    236              // Process SW3 here
    237              if ( keys & HAL_KEY_SW_3 )  // Switch 3
    238              {
    239              }
    240              // Process SW4 here
    241              if ( keys & HAL_KEY_SW_4 )  // Switch 4
    242              {
    243              }
    244              // Process SW5 here
    245              if ( keys & HAL_KEY_SW_5 )  // Switch 5
    246              {
    247              }
    248              // Process SW6 here
    249              if ( keys & HAL_KEY_SW_6 )  // Switch 6
    250              {
    251              }
    252            }
    253          }
    254          
    255          /*********************************************************************
    256           * @fn      OnBoard_stack_used
    257           *
    258           * @brief   Runs through the stack looking for touched memory.
    259           *
    260           * @param   none
    261           *
    262           * @return  Maximum number of bytes used by the stack.
    263           *********************************************************************/

   \                                 In  segment CODE, align 2
    264          uint16 OnBoard_stack_used(void)
   \                     OnBoard_stack_used:
    265          {
    266            uint8 const *ptr;
    267            uint8 cnt = 0;
   \   000000   4E43         MOV.B   #0x0, R14
    268          
    269            for (ptr = CSTACK_END; ptr > CSTACK_BEG; ptr--)
   \   000002   3F40....     MOV.W   #LWRD(SFE(CSTACK) - 1), R15
   \   000006   023C         JMP     ??OnBoard_stack_used_2
    270            {
    271              if (STACK_INIT_VALUE == *ptr)
    272              {
    273                if (++cnt >= MIN_RAM_INIT)
    274                {
    275                  ptr += MIN_RAM_INIT;
    276                  break;
    277                }
    278              }
    279              else
    280              {
    281                cnt = 0;
   \                     ??OnBoard_stack_used_0:
   \   000008   4E43         MOV.B   #0x0, R14
    282              }
   \                     ??OnBoard_stack_used_1:
   \   00000A   3F53         ADD.W   #0xffff, R15
   \                     ??OnBoard_stack_used_2:
   \   00000C   3D40....     MOV.W   #SFB(CSTACK), R13
   \   000010   0D9F         CMP.W   R15, R13
   \   000012   0A2C         JC      ??OnBoard_stack_used_3
   \   000014   FF90CD000000 CMP.B   #0xcd, 0(R15)
   \   00001A   F623         JNE     ??OnBoard_stack_used_0
   \   00001C   5E53         ADD.B   #0x1, R14
   \   00001E   7E900C00     CMP.B   #0xc, R14
   \   000022   F32B         JNC     ??OnBoard_stack_used_1
   \   000024   3F500C00     ADD.W   #0xc, R15
    283            }
    284          
    285            return (uint16)(CSTACK_END - ptr + 1);
   \                     ??OnBoard_stack_used_3:
   \   000028   3C40....     MOV.W   #LWRD(SFE(CSTACK) - 1), R12
   \   00002C   0C8F         SUB.W   R15, R12
   \   00002E   1C53         ADD.W   #0x1, R12
   \   000030   1001         RETA
    286          }
    287          
    288          /*********************************************************************
    289           * @fn      _itoa
    290           *
    291           * @brief   convert a 16bit number to ASCII
    292           *
    293           * @param   num -
    294           *          buf -
    295           *          radix -
    296           *
    297           * @return  void
    298           *
    299           *********************************************************************/

   \                                 In  segment CODE, align 2
    300          void _itoa(uint16 num, uint8 *buf, uint8 radix)
   \                     _itoa:
    301          {
   \   000000   5B15         PUSHM.W #0x6, R11
   \   000002   31800600     SUB.W   #0x6, SP
   \   000006   0B4C         MOV.W   R12, R11
   \   000008   084D         MOV.W   R13, R8
    302            char c,i;
    303            uint8 *p, rst[5];
    304          
    305            p = rst;
   \   00000A   0941         MOV.W   SP, R9
   \   00000C   0953         ADD.W   #0x0, R9
    306            for ( i=0; i<5; i++,p++ )
   \   00000E   4643         MOV.B   #0x0, R6
   \   000010   4A4E         MOV.B   R14, R10
    307            {
    308              c = num % radix;  // Isolate a digit
   \                     ??_itoa_0:
   \   000012   0C4B         MOV.W   R11, R12
   \   000014   0E4A         MOV.W   R10, R14
   \   000016   ........     CALLA   #?DivMod16u
    309              *p = c + (( c < 10 ) ? '0' : '7');  // Convert to Ascii
   \   00001A   7E900A00     CMP.B   #0xa, R14
   \   00001E   0328         JNC     ??_itoa_2
   \   000020   7F403700     MOV.B   #0x37, R15
   \   000024   023C         JMP     ??_itoa_3
   \                     ??_itoa_2:
   \   000026   7F403000     MOV.B   #0x30, R15
   \                     ??_itoa_3:
   \   00002A   4E5F         ADD.B   R15, R14
   \   00002C   C94E0000     MOV.B   R14, 0(R9)
    310              num /= radix;
   \   000030   0C4B         MOV.W   R11, R12
   \   000032   0E4A         MOV.W   R10, R14
   \   000034   ........     CALLA   #?DivMod16u
   \   000038   0B4C         MOV.W   R12, R11
    311              if ( !num )
   \   00003A   0C93         CMP.W   #0x0, R12
   \   00003C   0524         JEQ     ??_itoa_4
    312                break;
    313            }
   \   00003E   5653         ADD.B   #0x1, R6
   \   000040   1953         ADD.W   #0x1, R9
   \   000042   76900500     CMP.B   #0x5, R6
   \   000046   E52B         JNC     ??_itoa_0
    314          
    315            for ( c=0 ; c<=i; c++ )
   \                     ??_itoa_4:
   \   000048   4E43         MOV.B   #0x0, R14
    316              *buf++ = *p--;  // Reverse character order
   \                     ??_itoa_1:
   \   00004A   E8490000     MOV.B   @R9, 0(R8)
   \   00004E   3953         ADD.W   #0xffff, R9
   \   000050   1853         ADD.W   #0x1, R8
   \   000052   5E53         ADD.B   #0x1, R14
   \   000054   469E         CMP.B   R14, R6
   \   000056   F92F         JC      ??_itoa_1
    317          
    318            *buf = '\0';
   \   000058   C8430000     MOV.B   #0x0, 0(R8)
    319          }
   \   00005C   31500600     ADD.W   #0x6, SP
   \   000060   5617         POPM.W  #0x6, R11
   \   000062   1001         RETA
    320          
    321          /*********************************************************************
    322           * @fn        Onboard_rand
    323           *
    324           * @brief    Random number generator
    325           *
    326           * @param   none
    327           *
    328           * @return  uint16 - new random number
    329           *
    330           *********************************************************************/

   \                                 In  segment CODE, align 2
    331          uint16 Onboard_rand( void )
   \                     Onboard_rand:
    332          {
   \   000000   2183         SUB.W   #0x2, SP
    333            uint16 randy;
    334          
    335            zapSysReq(MT_SYS_RANDOM, (uint8 *)&randy, NULL);
   \   000002   0E43         MOV.W   #0x0, R14
   \   000004   0D41         MOV.W   SP, R13
   \   000006   0D53         ADD.W   #0x0, R13
   \   000008   7C400C00     MOV.B   #0xc, R12
   \   00000C   ........     CALLA   #zapSysReq
    336            return randy;
   \   000010   2C41         MOV.W   @SP, R12
   \   000012   2153         ADD.W   #0x2, SP
   \   000014   1001         RETA
    337          }
    338          
    339          /*********************************************************************
    340           * @fn        Onboard_wait
    341           *
    342           * @brief    Delay wait
    343           *
    344           * @param   uint16 - time to wait
    345           *
    346           * @return  none
    347           *
    348           *********************************************************************/

   \                                 In  segment CODE, align 2
    349          void Onboard_wait( uint16 timeout )
   \                     Onboard_wait:
    350          {
   \   000000   103C         JMP     ??Onboard_wait_1
    351            // TODO: MSP430 Port required
    352            while (timeout--)
    353            {
    354              asm("NOP"); asm("NOP"); asm("NOP"); asm("NOP"); asm("NOP"); asm("NOP"); asm("NOP"); asm("NOP");
   \                     ??Onboard_wait_0:
   \   000002   0343         NOP
   \   000004   0343         NOP
   \   000006   0343         NOP
   \   000008   0343         NOP
   \   00000A   0343         NOP
   \   00000C   0343         NOP
   \   00000E   0343         NOP
   \   000010   0343         NOP
    355              asm("NOP"); asm("NOP"); asm("NOP"); asm("NOP"); asm("NOP"); asm("NOP"); asm("NOP"); asm("NOP");
   \   000012   0343         NOP
   \   000014   0343         NOP
   \   000016   0343         NOP
   \   000018   0343         NOP
   \   00001A   0343         NOP
   \   00001C   0343         NOP
   \   00001E   0343         NOP
   \   000020   0343         NOP
    356            }
   \                     ??Onboard_wait_1:
   \   000022   0F4C         MOV.W   R12, R15
   \   000024   3C53         ADD.W   #0xffff, R12
   \   000026   0F93         CMP.W   #0x0, R15
   \   000028   EC23         JNE     ??Onboard_wait_0
    357          }
   \   00002A   1001         RETA
    358          
    359          /*********************************************************************
    360           * @fn      osalTimeUpdate
    361           *
    362           * @brief   Uses the free running rollover count of the ZAP timer.
    363           *          This function is intended to be invoked from the background, not interrupt level.
    364           *
    365           * @param   None.
    366           *
    367           * @return  None.
    368           */

   \                                 In  segment CODE, align 2
    369          void osalTimeUpdate(void)
   \                     osalTimeUpdate:
    370          {
   \   000000   0A12         PUSH.W  R10
    371            uint16 tmp = halBrdTmrTick;
   \   000002   1F42....     MOV.W   &halBrdTmrTick, R15
    372          
    373            if (tmp != halBrdTmrTickShdw)
   \   000006   1F92....     CMP.W   &halBrdTmrTickShdw, R15
   \   00000A   1924         JEQ     ??osalTimeUpdate_0
    374            {
    375              // Calculate the elapsed ticks of the free-running timer.
    376              uint16 elapsedMSec = tmp - halBrdTmrTickShdw;
   \   00000C   0A4F         MOV.W   R15, R10
   \   00000E   1A82....     SUB.W   &halBrdTmrTickShdw, R10
    377            
    378              // Store the ZAP Timer tick count for the next time through this function.
    379              halBrdTmrTickShdw = tmp;
   \   000012   824F....     MOV.W   R15, &halBrdTmrTickShdw
    380            
    381              osalTimerUpdate(elapsedMSec);
   \   000016   0C4A         MOV.W   R10, R12
   \   000018   ........     CALLA   #osalTimerUpdate
    382              osalClockUpdate(elapsedMSec);
   \   00001C   825A....     ADD.W   R10, &timeMSec
   \   000020   1A42....     MOV.W   &timeMSec, R10
   \   000024   3A90E903     CMP.W   #0x3e9, R10
   \   000028   0A28         JNC     ??osalTimeUpdate_0
   \   00002A   ........     CALLA   #?Subroutine0
    383            }
   \                     ??CrossCallReturnLabel_0:
   \   00002E   825C....     ADD.W   R12, &OSAL_timeSeconds
   \   000032   8263....     ADDC.W  #0x0, &OSAL_timeSeconds + 2
   \   000036   ........     CALLA   #?Subroutine0
   \                     ??CrossCallReturnLabel_1:
   \   00003A   824E....     MOV.W   R14, &timeMSec
    384          }
   \                     ??osalTimeUpdate_0:
   \   00003E   3A41         POP.W   R10
   \   000040   1001         RETA

   \                                 In  segment CODE, align 2
   \                     ?Subroutine0:
   \   000000   0C4A         MOV.W   R10, R12
   \   000002   3E40E803     MOV.W   #0x3e8, R14
   \   000006   ........     BRA     #?DivMod16u
    385          
    386          /*********************************************************************
    387           * @fn      osal_getClock
    388           *
    389           * @brief   Gets the current time.  This will only return the seconds
    390           *          portion of time and doesn't include the factional second
    391           *          counter.
    392           *
    393           * @param   none
    394           *
    395           * @return  number of seconds since 0 hrs, 0 minutes, 0 seconds,
    396           *          on the 1st of January 2000 UTC
    397           */

   \                                 In  segment CODE, align 2
    398          UTCTime osal_getClock( void )
   \                     osal_getClock:
    399          {
    400            return ( OSAL_timeSeconds );
   \   000000   1C42....     MOV.W   &OSAL_timeSeconds, R12
   \   000004   1D42....     MOV.W   &OSAL_timeSeconds + 2, R13
   \   000008   1001         RETA
    401          }
    402          

   \                                 In  segment CODE, align 2
    403          void HalBoardDelay(uint16 delay, uint8 sleep)
   \                     HalBoardDelay:
    404          {
    405            halBrdTmrDly = halBrdTmrTick + delay + 1;
   \   000000   1C52....     ADD.W   &halBrdTmrTick, R12
   \   000004   1C53         ADD.W   #0x1, R12
   \   000006   824C....     MOV.W   R12, &halBrdTmrDly
    406            halBrdTmrDlyF = TRUE;
   \   00000A   D243....     MOV.B   #0x1, &halBrdTmrDlyF
    407          
    408            if (sleep)
   \   00000E   4D93         CMP.B   #0x0, R13
   \   000010   0224         JEQ     ??HalBoardDelay_0
    409            {
    410              halBrdDlySleep = TRUE;
   \   000012   D243....     MOV.B   #0x1, &halBrdDlySleep
    411            }
    412            __low_power_mode_1();
   \                     ??HalBoardDelay_0:
   \   000016   32D05800     BIS.W   #0x58, SR
    413          
    414            halBrdDlySleep = FALSE;
   \   00001A   C243....     MOV.B   #0x0, &halBrdDlySleep
    415          }
   \   00001E   1001         RETA
    416          

   \                                 In  segment CODE, align 2
    417          uint8 HalBoardDelayed(void)
   \                     HalBoardDelayed:
    418          {
    419            return halBrdTmrDlyF;
   \   000000   5C42....     MOV.B   &halBrdTmrDlyF, R12
   \   000004   1001         RETA
    420          }
    421          
    422          // Timer A0 interrupt service routine

   \                                 In  segment ISR_CODE, align 2
    423          HAL_ISR_FUNCTION(HalBoardTimerRolloverIsr, TIMER0_A0_VECTOR)
   \                     HalBoardTimerRolloverIsr:
    424          {
   \   000000   0F12         PUSH.W  R15
    425            if (++halBrdTmrTick == halBrdTmrDly)
   \   000002   1F42....     MOV.W   &halBrdTmrTick, R15
   \   000006   1F53         ADD.W   #0x1, R15
   \   000008   824F....     MOV.W   R15, &halBrdTmrTick
   \   00000C   1F92....     CMP.W   &halBrdTmrDly, R15
   \   000010   0520         JNE     ??HalBoardTimerRolloverIsr_0
    426            {
    427              halBrdTmrDlyF = FALSE;
   \   000012   C243....     MOV.B   #0x0, &halBrdTmrDlyF
    428              __low_power_mode_off_on_exit();
   \   000016   B1C0F0000200 BIC.W   #0xf0, 0x2(SP)
    429            }
    430            if (!halBrdDlySleep)
   \                     ??HalBoardTimerRolloverIsr_0:
   \   00001C   C293....     CMP.B   #0x0, &halBrdDlySleep
   \   000020   0320         JNE     ??HalBoardTimerRolloverIsr_1
    431            {
    432              __low_power_mode_off_on_exit();
   \   000022   B1C0F0000200 BIC.W   #0xf0, 0x2(SP)
    433            }
    434          }
   \                     ??HalBoardTimerRolloverIsr_1:
   \   000028   3F41         POP.W   R15
   \   00002A   0013         RETI
    435          

   \                                 In  segment ISR_CODE, align 2
    436          HAL_ISR_FUNCTION(HalBoardPort1Isr, PORT1_VECTOR)
   \                     HalBoardPort1Isr:
    437          {
    438            P1IFG = 0;
   \   000000   C2431C02     MOV.B   #0x0, &0x21c
    439            __low_power_mode_off_on_exit();
   \   000004   B1C0F0000000 BIC.W   #0xf0, 0(SP)
    440          }
   \   00000A   0013         RETI
   \   00000C                REQUIRE _A_PAIFG_L

   \                                 In  segment INTVEC, offset 0x5e, root
   \                     `??HalBoardPort1Isr??INTVEC 94`:
   \   00005E   ....         DC16    HalBoardPort1Isr

   \                                 In  segment INTVEC, offset 0x6c, root
   \                     `??HalBoardTimerRolloverIsr??INTVEC 108`:
   \   00006C   ....         DC16    HalBoardTimerRolloverIsr

   \                                 In  segment DATA16_ID, align 1, align-sorted
   \                     `?<Initializer for registeredKeysTaskID>`:
   \   000000   FF           DC8 255
    441          
    442          /*********************************************************************
    443          *********************************************************************/

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
       4  HalBoardDelay
       4  HalBoardDelayed
       4  HalBoardPort1Isr
       6  HalBoardTimerRolloverIsr
       4  InitBoard
            4 -> HalKeyConfig
       4  InitClock
       4  OnBoard_KeyCallback
            4 -> OnBoard_SendKeys
       8  OnBoard_SendKeys
            8 -> osal_msg_allocate
            8 -> osal_msg_send
       4  OnBoard_stack_used
       6  Onboard_rand
            6 -> zapSysReq
       4  Onboard_wait
       4  RegisterForKeys
      22  _itoa
       6  osalTimeUpdate
            6 -> osalTimerUpdate
       4  osal_getClock


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       1  ?<Initializer for registeredKeysTaskID>
       2  ??HalBoardPort1Isr??INTVEC 94
       2  ??HalBoardTimerRolloverIsr??INTVEC 108
      10  ?Subroutine0
      32  HalBoardDelay
       6  HalBoardDelayed
      12  HalBoardPort1Isr
      44  HalBoardTimerRolloverIsr
      18  InitBoard
      20  InitClock
       4  OSAL_timeSeconds
      12  OnBoard_KeyCallback
      56  OnBoard_SendKeys
      50  OnBoard_stack_used
       1  OnboardKeyIntEnable
      22  Onboard_rand
      44  Onboard_wait
       6  RegisterForKeys
       2  TA0CCR0
       2  TA0CCTL0
       2  TA0CTL
       2  _A_PAIFG_L
     100  _itoa
       1  halBrdDlySleep
       2  halBrdTmrDly
       1  halBrdTmrDlyF
       2  halBrdTmrTick
       2  halBrdTmrTickShdw
      66  osalTimeUpdate
      10  osal_getClock
       1  registeredKeysTaskID
       2  timeMSec

 
 452 bytes in segment CODE
   8 bytes in segment DATA16_AN
   1 byte  in segment DATA16_I
   1 byte  in segment DATA16_ID
  15 bytes in segment DATA16_Z
   4 bytes in segment INTVEC
  56 bytes in segment ISR_CODE
 
 508 bytes of CODE  memory
   1 byte  of CONST memory (+ 4 bytes shared)
  16 bytes of DATA  memory (+ 8 bytes shared)

Errors: none
Warnings: none
