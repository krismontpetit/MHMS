###############################################################################
#                                                                             #
# IAR C/C++ Compiler V5.51.2.50607/W32 for MSP430       18/Apr/2013  16:58:52 #
# Copyright 1996-2012 IAR Systems AB.                                         #
#                                                                             #
#    __rt_version  =  3                                                       #
#    __double_size =  32                                                      #
#    __reg_r4      =  free                                                    #
#    __reg_r5      =  free                                                    #
#    __pic         =  no                                                      #
#    __core        =  430X                                                    #
#    __data_model  =  small                                                   #
#    Source file   =  C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Components\hal\target\MSP5438ZAP\hal_led.c             #
#    Command line  =  -f C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2. #
#                     5.1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\Source\zap.c #
#                     fg (-DZAP_PHY_SPI=1 -DZAP_PHY_UART=0                    #
#                     -DZAP_DEVICETYPE=ZG_DEVICETYPE_ROUTER                   #
#                     -DTVSA_DEVICE_ID=0x0016 -DTVSA_DONGLE=1 -DHAL_UART=1    #
#                     -DZAP_PHY_RESET_ZNP=TRUE -DZAP_ZNP_MT=FALSE             #
#                     -DZAP_APP_MSG=FALSE -DZAP_SBL_PROXY=FALSE               #
#                     -DZAP_AUTO_CFG=TRUE -DZAP_AUTO_START=TRUE               #
#                     -DZAP_NV_RESTORE=FALSE -DLCD_SUPPORTED                  #
#                     -DZAP_AF_DATA_REQ_FRAG=FALSE                            #
#                     -DZAP_AF_DATA_REQ_AREQ=!ZAP_AF_DATA_REQ_FRAG            #
#                     -DZAP_ZDO_STARTUP_AREQ=TRUE -DZAP_AF_FUNC               #
#                     -DZAP_SAPI_FUNC -DZAP_SYS_FUNC -DZAP_UTIL_FUNC          #
#                     -DZAP_ZDO_FUNC -DSECURE=0 -DZG_SECURE_DYNAMIC=0         #
#                     "-DDEFAULT_CHANLIST=(uint32)0x00000800"                 #
#                     -DZDAPP_CONFIG_PAN_ID=0xFFFF -DPOLL_RATE=1000           #
#                     -DNWK_START_DELAY=100 -DMAX_BINDING_CLUSTER_IDS=4)      #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Components\hal\target\MSP5438ZAP\hal_led.c -D          #
#                     ZAP_DEVICETYPE=ZG_DEVICETYPE_ROUTER -D                  #
#                     TVSA_DEVICE_ID=0x0016 -lC "C:\Users\student\Documents\G #
#                     itHub\MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EX #
#                     P5438\ZAP Router\List\" -lA                             #
#                     "C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5. #
#                     1\Projects\zstack\ZAP\TVSA\EXP5438\ZAP Router\List\"    #
#                     --remarks --diag_suppress Pe001,Pe193,Pe236,Pe826 -o    #
#                     "C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5. #
#                     1\Projects\zstack\ZAP\TVSA\EXP5438\ZAP Router\Obj\"     #
#                     --debug -D__MSP430F5438A__ -e --double=32 --clib -I     #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\ -I                   #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\Source\ -I         #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\Source\ -I      #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\hal\target\MSP5438ZAP\ -I                          #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\hal\include\ -I C:\Users\student\Documents\GitHub\ #
#                     MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\ #
#                     ..\..\..\..\..\Components\mac\include\ -I               #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\mt\ -I C:\Users\student\Documents\GitHub\MHMS\ZAP- #
#                     MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\ #
#                     ..\..\Components\osal\include\ -I                       #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\osal\mcu\msp430\ -I C:\Users\student\Documents\Git #
#                     Hub\MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5 #
#                     438\..\..\..\..\..\Components\services\saddr\ -I        #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\services\sdata\ -I C:\Users\student\Documents\GitH #
#                     ub\MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP54 #
#                     38\..\..\..\..\..\Components\stack\af\ -I               #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\stack\nwk\ -I C:\Users\student\Documents\GitHub\MH #
#                     MS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\.. #
#                     \..\..\..\..\Components\stack\sapi\ -I                  #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\stack\sec\ -I C:\Users\student\Documents\GitHub\MH #
#                     MS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\.. #
#                     \..\..\..\..\Components\stack\sys\ -I                   #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\stack\zdo\ -I C:\Users\student\Documents\GitHub\MH #
#                     MS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\.. #
#                     \..\..\..\..\Components\zmac\ -I                        #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\zmac\f8w\ --core=430X --data_model=small -Ohz      #
#                     --multiplier=32 --multiplier_location=4C0               #
#                     --require_prototypes --hw_workaround=CPU40              #
#                     --hw_workaround=CPU42                                   #
#    List file     =  C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\ZAP                   #
#                     Router\List\hal_led.lst                                 #
#    Object file   =  C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\ZAP                   #
#                     Router\Obj\hal_led.r43                                  #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1\Components\hal\target\MSP5438ZAP\hal_led.c
      1          /***************************************************************************************************
      2            Filename:       hal_led.c
      3            Revised:        $Date: 2012-02-14 12:43:32 -0800 (Tue, 14 Feb 2012) $
      4            Revision:       $Revision: 29281 $
      5          
      6          
      7            Description:    This file contains the interface to the HAL LED Service.
      8          
      9          
     10            Copyright 2006-2012 Texas Instruments Incorporated. All rights reserved.
     11          
     12            IMPORTANT: Your use of this Software is limited to those specific rights
     13            granted under the terms of a software license agreement between the user
     14            who downloaded the software, his/her employer (which must be your employer)
     15            and Texas Instruments Incorporated (the "License"). You may not use this
     16            Software unless you agree to abide by the terms of the License. The License
     17            limits your use, and you acknowledge, that the Software may not be modified,
     18            copied or distributed unless embedded on a Texas Instruments microcontroller
     19            or used solely and exclusively in conjunction with a Texas Instruments radio
     20            frequency transceiver, which is integrated into your product. Other than for
     21            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     22            works of, modify, distribute, perform, display or sell this Software and/or
     23            its documentation for any purpose.
     24          
     25            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     26            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, 
     27            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE, 
     28            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     29            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     30            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     31            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     32            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     33            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     34            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     35            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     36          
     37            Should you have any questions regarding your right to use this Software,
     38            contact Texas Instruments Incorporated at www.TI.com. 
     39          **************************************************************************************************/
     40          
     41          /***************************************************************************************************
     42           *                                             INCLUDES
     43           ***************************************************************************************************/
     44          #include "hal_types.h"
     45          #include "hal_led.h"

   \                                 In  segment DATA16_AN, at 0x202
   \   union <unnamed> _A_PAOUT_L
   \                     _A_PAOUT_L:
   \   000000                DS8 2
     46          #include "OSAL.h"
     47          #include "hal_drivers.h"
     48          #include "hal_mcu.h"
     49          
     50          /***************************************************************************************************
     51           *                                              MACROS
     52           ***************************************************************************************************/
     53          
     54          
     55          /***************************************************************************************************
     56           *                                             CONSTANTS
     57           ***************************************************************************************************/
     58          
     59          
     60          /***************************************************************************************************
     61           *                                              TYPEDEFS
     62           ***************************************************************************************************/
     63          /* LED control structure */
     64          typedef struct {
     65            uint8 mode;    // Operation mode
     66            uint8 todo;    // Blink cycles left
     67            uint8 onPct;   // On cycle percentage
     68            uint16 time;  // On/off cycle time (msec)
     69            uint32 next;  // Time for next change
     70          } HalLedControl_t;
     71          
     72          
     73          /***************************************************************************************************
     74           *                                           GLOBAL VARIABLES
     75           ***************************************************************************************************/
     76          
     77          

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     78          static uint8 ledState;                 // LED state at last set/clr/blink update
   \                     ledState:
   \   000000                DS8 1
     79          
     80          #ifdef POWER_SAVING
     81          static uint8 sleepLedState;            // Saved state of the LEDs
     82          #endif
     83          
     84          #if (HAL_LED == TRUE)

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     85          static uint8 preBlinkState;            // Original State before going to blink mode
   \                     preBlinkState:
   \   000000                DS8 1
     86                                                 // bit 0, 1, 2, 3 represent led 0, 1, 2, 3
     87          #endif /* HAL_LED */
     88          
     89          #if (HAL_LED == TRUE)

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     90            static HalLedControl_t HalLedStatusTable[HAL_LED_DEFAULT_MAX_LEDS];   // LED Status Table
   \                     HalLedStatusTable:
   \   000000                DS8 40
     91          #endif /* HAL_LED */
     92          
     93          /***************************************************************************************************
     94           *                                            LOCAL FUNCTION
     95           ***************************************************************************************************/
     96          #if (HAL_LED == TRUE)
     97          void HalLedUpdate( void );
     98          void HalLedOnOff( uint8 leds, uint8 mode );
     99          #endif /* HAL_LED */
    100          
    101          /***************************************************************************************************
    102           *                                            FUNCTIONS - API
    103           ***************************************************************************************************/
    104          
    105          /***************************************************************************************************
    106           * @fn      HalLedInit
    107           *
    108           * @brief   Initialize LED Service
    109           *
    110           * @param   init - pointer to void that contains the initialized value
    111           *
    112           * @return  None
    113           ***************************************************************************************************/

   \                                 In  segment CODE, align 2
    114          void HalLedInit ( void )
   \                     HalLedInit:
    115          {
    116          #if (HAL_LED == TRUE)
    117            HalLedSet (HAL_LED_ALL, HAL_LED_MODE_OFF);
   \   000000   4D43         MOV.B   #0x0, R13
   \   000002   7C400F00     MOV.B   #0xf, R12
   \   000006   ........     BRA     #HalLedSet
    118          #endif /* HAL_LED */
    119          }
    120          
    121          /***************************************************************************************************
    122           * @fn      HalLedSet
    123           *
    124           * @brief   Tun ON/OFF/TOGGLE given LEDs
    125           *
    126           * @param   led - bit mask value of leds to be turned ON/OFF/TOGGLE
    127           *          mode - BLINK, FLASH, TOGGLE, ON, OFF
    128           * @return  None
    129           ***************************************************************************************************/

   \                                 In  segment CODE, align 2
    130          uint8 HalLedSet ( uint8 leds, uint8 mode )
   \                     HalLedSet:
    131          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   4A4C         MOV.B   R12, R10
   \   000004   4F4D         MOV.B   R13, R15
    132          #if (defined (BLINK_LEDS)) && (HAL_LED == TRUE)
    133            uint8 led;
    134            HalLedControl_t *sts;
    135          
    136            switch (mode)
   \   000006   4E4D         MOV.B   R13, R14
   \   000008   4E83         SUB.B   #0x0, R14
   \   00000A   1B24         JEQ     ??HalLedSet_4
   \   00000C   5E83         SUB.B   #0x1, R14
   \   00000E   1924         JEQ     ??HalLedSet_4
   \   000010   5E83         SUB.B   #0x1, R14
   \   000012   0524         JEQ     ??HalLedSet_5
   \   000014   6E83         SUB.B   #0x2, R14
   \   000016   0E24         JEQ     ??HalLedSet_6
   \   000018   6E82         SUB.B   #0x4, R14
   \   00001A   1324         JEQ     ??HalLedSet_4
   \   00001C   073C         JMP     ??HalLedSet_0
    137            {
    138              case HAL_LED_MODE_BLINK:
    139                // Default blink, 1 time, D% duty cycle
    140                HalLedBlink( leds, 1, HAL_LED_DEFAULT_DUTY_CYCLE, HAL_LED_DEFAULT_FLASH_TIME );
   \                     ??HalLedSet_5:
   \   00001E   3F40E803     MOV.W   #0x3e8, R15
   \   000022   7E400500     MOV.B   #0x5, R14
   \   000026   5D43         MOV.B   #0x1, R13
   \                     ??HalLedSet_7:
   \   000028   ........     CALLA   #HalLedBlink
    141                break;
    142          
    143              case HAL_LED_MODE_FLASH:
    144                // Default flash, N times, D% duty cycle
    145                HalLedBlink( leds, HAL_LED_DEFAULT_FLASH_COUNT, HAL_LED_DEFAULT_DUTY_CYCLE, HAL_LED_DEFAULT_FLASH_TIME );
    146                break;
    147          
    148              case HAL_LED_MODE_ON:
    149              case HAL_LED_MODE_OFF:
    150              case HAL_LED_MODE_TOGGLE:
    151                led = HAL_LED_1;
    152                leds &= HAL_LED_ALL;
    153                sts = HalLedStatusTable;
    154          
    155                while ( leds )
    156                {
    157                  if ( leds & led )
    158                  {
    159                    if ( mode != HAL_LED_MODE_TOGGLE )
    160                      sts->mode = mode;  // ON or OFF
    161                    else
    162                      sts->mode ^= HAL_LED_MODE_ON;  // Toggle
    163                    HalLedOnOff( led, sts->mode );
    164                    leds ^= led;
    165                  }
    166                  led <<= 1;
    167                  sts++;
    168                }
    169                break;
    170          
    171              default:
    172                break;
    173            }
    174          
    175          #elif (HAL_LED == TRUE)
    176            HalLedOnOff( leds, mode );
    177          #endif /* BLINK_LEDS && HAL_LED */
    178          
    179            return ( ledState );
   \                     ??HalLedSet_0:
   \   00002C   5C42....     MOV.B   &ledState, R12
   \   000030   3817         POPM.W  #0x4, R11
   \   000032   1001         RETA
   \                     ??HalLedSet_6:
   \   000034   3F40E803     MOV.W   #0x3e8, R15
   \   000038   7E400500     MOV.B   #0x5, R14
   \   00003C   7D403200     MOV.B   #0x32, R13
   \   000040   F33F         JMP     ??HalLedSet_7
   \                     ??HalLedSet_4:
   \   000042   5B43         MOV.B   #0x1, R11
   \   000044   7AF00F00     AND.B   #0xf, R10
   \   000048   3840....     MOV.W   #HalLedStatusTable, R8
   \   00004C   0C3C         JMP     ??HalLedSet_8
   \                     ??HalLedSet_2:
   \   00004E   6E48         MOV.B   @R8, R14
   \   000050   5EE3         XOR.B   #0x1, R14
   \                     ??HalLedSet_3:
   \   000052   C84E0000     MOV.B   R14, 0(R8)
   \   000056   4D4E         MOV.B   R14, R13
   \   000058   4C4B         MOV.B   R11, R12
   \   00005A   ........     CALLA   #HalLedOnOff
   \   00005E   4AEB         XOR.B   R11, R10
   \                     ??HalLedSet_1:
   \   000060   4B5B         RLA.B   R11
   \   000062   38500A00     ADD.W   #0xa, R8
   \                     ??HalLedSet_8:
   \   000066   4A93         CMP.B   #0x0, R10
   \   000068   E127         JEQ     ??HalLedSet_0
   \   00006A   4ABB         BIT.B   R11, R10
   \   00006C   F927         JEQ     ??HalLedSet_1
   \   00006E   7F92         CMP.B   #0x8, R15
   \   000070   EE27         JEQ     ??HalLedSet_2
   \   000072   4E4F         MOV.B   R15, R14
   \   000074   EE3F         JMP     ??HalLedSet_3
   \   000076   0343         NOP
    180          }
    181          
    182          /***************************************************************************************************
    183           * @fn      HalLedBlink
    184           *
    185           * @brief   Blink the leds
    186           *
    187           * @param   leds       - bit mask value of leds to be blinked
    188           *          numBlinks  - number of blinks, 0 for continuous
    189           *          percent    - the percentage in each period where the led
    190           *                       will be on
    191           *          period     - length of each cycle in milliseconds
    192           *
    193           * @return  None
    194           ***************************************************************************************************/

   \                                 In  segment CODE, align 2
    195          void HalLedBlink ( uint8 leds, uint8 numBlinks, uint8 percent, uint16 period )
   \                     HalLedBlink:
    196          {
   \   000000   5B15         PUSHM.W #0x6, R11
   \   000002   4A4C         MOV.B   R12, R10
   \   000004   4B4D         MOV.B   R13, R11
   \   000006   484E         MOV.B   R14, R8
   \   000008   094F         MOV.W   R15, R9
    197          #if (defined (BLINK_LEDS)) && (HAL_LED == TRUE)
    198            uint8 led;
    199            HalLedControl_t *sts;
    200          
    201            if ( leds && percent && period )
   \   00000A   4C93         CMP.B   #0x0, R12
   \   00000C   3B24         JEQ     ??HalLedBlink_1
   \   00000E   4E93         CMP.B   #0x0, R14
   \   000010   3924         JEQ     ??HalLedBlink_1
   \   000012   0F93         CMP.W   #0x0, R15
   \   000014   3724         JEQ     ??HalLedBlink_1
    202            {
    203              if ( percent < 100 )
   \   000016   7E906400     CMP.B   #0x64, R14
   \   00001A   322C         JC      ??HalLedBlink_2
    204              {
    205                led = HAL_LED_1;
   \   00001C   5643         MOV.B   #0x1, R6
    206                leds &= HAL_LED_ALL;
   \   00001E   7AF00F00     AND.B   #0xf, R10
    207                sts = HalLedStatusTable;
   \   000022   3740....     MOV.W   #HalLedStatusTable, R7
   \   000026   1F3C         JMP     ??HalLedBlink_3
    208          
    209                while ( leds )
    210                {
    211                  if ( leds & led )
   \                     ??HalLedBlink_0:
   \   000028   4AB6         BIT.B   R6, R10
   \   00002A   1A24         JEQ     ??HalLedBlink_4
    212                  {
    213                    /* Store the current state of the led before going to blinking */
    214                    preBlinkState |= (led & ledState);
   \   00002C   4E46         MOV.B   R6, R14
   \   00002E   5EF2....     AND.B   &ledState, R14
   \   000032   C2DE....     BIS.B   R14, &preBlinkState
    215          
    216                    sts->mode  = HAL_LED_MODE_OFF;                   // Stop previous blink
   \   000036   4E43         MOV.B   #0x0, R14
    217                    sts->time  = period;                             // Time for one on/off cycle
   \   000038   87490400     MOV.W   R9, 0x4(R7)
    218                    sts->onPct = percent;                            // % of cycle LED is on
   \   00003C   C7480200     MOV.B   R8, 0x2(R7)
    219                    sts->todo  = numBlinks;                          // Number of blink cycles
   \   000040   C74B0100     MOV.B   R11, 0x1(R7)
    220                    if ( !numBlinks ) sts->mode |= HAL_LED_MODE_FLASH;   // Continuous
   \   000044   4B93         CMP.B   #0x0, R11
   \   000046   0120         JNE     ??HalLedBlink_5
   \   000048   6E42         MOV.B   #0x4, R14
   \                     ??HalLedBlink_5:
   \   00004A   C74E0000     MOV.B   R14, 0(R7)
    221                    sts->next = osal_GetSystemClock();               // Start now
   \   00004E   ........     CALLA   #osal_GetSystemClock
   \   000052   874C0600     MOV.W   R12, 0x6(R7)
   \   000056   874D0800     MOV.W   R13, 0x8(R7)
    222                    sts->mode |= HAL_LED_MODE_BLINK;                 // Enable blinking
   \   00005A   E7D30000     BIS.B   #0x2, 0(R7)
    223                    leds ^= led;
   \   00005E   4AE6         XOR.B   R6, R10
    224                  }
    225                  led <<= 1;
   \                     ??HalLedBlink_4:
   \   000060   4656         RLA.B   R6
    226                  sts++;
   \   000062   37500A00     ADD.W   #0xa, R7
    227                }
   \                     ??HalLedBlink_3:
   \   000066   4A93         CMP.B   #0x0, R10
   \   000068   DF23         JNE     ??HalLedBlink_0
    228                osal_stop_timerEx(Hal_TaskID, HAL_LED_BLINK_EVENT);
   \   00006A   2D43         MOV.W   #0x2, R13
   \   00006C   5C42....     MOV.B   &Hal_TaskID, R12
   \   000070   ........     CALLA   #osal_stop_timerEx
    229                osal_set_event( Hal_TaskID, HAL_LED_BLINK_EVENT );
   \   000074   2D43         MOV.W   #0x2, R13
   \   000076   5C42....     MOV.B   &Hal_TaskID, R12
   \   00007A   ........     CALLA   #osal_set_event
   \   00007E   053C         JMP     ??HalLedBlink_6
    230              }
    231              else
    232                HalLedSet( leds, HAL_LED_MODE_ON );  // >= 100%, turn on
   \                     ??HalLedBlink_2:
   \   000080   5D43         MOV.B   #0x1, R13
   \   000082   013C         JMP     ??HalLedBlink_7
    233            }
    234            else
    235              HalLedSet( leds, HAL_LED_MODE_OFF );   // No on time, turn off
   \                     ??HalLedBlink_1:
   \   000084   4D43         MOV.B   #0x0, R13
   \                     ??HalLedBlink_7:
   \   000086   ........     CALLA   #HalLedSet
    236          #elif (HAL_LED == TRUE)
    237            percent = (leds & ledState) ? HAL_LED_MODE_OFF : HAL_LED_MODE_ON;
    238            HalLedOnOff( leds, percent );           // Toggle
    239          #endif /* BLINK_LEDS && HAL_LED */
    240          }
   \                     ??HalLedBlink_6:
   \   00008A   5617         POPM.W  #0x6, R11
   \   00008C   1001         RETA
    241          
    242          #if (HAL_LED == TRUE)
    243          /***************************************************************************************************
    244           * @fn      HalLedUpdate
    245           *
    246           * @brief   Update leds to work with blink
    247           *
    248           * @param   none
    249           *
    250           * @return  none
    251           ***************************************************************************************************/

   \                                 In  segment CODE, align 2
    252          void HalLedUpdate( void )
   \                     HalLedUpdate:
    253          {
   \   000000   7B15         PUSHM.W #0x8, R11
    254          #if (defined (BLINK_LEDS))
    255            uint8 led;
    256            uint8 pct;
    257            uint8 leds;
    258            HalLedControl_t *sts;
    259            uint32 time;
    260            uint16 next;
    261            uint16 wait;
    262          
    263            next = 0;
   \   000002   0643         MOV.W   #0x0, R6
    264            led  = HAL_LED_1;
   \   000004   5A43         MOV.B   #0x1, R10
    265            leds = HAL_LED_ALL;
   \   000006   77400F00     MOV.B   #0xf, R7
    266            sts  = HalLedStatusTable;
   \   00000A   3B40....     MOV.W   #HalLedStatusTable, R11
    267          
    268            while ( leds )
    269            {
    270              if ( leds & led )
   \                     ??HalLedUpdate_0:
   \   00000E   47BA         BIT.B   R10, R7
   \   000010   6124         JEQ     ??HalLedUpdate_1
    271              {
    272                if ( sts->mode & HAL_LED_MODE_BLINK )
   \   000012   EBB30000     BIT.B   #0x2, 0(R11)
   \   000016   5D28         JNC     ??HalLedUpdate_2
    273                {
    274                  time = osal_GetSystemClock();
   \   000018   ........     CALLA   #osal_GetSystemClock
   \   00001C   084C         MOV.W   R12, R8
   \   00001E   094D         MOV.W   R13, R9
    275                  if ( time >= sts->next )
   \   000020   144B0600     MOV.W   0x6(R11), R4
   \   000024   1F4B0800     MOV.W   0x8(R11), R15
   \   000028   0D9F         CMP.W   R15, R13
   \   00002A   4B28         JNC     ??HalLedUpdate_3
   \   00002C   0220         JNE     ??HalLedUpdate_4
   \   00002E   0C94         CMP.W   R4, R12
   \   000030   4828         JNC     ??HalLedUpdate_3
    276                  {
    277                    if (sts->mode & HAL_LED_MODE_ON )
   \                     ??HalLedUpdate_4:
   \   000032   DBB30000     BIT.B   #0x1, 0(R11)
   \   000036   1028         JNC     ??HalLedUpdate_5
    278                    {
    279                      pct = 100 - sts->onPct;               // Percentage of cycle for off
   \   000038   75406400     MOV.B   #0x64, R5
   \   00003C   558B0200     SUB.B   0x2(R11), R5
    280                      sts->mode &= ~HAL_LED_MODE_ON;        // Say it's not on
   \   000040   DBC30000     BIC.B   #0x1, 0(R11)
    281                      HalLedOnOff( led, HAL_LED_MODE_OFF ); // Turn it off
   \   000044   4D43         MOV.B   #0x0, R13
   \   000046   4C4A         MOV.B   R10, R12
   \   000048   ........     CALLA   #HalLedOnOff
    282          
    283                      if (!(sts->mode & HAL_LED_MODE_FLASH))
   \   00004C   EBB20000     BIT.B   #0x4, 0(R11)
   \   000050   142C         JC      ??HalLedUpdate_6
    284                      {
    285                        sts->todo--;                        /* Not continuous, reduce count */
   \   000052   FB530100     ADD.B   #0xff, 0x1(R11)
   \   000056   113C         JMP     ??HalLedUpdate_6
    286                      }
    287                    }
    288                    else if ( !(sts->todo) && !(sts->mode & HAL_LED_MODE_FLASH) )
   \                     ??HalLedUpdate_5:
   \   000058   CB930100     CMP.B   #0x0, 0x1(R11)
   \   00005C   0620         JNE     ??HalLedUpdate_7
   \   00005E   EBB20000     BIT.B   #0x4, 0(R11)
   \   000062   032C         JC      ??HalLedUpdate_7
    289                    {
    290                      sts->mode ^= HAL_LED_MODE_BLINK;  /* No more blinks */
   \   000064   EBE30000     XOR.B   #0x2, 0(R11)
   \   000068   083C         JMP     ??HalLedUpdate_6
    291                    }
    292                    else
    293                    {
    294                      pct = sts->onPct;                     /* Percentage of cycle for on */
   \                     ??HalLedUpdate_7:
   \   00006A   554B0200     MOV.B   0x2(R11), R5
    295                      sts->mode |= HAL_LED_MODE_ON;         /* Say it's on */
   \   00006E   DBD30000     BIS.B   #0x1, 0(R11)
    296                      HalLedOnOff (led, HAL_LED_MODE_ON);   /* Turn it on */
   \   000072   5D43         MOV.B   #0x1, R13
   \   000074   4C4A         MOV.B   R10, R12
   \   000076   ........     CALLA   #HalLedOnOff
    297                    }
    298                    if ( sts->mode & HAL_LED_MODE_BLINK )
   \                     ??HalLedUpdate_6:
   \   00007A   EBB30000     BIT.B   #0x2, 0(R11)
   \   00007E   1228         JNC     ??HalLedUpdate_8
    299                    {
    300                      wait = (((uint32)pct * (uint32)sts->time) / 100);
   \   000080   4C45         MOV.B   R5, R12
   \   000082   1E4B0400     MOV.W   0x4(R11), R14
   \   000086   ........     CALLA   #?Mul16to32u
   \   00008A   3E406400     MOV.W   #0x64, R14
   \   00008E   0F43         MOV.W   #0x0, R15
   \   000090   ........     CALLA   #?DivMod32u
   \   000094   044C         MOV.W   R12, R4
    301                      sts->next = time + wait;
   \   000096   085C         ADD.W   R12, R8
   \   000098   0963         ADDC.W  #0x0, R9
   \   00009A   8B480600     MOV.W   R8, 0x6(R11)
   \   00009E   8B490800     MOV.W   R9, 0x8(R11)
   \   0000A2   103C         JMP     ??HalLedUpdate_9
    302                    }
    303                    else
    304                    {
    305                      /* no more blink, no more wait */
    306                      wait = 0;
   \                     ??HalLedUpdate_8:
   \   0000A4   0443         MOV.W   #0x0, R4
    307                      /* After blinking, set the LED back to the state before it blinks */
    308                      HalLedSet (led, ((preBlinkState & led)!=0)?HAL_LED_MODE_ON:HAL_LED_MODE_OFF);
   \   0000A6   C2BA....     BIT.B   R10, &preBlinkState
   \   0000AA   0220         JNE     ??HalLedUpdate_10
   \   0000AC   4D43         MOV.B   #0x0, R13
   \   0000AE   013C         JMP     ??HalLedUpdate_11
   \                     ??HalLedUpdate_10:
   \   0000B0   5D43         MOV.B   #0x1, R13
   \                     ??HalLedUpdate_11:
   \   0000B2   4C4A         MOV.B   R10, R12
   \   0000B4   ........     CALLA   #HalLedSet
    309                      /* Clear the saved bit */
    310                      preBlinkState &= (0xff ^ led);
   \   0000B8   4E4A         MOV.B   R10, R14
   \   0000BA   7EE3         XOR.B   #0xff, R14
   \   0000BC   C2FE....     AND.B   R14, &preBlinkState
   \   0000C0   013C         JMP     ??HalLedUpdate_9
    311                    }
    312                  }
    313                  else
    314                    wait = sts->next - time;  // Time left
   \                     ??HalLedUpdate_3:
   \   0000C2   048C         SUB.W   R12, R4
    315          
    316                  if ( !next || ( wait && (wait < next) ) )
   \                     ??HalLedUpdate_9:
   \   0000C4   0693         CMP.W   #0x0, R6
   \   0000C6   0424         JEQ     ??HalLedUpdate_12
   \   0000C8   0493         CMP.W   #0x0, R4
   \   0000CA   0324         JEQ     ??HalLedUpdate_2
   \   0000CC   0496         CMP.W   R6, R4
   \   0000CE   012C         JC      ??HalLedUpdate_2
    317                    next = wait;
   \                     ??HalLedUpdate_12:
   \   0000D0   0644         MOV.W   R4, R6
    318                }
    319                leds ^= led;
   \                     ??HalLedUpdate_2:
   \   0000D2   47EA         XOR.B   R10, R7
    320              }
    321              led <<= 1;
   \                     ??HalLedUpdate_1:
   \   0000D4   4A5A         RLA.B   R10
    322              sts++;
   \   0000D6   3B500A00     ADD.W   #0xa, R11
    323            }
   \   0000DA   4793         CMP.B   #0x0, R7
   \   0000DC   9823         JNE     ??HalLedUpdate_0
    324          
    325            if ( next )
   \   0000DE   0693         CMP.W   #0x0, R6
   \   0000E0   0624         JEQ     ??HalLedUpdate_13
    326              osal_start_timerEx(Hal_TaskID, HAL_LED_BLINK_EVENT, next);  // Come back later
   \   0000E2   0E46         MOV.W   R6, R14
   \   0000E4   2D43         MOV.W   #0x2, R13
   \   0000E6   5C42....     MOV.B   &Hal_TaskID, R12
   \   0000EA   ........     CALLA   #osal_start_timerEx
    327          
    328          #endif /* BLINK_LEDS */
    329          }
   \                     ??HalLedUpdate_13:
   \   0000EE   7417         POPM.W  #0x8, R11
   \   0000F0   1001         RETA
    330          
    331          /***************************************************************************************************
    332           * @fn      HalLedOnOff
    333           *
    334           * @brief   Turns specified LED ON or OFF
    335           *
    336           * @param   leds - LED bit mask
    337           *          mode - LED_ON,LED_OFF,
    338           *
    339           * @return  none
    340           ***************************************************************************************************/

   \                                 In  segment CODE, align 2
    341          void HalLedOnOff( uint8 leds, uint8 mode )
   \                     HalLedOnOff:
    342          {
    343            if ( leds & HAL_LED_1 )
   \   000000   5CB3         BIT.B   #0x1, R12
   \   000002   ........     CALLA   #?Subroutine0
    344            {
    345              if ( mode == HAL_LED_MODE_ON )
    346                HAL_TURN_ON_LED1();
    347              else
    348                HAL_TURN_OFF_LED1();
    349            }
    350          
    351            if ( leds & HAL_LED_2 )
   \                     ??CrossCallReturnLabel_0:
   \   000006   6CB3         BIT.B   #0x2, R12
   \   000008   0728         JNC     ??HalLedOnOff_4
    352            {
    353              if ( mode == HAL_LED_MODE_ON )
   \   00000A   5D93         CMP.B   #0x1, R13
   \   00000C   0320         JNE     ??HalLedOnOff_5
    354                HAL_TURN_ON_LED2();
   \   00000E   E2D30202     BIS.B   #0x2, &0x202
   \   000012   023C         JMP     ??HalLedOnOff_4
    355              else
    356                HAL_TURN_OFF_LED2();
   \                     ??HalLedOnOff_5:
   \   000014   E2C30202     BIC.B   #0x2, &0x202
    357            }
    358          
    359            if ( leds & HAL_LED_3 )
   \                     ??HalLedOnOff_4:
   \   000018   6CB2         BIT.B   #0x4, R12
   \   00001A   ........     CALLA   #?Subroutine0
    360            {
    361              if ( mode == HAL_LED_MODE_ON )
    362                HAL_TURN_ON_LED3();
    363              else
    364                HAL_TURN_OFF_LED3();
    365            }
    366          
    367            if ( leds & HAL_LED_4 )
   \                     ??CrossCallReturnLabel_1:
   \   00001E   7CB2         BIT.B   #0x8, R12
   \   000020   0928         JNC     ??HalLedOnOff_6
    368            {
    369              if ( mode == HAL_LED_MODE_ON )
   \   000022   5D93         CMP.B   #0x1, R13
   \   000024   0520         JNE     ??HalLedOnOff_7
    370                HAL_TURN_ON_LED4();
   \   000026   E2D30202     BIS.B   #0x2, &0x202
   \   00002A   5E42....     MOV.B   &ledState, R14
   \   00002E   063C         JMP     ??HalLedOnOff_8
    371              else
    372                HAL_TURN_OFF_LED4();
   \                     ??HalLedOnOff_7:
   \   000030   E2C30202     BIC.B   #0x2, &0x202
    373            }
    374          
    375              // Remember current state
    376            if ( mode )
   \                     ??HalLedOnOff_6:
   \   000034   5E42....     MOV.B   &ledState, R14
   \   000038   4D93         CMP.B   #0x0, R13
   \   00003A   0224         JEQ     ??HalLedOnOff_9
    377              ledState |= leds;
   \                     ??HalLedOnOff_8:
   \   00003C   4EDC         BIS.B   R12, R14
   \   00003E   023C         JMP     ??HalLedOnOff_10
    378            else
    379              ledState &= (0xff ^ leds);
   \                     ??HalLedOnOff_9:
   \   000040   7CE3         XOR.B   #0xff, R12
   \   000042   4EFC         AND.B   R12, R14
   \                     ??HalLedOnOff_10:
   \   000044   C24E....     MOV.B   R14, &ledState
    380          
    381          }
   \   000048   1001         RETA
   \   00004A                REQUIRE _A_PAOUT_L

   \                                 In  segment CODE, align 2
   \                     ?Subroutine0:
   \   000000   0728         JNC     ??HalLedOnOff_0
   \   000002   5D93         CMP.B   #0x1, R13
   \   000004   0320         JNE     ??HalLedOnOff_1
   \   000006   D2D30202     BIS.B   #0x1, &0x202
   \   00000A   1001         RETA
   \                     ??HalLedOnOff_1:
   \   00000C   D2C30202     BIC.B   #0x1, &0x202
   \                     ??HalLedOnOff_0:
   \   000010   1001         RETA
    382          #endif /* HAL_LED */
    383          
    384          #ifdef POWER_SAVING
    385          /***************************************************************************************************
    386           * @fn      HalGetLedState
    387           *
    388           * @brief   Dim LED2 - Dim (set level) of LED2
    389           *
    390           * @param   none
    391           *
    392           * @return  led state
    393           ***************************************************************************************************/
    394          uint8 HalLedGetState ()
    395          {
    396            return ledState;
    397          }
    398          
    399          /***************************************************************************************************
    400           * @fn      HalLedEnterSleep
    401           *
    402           * @brief   Store current LEDs state before sleep
    403           *
    404           * @param   none
    405           *
    406           * @return  none
    407           ***************************************************************************************************/
    408          void HalLedEnterSleep( void )
    409          {
    410            sleepLedState = HalLedGetState();
    411            HalLedSet( HAL_LED_ALL, HAL_LED_MODE_OFF );
    412          }
    413          
    414          /***************************************************************************************************
    415           * @fn      HalLedExitSleep
    416           *
    417           * @brief   Restore current LEDs state after sleep
    418           *
    419           * @param   none
    420           *
    421           * @return  none
    422           ***************************************************************************************************/
    423          void HalLedExitSleep( void )
    424          {
    425            HalLedSet( sleepLedState, HAL_LED_MODE_ON );
    426          }
    427          #endif //POWER_SAVING
    428          
    429          /***************************************************************************************************
    430          ***************************************************************************************************/
    431          
    432          
    433          
    434          

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      16  HalLedBlink
            16 -> HalLedSet
            16 -> osal_GetSystemClock
            16 -> osal_set_event
            16 -> osal_stop_timerEx
       4  HalLedInit
             4 -> HalLedSet
       4  HalLedOnOff
      12  HalLedSet
            12 -> HalLedBlink
            12 -> HalLedOnOff
      20  HalLedUpdate
            20 -> HalLedOnOff
            20 -> HalLedSet
            20 -> osal_GetSystemClock
            20 -> osal_start_timerEx


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      18  ?Subroutine0
     142  HalLedBlink
      10  HalLedInit
      74  HalLedOnOff
     120  HalLedSet
      40  HalLedStatusTable
     242  HalLedUpdate
       2  _A_PAOUT_L
       1  ledState
       1  preBlinkState

 
 606 bytes in segment CODE
   2 bytes in segment DATA16_AN
  42 bytes in segment DATA16_Z
 
 606 bytes of CODE memory
  42 bytes of DATA memory (+ 2 bytes shared)

Errors: none
Warnings: none
