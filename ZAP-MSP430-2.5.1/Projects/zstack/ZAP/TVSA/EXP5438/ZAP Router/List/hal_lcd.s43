///////////////////////////////////////////////////////////////////////////////
//                                                                            /
// IAR C/C++ Compiler V5.51.2.50607/W32 for MSP430      24/Apr/2013  12:06:18 /
// Copyright 1996-2012 IAR Systems AB.                                        /
//                                                                            /
//    __rt_version  =  3                                                      /
//    __double_size =  32                                                     /
//    __reg_r4      =  free                                                   /
//    __reg_r5      =  free                                                   /
//    __pic         =  no                                                     /
//    __core        =  430X                                                   /
//    __data_model  =  small                                                  /
//    Source file   =  C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5. /
//                     1\Components\hal\target\MSP5438ZAP\hal_lcd.c           /
//    Command line  =  -f C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2 /
//                     .5.1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\Source\zap /
//                     .cfg (-DTVSA_DEVICE_ID=0x0016 -DTVSA_DONGLE=1          /
//                     -DHAL_UART=1 -DZAP_PHY_SPI=1                           /
//                     -DZAP_PHY_UART=!ZAP_PHY_SPI -DZAP_PHY_RESET_ZNP=TRUE   /
//                     -DZAP_ZNP_MT=FALSE -DZAP_APP_MSG=FALSE                 /
//                     -DZAP_SBL_PROXY=FALSE -DZAP_AUTO_CFG=TRUE              /
//                     -DZAP_AUTO_START=TRUE -DZAP_NV_RESTORE=FALSE           /
//                     -DLCD_SUPPORTED -DZAP_AF_DATA_REQ_FRAG=FALSE           /
//                     -DZAP_AF_DATA_REQ_AREQ=!ZAP_AF_DATA_REQ_FRAG           /
//                     -DZAP_ZDO_STARTUP_AREQ=TRUE -DZAP_AF_FUNC              /
//                     -DZAP_SAPI_FUNC -DZAP_SYS_FUNC -DZAP_UTIL_FUNC         /
//                     -DZAP_ZDO_FUNC -DSECURE=0 -DZG_SECURE_DYNAMIC=0        /
//                     "-DDEFAULT_CHANLIST=(uint32)0x00000800"                /
//                     -DZDAPP_CONFIG_PAN_ID=0xFFFF -DPOLL_RATE=1000          /
//                     -DNWK_START_DELAY=100 -DMAX_BINDING_CLUSTER_IDS=4)     /
//                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5. /
//                     1\Components\hal\target\MSP5438ZAP\hal_lcd.c -D        /
//                     ZAP_DEVICETYPE=ZG_DEVICETYPE_ROUTER -D                 /
//                     TVSA_DEVICE_ID=0x0016 -lC "C:\Users\student\Documents\ /
//                     GitHub\MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\ /
//                     EXP5438\ZAP Router\List\" -lA                          /
//                     "C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5 /
//                     .1\Projects\zstack\ZAP\TVSA\EXP5438\ZAP Router\List\"  /
//                     --remarks --diag_suppress Pe001,Pe193,Pe236,Pe826 -o   /
//                     "C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5 /
//                     .1\Projects\zstack\ZAP\TVSA\EXP5438\ZAP Router\Obj\"   /
//                     --debug -D__MSP430F5438A__ -e --double=32 --clib -I    /
//                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5. /
//                     1\Projects\zstack\ZAP\TVSA\EXP5438\ -I                 /
//                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5. /
//                     1\Projects\zstack\ZAP\TVSA\EXP5438\..\Source\ -I       /
//                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5. /
//                     1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\Source\ -I    /
//                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5. /
//                     1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Comp /
//                     onents\hal\target\MSP5438ZAP\ -I                       /
//                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5. /
//                     1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Comp /
//                     onents\hal\include\ -I C:\Users\student\Documents\GitH /
//                     ub\MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5 /
//                     438\..\..\..\..\..\Components\mac\include\ -I          /
//                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5. /
//                     1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Comp /
//                     onents\mt\ -I C:\Users\student\Documents\GitHub\MHMS\Z /
//                     AP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\..\.. /
//                     \..\..\..\Components\osal\include\ -I                  /
//                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5. /
//                     1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Comp /
//                     onents\osal\mcu\msp430\ -I                             /
//                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5. /
//                     1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Comp /
//                     onents\services\saddr\ -I C:\Users\student\Documents\G /
//                     itHub\MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\E /
//                     XP5438\..\..\..\..\..\Components\services\sdata\ -I    /
//                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5. /
//                     1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Comp /
//                     onents\stack\af\ -I C:\Users\student\Documents\GitHub\ /
//                     MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438 /
//                     \..\..\..\..\..\Components\stack\nwk\ -I               /
//                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5. /
//                     1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Comp /
//                     onents\stack\sapi\ -I C:\Users\student\Documents\GitHu /
//                     b\MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP54 /
//                     38\..\..\..\..\..\Components\stack\sec\ -I             /
//                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5. /
//                     1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Comp /
//                     onents\stack\sys\ -I C:\Users\student\Documents\GitHub /
//                     \MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP543 /
//                     8\..\..\..\..\..\Components\stack\zdo\ -I              /
//                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5. /
//                     1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Comp /
//                     onents\zmac\ -I C:\Users\student\Documents\GitHub\MHMS /
//                     \ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\..\ /
//                     ..\..\..\..\Components\zmac\f8w\ --core=430X           /
//                     --data_model=small -Ohz --multiplier=32                /
//                     --multiplier_location=4C0 --require_prototypes         /
//                     --hw_workaround=CPU40 --hw_workaround=CPU42            /
//    List file     =  C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5. /
//                     1\Projects\zstack\ZAP\TVSA\EXP5438\ZAP                 /
//                     Router\List\hal_lcd.s43                                /
//                                                                            /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////

        NAME hal_lcd

        RTMODEL "__SystemLibrary", "CLib"
        RTMODEL "__core", "430X"
        RTMODEL "__data_model", "small"
        RTMODEL "__double_size", "32"
        RTMODEL "__pic", "no"
        RTMODEL "__reg_r4", "free"
        RTMODEL "__reg_r5", "free"
        RTMODEL "__rt_version", "3"

        RSEG CSTACK:DATA:SORT:NOROOT(0)

        EXTERN ?DivMod8u
        EXTERN ?cstart_init_copy
        EXTERN ?cstart_init_zero
        EXTERN ?longjmp_r4
        EXTERN ?longjmp_r5
        EXTERN ?setjmp_r4
        EXTERN ?setjmp_r5

        PUBWEAK ?setjmp_save_r4
        PUBWEAK ?setjmp_save_r5
        PUBLIC Draw_Block_Address_Macro
        PUBLIC Draw_Block_Value_Macro
        PUBLIC HalLcdDisplayPercentBar
        FUNCTION HalLcdDisplayPercentBar,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 30, STACK
        PUBLIC HalLcdInit
        FUNCTION HalLcdInit,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC HalLcdWriteScreen
        FUNCTION HalLcdWriteScreen,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 6, STACK
        PUBLIC HalLcdWriteString
        FUNCTION HalLcdWriteString,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 20, STACK
        PUBLIC HalLcdWriteStringValue
        FUNCTION HalLcdWriteStringValue,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 42, STACK
        PUBLIC HalLcdWriteStringValueValue
        FUNCTION HalLcdWriteStringValueValue,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 46, STACK
        PUBLIC HalLcdWriteValue
        FUNCTION HalLcdWriteValue,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 32, STACK
        PUBLIC HalLcd_HW_Active
        FUNCTION HalLcd_HW_Active,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC HalLcd_HW_Clear
        FUNCTION HalLcd_HW_Clear,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 6, STACK
        PUBLIC HalLcd_HW_DrawBlock
        FUNCTION HalLcd_HW_DrawBlock,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 6, STACK
        PUBLIC HalLcd_HW_DrawCurrentBlock
        FUNCTION HalLcd_HW_DrawCurrentBlock,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC HalLcd_HW_Init
        FUNCTION HalLcd_HW_Init,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 6, STACK
        PUBLIC HalLcd_HW_InitBackLight
        FUNCTION HalLcd_HW_InitBackLight,0203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC HalLcd_HW_SendCmd
        FUNCTION HalLcd_HW_SendCmd,0203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC HalLcd_HW_SetAddress
        FUNCTION HalLcd_HW_SetAddress,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 6, STACK
        PUBLIC HalLcd_HW_SetContrast
        FUNCTION HalLcd_HW_SetContrast,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC HalLcd_HW_Wait
        FUNCTION HalLcd_HW_Wait,080203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC HalLcd_HW_WriteLine
        FUNCTION HalLcd_HW_WriteLine,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 16, STACK
        PUBLIC LCD_MEM
        PUBLIC LcdAddress
        PUBLIC LcdInitMacro
        PUBLIC LcdTableAddress
        PUBLIC Read_Block_Address_Macro
        PUBWEAK TA0CCR3
        PUBWEAK TA0CCTL3
        PUBWEAK UCB2STAT
        PUBWEAK UCB2TXBUF
        PUBWEAK _A_PDDIR_L
        PUBWEAK _A_PDIN_L
        PUBWEAK _A_PDOUT_L
        PUBWEAK _A_PDSEL_L
        PUBWEAK _A_PEDIR_L
        PUBWEAK _A_PEOUT_L
        PUBWEAK _A_PESEL_L
        PUBWEAK _A_UCB2BRW_L
        PUBWEAK _A_UCB2CTLW0_L
        PUBWEAK _A_UCB2ICTL_L
        PUBLIC fonts
        PUBLIC fonts_lookup
        
          CFI Names cfiNames0
          CFI StackFrame CFA SP DATA
          CFI Resource PC:20, SP:20, SR:16, R4L:16, R4H:4, R4:20, R5L:16, R5H:4
          CFI Resource R5:20, R6L:16, R6H:4, R6:20, R7L:16, R7H:4, R7:20, R8L:16
          CFI Resource R8H:4, R8:20, R9L:16, R9H:4, R9:20, R10L:16, R10H:4
          CFI Resource R10:20, R11L:16, R11H:4, R11:20, R12L:16, R12H:4, R12:20
          CFI Resource R13L:16, R13H:4, R13:20, R14L:16, R14H:4, R14:20, R15L:16
          CFI Resource R15H:4, R15:20
          CFI ResourceParts R4 R4H, R4L
          CFI ResourceParts R5 R5H, R5L
          CFI ResourceParts R6 R6H, R6L
          CFI ResourceParts R7 R7H, R7L
          CFI ResourceParts R8 R8H, R8L
          CFI ResourceParts R9 R9H, R9L
          CFI ResourceParts R10 R10H, R10L
          CFI ResourceParts R11 R11H, R11L
          CFI ResourceParts R12 R12H, R12L
          CFI ResourceParts R13 R13H, R13L
          CFI ResourceParts R14 R14H, R14L
          CFI ResourceParts R15 R15H, R15L
          CFI EndNames cfiNames0
        
          CFI Common cfiCommon0 Using cfiNames0
          CFI CodeAlign 2
          CFI DataAlign 2
          CFI ReturnAddress PC CODE
          CFI CFA SP+4
          CFI PC Frame(CFA, -4)
          CFI SR Undefined
          CFI R4L SameValue
          CFI R4H 0
          CFI R4 Concat
          CFI R5L SameValue
          CFI R5H 0
          CFI R5 Concat
          CFI R6L SameValue
          CFI R6H 0
          CFI R6 Concat
          CFI R7L SameValue
          CFI R7H 0
          CFI R7 Concat
          CFI R8L SameValue
          CFI R8H 0
          CFI R8 Concat
          CFI R9L SameValue
          CFI R9H 0
          CFI R9 Concat
          CFI R10L SameValue
          CFI R10H 0
          CFI R10 Concat
          CFI R11L SameValue
          CFI R11H 0
          CFI R11 Concat
          CFI R12L Undefined
          CFI R12H Undefined
          CFI R12 Undefined
          CFI R13L Undefined
          CFI R13H Undefined
          CFI R13 Undefined
          CFI R14L Undefined
          CFI R14H Undefined
          CFI R14 Undefined
          CFI R15L Undefined
          CFI R15H Undefined
          CFI R15 Undefined
          CFI EndCommon cfiCommon0
        
        
          CFI Common cfiCommon1 Using cfiNames0
          CFI CodeAlign 2
          CFI DataAlign 2
          CFI ReturnAddress PC CODE
          CFI CFA SP+4
          CFI PC Frame(CFA, -4)
          CFI SR Undefined
          CFI R4L SameValue
          CFI R4H 0
          CFI R4 Concat
          CFI R5L SameValue
          CFI R5H 0
          CFI R5 Concat
          CFI R6L SameValue
          CFI R6H 0
          CFI R6 Concat
          CFI R7L SameValue
          CFI R7H 0
          CFI R7 Concat
          CFI R8L SameValue
          CFI R8H 0
          CFI R8 Concat
          CFI R9L SameValue
          CFI R9H 0
          CFI R9 Concat
          CFI R10L SameValue
          CFI R10H 0
          CFI R10 Concat
          CFI R11L SameValue
          CFI R11H 0
          CFI R11 Concat
          CFI R12L SameValue
          CFI R12H 0
          CFI R12 Concat
          CFI R13L SameValue
          CFI R13H 0
          CFI R13 Concat
          CFI R14L SameValue
          CFI R14H 0
          CFI R14 Concat
          CFI R15L SameValue
          CFI R15H 0
          CFI R15 Concat
          CFI EndCommon cfiCommon1
        
        EXTERN osal_mem_alloc
        FUNCTION osal_mem_alloc,0202H
        EXTERN osal_strlen
        FUNCTION osal_strlen,0202H
        EXTERN osal_memcpy
        FUNCTION osal_memcpy,0202H
        EXTERN osal_mem_free
        FUNCTION osal_mem_free,0202H
        EXTERN _ltoa
        FUNCTION _ltoa,0202H

// C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1\Components\hal\target\MSP5438ZAP\hal_lcd.c
//    1 /**************************************************************************************************
//    2   Filename:       hal_lcd.c
//    3   Revised:        $Date: 2009-04-01 22:04:53 -0700 (Wed, 01 Apr 2009) $
//    4   Revision:       $Revision: 19626 $
//    5 
//    6   Description:    This file contains the interface to the HAL LCD Service.
//    7 
//    8 
//    9   Copyright 2007-2009 Texas Instruments Incorporated. All rights reserved.
//   10 
//   11   IMPORTANT: Your use of this Software is limited to those specific rights
//   12   granted under the terms of a software license agreement between the user
//   13   who downloaded the software, his/her employer (which must be your employer)
//   14   and Texas Instruments Incorporated (the "License").  You may not use this
//   15   Software unless you agree to abide by the terms of the License. The License
//   16   limits your use, and you acknowledge, that the Software may not be modified,
//   17   copied or distributed unless embedded on a Texas Instruments microcontroller
//   18   or used solely and exclusively in conjunction with a Texas Instruments radio
//   19   frequency transceiver, which is integrated into your product.  Other than for
//   20   the foregoing purpose, you may not use, reproduce, copy, prepare derivative
//   21   works of, modify, distribute, perform, display or sell this Software and/or
//   22   its documentation for any purpose.
//   23 
//   24   YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
//   25   PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
//   26   INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
//   27   NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
//   28   TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
//   29   NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
//   30   LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
//   31   INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
//   32   OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
//   33   OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
//   34   (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
//   35 
//   36   Should you have any questions regarding your right to use this Software,
//   37   contact Texas Instruments Incorporated at www.TI.com.
//   38 **************************************************************************************************/
//   39 
//   40 /**************************************************************************************************
//   41  *                                           INCLUDES
//   42  **************************************************************************************************/
//   43 #include "hal_types.h"
//   44 #include "hal_lcd.h"

        ASEGN DATA16_AN:DATA:NOROOT,0260H
// union <unnamed> _A_PDIN_L
_A_PDIN_L:
        DS8 2

        ASEGN DATA16_AN:DATA:NOROOT,0262H
// union <unnamed> _A_PDOUT_L
_A_PDOUT_L:
        DS8 2

        ASEGN DATA16_AN:DATA:NOROOT,0264H
// union <unnamed> _A_PDDIR_L
_A_PDDIR_L:
        DS8 2

        ASEGN DATA16_AN:DATA:NOROOT,026aH
// union <unnamed> _A_PDSEL_L
_A_PDSEL_L:
        DS8 2

        ASEGN DATA16_AN:DATA:NOROOT,0282H
// union <unnamed> _A_PEOUT_L
_A_PEOUT_L:
        DS8 2

        ASEGN DATA16_AN:DATA:NOROOT,0284H
// union <unnamed> _A_PEDIR_L
_A_PEDIR_L:
        DS8 2

        ASEGN DATA16_AN:DATA:NOROOT,028aH
// union <unnamed> _A_PESEL_L
_A_PESEL_L:
        DS8 2

        ASEGN DATA16_AN:DATA:NOROOT,0348H
// unsigned short volatile TA0CCTL3
TA0CCTL3:
        DS8 2

        ASEGN DATA16_AN:DATA:NOROOT,0358H
// unsigned short volatile TA0CCR3
TA0CCR3:
        DS8 2

        ASEGN DATA16_AN:DATA:NOROOT,0660H
// union <unnamed> _A_UCB2CTLW0_L
_A_UCB2CTLW0_L:
        DS8 2

        ASEGN DATA16_AN:DATA:NOROOT,0666H
// union <unnamed> _A_UCB2BRW_L
_A_UCB2BRW_L:
        DS8 2

        ASEGN DATA16_AN:DATA:NOROOT,066aH
// unsigned char volatile UCB2STAT
UCB2STAT:
        DS8 1

        ASEGN DATA16_AN:DATA:NOROOT,066eH
// unsigned char volatile UCB2TXBUF
UCB2TXBUF:
        DS8 1

        ASEGN DATA16_AN:DATA:NOROOT,067cH
// union <unnamed> _A_UCB2ICTL_L
_A_UCB2ICTL_L:
        DS8 2
//   45 #include "OSAL.h"
//   46 #include "OnBoard.h"
//   47 #include "hal_assert.h"
//   48 #include <stdlib.h>
//   49 #include <string.h>
//   50 
//   51 #if defined (ZTOOL_P1) || defined (ZTOOL_P2)
//   52   #include "DebugTrace.h"
//   53 #endif
//   54 
//   55 #if (HAL_LCD == TRUE)
//   56 /**************************************************************************************************
//   57  *                                          CONSTANTS
//   58  **************************************************************************************************/
//   59 /* LCD lines */
//   60 #define LCD_MAX_LINE_COUNT              3
//   61 #define LCD_MAX_LINE_LENGTH             16
//   62 #define LCD_MAX_BUF                     25
//   63 
//   64 /* Defines for HW LCD */
//   65 #define HAL_LCD_BACKLIGHT_LEVEL         10   //0-15    0:OFF, 15:MAX
//   66 #define HAL_LCD_CONTRAST_LEVEL          100   //70-127  70:LOW, 127:HIGH
//   67 
//   68 /**************************************************************************************************
//   69  *                                           MACROS
//   70  **************************************************************************************************/
//   71 

        RSEG DATA16_I:DATA:SORT:NOROOT(0)
        REQUIRE ?cstart_init_copy
//   72 unsigned char LcdInitMacro[]={
LcdInitMacro:
        DS8 108
        REQUIRE `?<Initializer for LcdInitMacro>`
//   73             0x74,0x00,0x00,0x76,0x00,0x01,  // R00 start oscillation
//   74             0x74,0x00,0x01,0x76,0x00,0x0D,  // R01 driver output control
//   75             0x74,0x00,0x02,0x76,0x00,0x4C,  // R02 LCD - driving waveform control
//   76             0x74,0x00,0x03,0x76,0x12,0x14,  // R03 Power control
//   77             0x74,0x00,0x04,0x76,0x04,0x66,  // R04 Contrast control
//   78             0x74,0x00,0x05,0x76,0x00,0x10,  // R05 Entry mode
//   79             0x74,0x00,0x06,0x76,0x00,0x00,  // R06 RAM data write mask
//   80             0x74,0x00,0x07,0x76,0x00,0x15,  // R07 Display control
//   81             0x74,0x00,0x08,0x76,0x00,0x03,  // R08 Cursor Control
//   82             0x74,0x00,0x09,0x76,0x00,0x00,  // R09 RAM data write mask
//   83             0x74,0x00,0x0A,0x76,0x00,0x15,  // R0A
//   84             0x74,0x00,0x0B,0x76,0x00,0x03,  // R0B Horizontal Cursor Position
//   85             0x74,0x00,0x0C,0x76,0x00,0x03,  // R0C Vertical Cursor Position
//   86             0x74,0x00,0x0D,0x76,0x00,0x00,  // R0D
//   87             0x74,0x00,0x0E,0x76,0x00,0x15,  // R0E
//   88             0x74,0x00,0x0F,0x76,0x00,0x03,  // R0F
//   89             0x74,0x00,0x10,0x76,0x00,0x15,  // R0E
//   90             0x74,0x00,0x11,0x76,0x00,0x03,  // R0F
//   91 };
//   92 
//   93 #define LCD_ROW                 110
//   94 #define LCD_COL                 138
//   95 #define LCD_Size                3505
//   96 #define LCD_MEM_SIZE            110*17
//   97 #define LCD_LAST_PIXEL          3505
//   98 
//   99 #define FONT_HEIGHT		          12
//  100 
//  101 #define INVERT_TEXT             BIT0
//  102 #define OVERWRITE_TEXT          BIT2
//  103 #define HAL_LCD_TEXT_STYLE      OVERWRITE_TEXT
//  104 
//  105 /**************************************************************************************************
//  106  *                                       GLOBAL VARIABLES
//  107  **************************************************************************************************/

        RSEG DATA16_Z:DATA:SORT:NOROOT(1)
        REQUIRE ?cstart_init_zero
//  108 static uint8 *Lcd_Line1;
Lcd_Line1:
        DS8 2

        RSEG DATA16_I:DATA:SORT:NOROOT(0)
        REQUIRE ?cstart_init_copy
//  109 static uint8 HAL_LCD_SETCONTRAST_CONTROL[] = {0x74,0x00,0x04,0x76,0x04,HAL_LCD_CONTRAST_LEVEL};
HAL_LCD_SETCONTRAST_CONTROL:
        DS8 6
        REQUIRE `?<Initializer for HAL_LCD_SETCONTRAST_CONTROL>`
//  110 

        RSEG DATA16_I:DATA:SORT:NOROOT(0)
        REQUIRE ?cstart_init_copy
//  111 unsigned char Read_Block_Address_Macro[]= {0x74,0x00,0x12,0x77,0x00,0x00};
Read_Block_Address_Macro:
        DS8 6
        REQUIRE `?<Initializer for Read_Block_Address_Macro>`

        RSEG DATA16_I:DATA:SORT:NOROOT(0)
        REQUIRE ?cstart_init_copy
//  112 unsigned char Draw_Block_Value_Macro[]=   {0x74,0x00,0x12,0x76,0xFF,0xFF};
Draw_Block_Value_Macro:
        DS8 6
        REQUIRE `?<Initializer for Draw_Block_Value_Macro>`

        RSEG DATA16_I:DATA:SORT:NOROOT(0)
        REQUIRE ?cstart_init_copy
//  113 unsigned char Draw_Block_Address_Macro[]= {0x74,0x00,0x11,0x76,0x00,0x00};
Draw_Block_Address_Macro:
        DS8 6
        REQUIRE `?<Initializer for Draw_Block_Address_Macro>`
//  114 

        RSEG DATA16_Z:DATA:SORT:NOROOT(1)
        REQUIRE ?cstart_init_zero
//  115 unsigned int LcdAddress=0, LcdTableAddress=0;
LcdAddress:
        DS8 2

        RSEG DATA16_Z:DATA:SORT:NOROOT(1)
        REQUIRE ?cstart_init_zero
LcdTableAddress:
        DS8 2
//  116 

        RSEG DATA16_Z:DATA:SORT:NOROOT(1)
        REQUIRE ?cstart_init_zero
//  117 int LCD_MEM[LCD_MEM_SIZE];
LCD_MEM:
        DS8 3740

        RSEG DATA16_C:CONST:SORT:NOROOT(0)
`?<Constant "TexasInstruments">`:
        DC8 "TexasInstruments"

        RSEG DATA16_C:CONST:SORT:NOROOT(0)
`?<Constant "                 ">`:
        DC8 "                 "

        RSEG DATA16_C:CONST:SORT:NOROOT(0)
`?<Constant "[          ]  ">`:
        DC8 "[          ]  "
//  118 

        RSEG DATA16_C:CONST:SORT:NOROOT(0)
//  119 const unsigned char fonts_lookup[]={
fonts_lookup:
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 63, 0, 0, 0, 0, 0, 0, 0, 64, 65, 0, 69
        DC8 0, 68, 67, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 66, 0, 0, 70, 0, 62, 0
        DC8 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26
        DC8 27, 28, 29, 30, 31, 32, 33, 34, 35, 0, 0, 0, 71, 0, 0, 36, 37, 38
        DC8 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55
        DC8 56, 57, 58, 59, 60, 61, 62, 0, 0, 0, 72, 73, 74, 75, 76, 77, 78, 79
        DC8 80, 81
//  120           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,            //Comment
//  121           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,            //Comment
//  122           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,            //Comment
//  123           0x00,0x00,63,0x00,0x00,0x00,0x00,0x00,0x00,0x00,              //Comment
//  124           64,65,0,69,0,68,67,0,0,1,          //'0' = 48 = 0x30
//  125           2,3,4,5,6,7,8,9,66,0,              //'9' = 57 = 0x39
//  126           0,70,0,62,0,10,11,12,13,14,        //'A' --> 'Z'
//  127           15,16,17,18,19,20,21,22,23,24,
//  128           25,26,27,28,29,30,31,32,33,34,
//  129           35,0,0,0,71,0,0,36,37,38,          //'a' = 97
//  130           39,40,41,42,43,44,45,46,47,48,
//  131           49,50,51,52,53,54,55,56,57,58,
//  132           59,60,61,62,0 ,0, 0, 72,73,74,
//  133           75,76,77,78,79,80,81};             //'z' = 122
//  134 

        RSEG DATA16_C:CONST:SORT:NOROOT(1)
//  135 const unsigned int fonts[]= {
fonts:
        DC16 0, 4092, 15375, 16143, 16335, 15567, 15615, 15423, 15375, 4092, 0
        DC16 0, 0, 0, 192, 240, 255, 240, 240, 240, 240, 240, 4095, 0, 0, 0, 0
        DC16 1020, 3855, 3855, 3840, 960, 240, 60, 3855, 4095, 0, 0, 0, 0, 1020
        DC16 3855, 3840, 3840, 1008, 3840, 3840, 3855, 1020, 0, 0, 0, 0, 3840
        DC16 4032, 4080, 3900, 3855, 16383, 3840, 3840, 16320, 0, 0, 0, 0, 4095
        DC16 15, 15, 15, 1023, 3840, 3840, 3855, 1020, 0, 0, 0, 0, 1008, 60, 15
        DC16 15, 1023, 3855, 3855, 3855, 1020, 0, 0, 0, 0, 16383, 15375, 15375
        DC16 15360, 3840, 960, 240, 240, 240, 0, 0, 0, 0, 1020, 3855, 3855
        DC16 3903, 1020, 4047, 3855, 3855, 1020, 0, 0, 0, 0, 1020, 3855, 3855
        DC16 3855, 4092, 960, 960, 240, 252, 0, 0, 0, 0, 240, 1020, 3855, 3855
        DC16 3855, 4095, 3855, 3855, 3855, 0, 0, 0, 0, 4095, 15420, 15420
        DC16 15420, 4092, 15420, 15420, 15420, 4095, 0, 0, 0, 0, 4080, 15420
        DC16 15375, 15, 15, 15, 15375, 15420, 4080, 0, 0, 0, 0, 1023, 3900
        DC16 15420, 15420, 15420, 15420, 15420, 3900, 1023, 0, 0, 0, 0, 16383
        DC16 12348, 60, 3132, 4092, 3132, 60, 12348, 16383, 0, 0, 0, 0, 16383
        DC16 15420, 12348, 3132, 4092, 3132, 60, 60, 255, 0, 0, 0, 0, 4080
        DC16 15420, 15375, 15, 15, 16143, 15375, 15420, 16368, 0, 0, 0, 0, 3855
        DC16 3855, 3855, 3855, 4095, 3855, 3855, 3855, 3855, 0, 0, 0, 0, 1020
        DC16 240, 240, 240, 240, 240, 240, 240, 1020, 0, 0, 0, 0, 16320, 3840
        DC16 3840, 3840, 3840, 3855, 3855, 3855, 1020, 0, 0, 0, 0, 15423, 15420
        DC16 3900, 3900, 1020, 3900, 3900, 15420, 15423, 0, 0, 0, 0, 255, 60
        DC16 60, 60, 60, 12348, 15420, 15420, 16383, 0, 0, 0, 0, 15375, 16191
        DC16 16383, 16383, 15567, 15375, 15375, 15375, 15375, 0, 0, 0, 0, 15375
        DC16 15375, 15423, 15615, 16383, 16335, 16143, 15375, 15375, 0, 0, 0, 0
        DC16 1008, 3900, 15375, 15375, 15375, 15375, 15375, 3900, 1008, 0, 0, 0
        DC16 0, 4095, 15420, 15420, 15420, 4092, 60, 60, 60, 255, 0, 0, 0, 0
        DC16 1008, 3900, 15375, 15375, 15375, 16143, 16335, 4092, 3840, 16320
        DC16 0, 0, 0, 4095, 15420, 15420, 15420, 4092, 3900, 15420, 15420
        DC16 15423, 0, 0, 0, 0, 1020, 3855, 3855, 15, 252, 960, 3855, 3855
        DC16 1020, 0, 0, 0, 0, 4095, 3315, 240, 240, 240, 240, 240, 240, 1020
        DC16 0, 0, 0, 0, 3855, 3855, 3855, 3855, 3855, 3855, 3855, 3855, 1020
        DC16 0, 0, 0, 0, 3855, 3855, 3855, 3855, 3855, 3855, 3855, 1020, 240, 0
        DC16 0, 0, 0, 15375, 15375, 15375, 15375, 15567, 15567, 3900, 3900
        DC16 3900, 0, 0, 0, 0, 3855, 3855, 3855, 1020, 240, 1020, 3855, 3855
        DC16 3855, 0, 0, 0, 0, 3855, 3855, 3855, 3855, 1020, 240, 240, 240
        DC16 1020, 0, 0, 0, 0, 16383, 16143, 963, 960, 240, 60, 12348, 15375
        DC16 16383, 0, 0, 0, 0, 0, 0, 0, 1020, 3840, 4092, 3855, 3855, 15612, 0
        DC16 0, 0, 0, 63, 60, 60, 4092, 15420, 15420, 15420, 15420, 4047, 0, 0
        DC16 0, 0, 0, 0, 0, 1020, 3855, 15, 15, 3855, 1020, 0, 0, 0, 0, 4032
        DC16 3840, 3840, 4092, 3855, 3855, 3855, 3855, 15612, 0, 0, 0, 0, 0, 0
        DC16 0, 1020, 3855, 4095, 15, 3855, 1020, 0, 0, 0, 0, 1008, 3900, 60
        DC16 60, 1023, 60, 60, 60, 255, 0, 0, 0, 0, 0, 0, 0, 15612, 3855, 3855
        DC16 3855, 4092, 3840, 3855, 1020, 0, 0, 63, 60, 60, 3900, 15612, 15420
        DC16 15420, 15420, 15423, 0, 0, 0, 0, 960, 960, 0, 1020, 960, 960, 960
        DC16 960, 16380, 0, 0, 0, 0, 3840, 3840, 0, 4080, 3840, 3840, 3840
        DC16 3840, 3855, 3855, 1020, 0, 0, 63, 60, 60, 15420, 3900, 1020, 3900
        DC16 15420, 15423, 0, 0, 0, 0, 1020, 960, 960, 960, 960, 960, 960, 960
        DC16 16380, 0, 0, 0, 0, 0, 0, 0, 4095, 15567, 15567, 15567, 15567
        DC16 15375, 0, 0, 0, 0, 0, 0, 0, 1023, 3855, 3855, 3855, 3855, 3855, 0
        DC16 0, 0, 0, 0, 0, 0, 1020, 3855, 3855, 3855, 3855, 1020, 0, 0, 0, 0
        DC16 0, 0, 0, 4047, 15420, 15420, 15420, 15420, 4092, 60, 255, 0, 0, 0
        DC16 0, 0, 15612, 3855, 3855, 3855, 3855, 4092, 3840, 16320, 0, 0, 0, 0
        DC16 0, 3903, 16188, 15612, 60, 60, 255, 0, 0, 0, 0, 0, 0, 0, 1020
        DC16 3855, 60, 960, 3855, 1020, 0, 0, 0, 0, 0, 48, 60, 4095, 60, 60, 60
        DC16 3900, 1008, 0, 0, 0, 0, 0, 0, 0, 3855, 3855, 3855, 3855, 3855
        DC16 15612, 0, 0, 0, 0, 0, 0, 0, 3855, 3855, 3855, 3855, 1020, 240, 0
        DC16 0, 0, 0, 0, 0, 0, 15375, 15375, 15567, 15567, 3900, 3900, 0, 0, 0
        DC16 0, 0, 0, 0, 15375, 3900, 1008, 1008, 3900, 15375, 0, 0, 0, 0, 0, 0
        DC16 0, 15420, 15420, 15420, 15420, 4080, 3840, 960, 255, 0, 0, 0, 0, 0
        DC16 4095, 3843, 960, 60, 3087, 4095, 0, 0, 0, 0, 1020, 3855, 3840, 960
        DC16 240, 240, 0, 240, 240, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC16 0, 0, 3840, 960, 240, 60, 60, 60, 240, 960, 3840, 0, 0, 0, 0, 60
        DC16 240, 960, 3840, 3840, 3840, 960, 240, 60, 0, 0, 0, 0, 0, 0, 1008
        DC16 1008, 0, 0, 1008, 1008, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1008
        DC16 1008, 0, 0, 0, 0, 0, 0, 0, 0, 16380, 16380, 0, 0, 0, 0, 0, 0, 0, 0
        DC16 0, 960, 960, 16380, 16380, 960, 960, 0, 0, 0, 0, 0, 0, 0, 0, 16380
        DC16 0, 0, 16380, 0, 0, 0, 0, 0, 0, 1020, 3855, 3855, 3855, 1020, 0, 0
        DC16 0, 0, 0, 0, 0, 0, 4092, 15375, 16143, 16335, 15567, 15615, 15423
        DC16 15375, 4092, 0, 0, 0, 0, 192, 240, 255, 240, 240, 240, 240, 240
        DC16 4095, 0, 0, 0, 0, 1020, 3855, 3855, 3840, 960, 240, 60, 3855, 4095
        DC16 0, 0, 0, 0, 1020, 3855, 3840, 3840, 1008, 3840, 3840, 3855, 1020
        DC16 0, 0, 0, 0, 3840, 4032, 4080, 3900, 3855, 16383, 3840, 3840, 16320
        DC16 0, 0, 0, 0, 4095, 15, 15, 15, 1023, 3840, 3840, 3855, 1020, 0, 0
        DC16 0, 0, 1008, 60, 15, 15, 1023, 3855, 3855, 3855, 1020, 0, 0, 0, 0
        DC16 16383, 15375, 15375, 15360, 3840, 960, 240, 240, 240, 0, 0, 0, 0
        DC16 1020, 3855, 3855, 3903, 1020, 4047, 3855, 3855, 1020, 0, 0, 0, 0
        DC16 1020, 3855, 3855, 3855, 4092, 960, 960, 240, 252, 0, 0, 0
//  136           0x0000,0x0ffc,0x3c0f,0x3f0f,0x3fcf,0x3ccf,0x3cff,0x3c3f,0x3c0f,0x0ffc,0x0000,0x0000,0x0000,
//  137           0x0000,0x00c0,0x00f0,0x00ff,0x00f0,0x00f0,0x00f0,0x00f0,0x00f0,0x0fff,0x0000,0x0000,0x0000,
//  138           0x0000,0x03fc,0x0f0f,0x0f0f,0x0f00,0x03c0,0x00f0,0x003c,0x0f0f,0x0fff,0x0000,0x0000,0x0000,
//  139           0x0000,0x03fc,0x0f0f,0x0f00,0x0f00,0x03f0,0x0f00,0x0f00,0x0f0f,0x03fc,0x0000,0x0000,0x0000,
//  140           0x0000,0x0f00,0x0fc0,0x0ff0,0x0f3c,0x0f0f,0x3fff,0x0f00,0x0f00,0x3fc0,0x0000,0x0000,0x0000,
//  141           0x0000,0x0fff,0x000f,0x000f,0x000f,0x03ff,0x0f00,0x0f00,0x0f0f,0x03fc,0x0000,0x0000,0x0000,
//  142           0x0000,0x03f0,0x003c,0x000f,0x000f,0x03ff,0x0f0f,0x0f0f,0x0f0f,0x03fc,0x0000,0x0000,0x0000,
//  143           0x0000,0x3fff,0x3c0f,0x3c0f,0x3c00,0x0f00,0x03c0,0x00f0,0x00f0,0x00f0,0x0000,0x0000,0x0000,
//  144           0x0000,0x03fc,0x0f0f,0x0f0f,0x0f3f,0x03fc,0x0fcf,0x0f0f,0x0f0f,0x03fc,0x0000,0x0000,0x0000,
//  145           0x0000,0x03fc,0x0f0f,0x0f0f,0x0f0f,0x0ffc,0x03c0,0x03c0,0x00f0,0x00fc,0x0000,0x0000,0x0000,
//  146           0x0000,0x00f0,0x03fc,0x0f0f,0x0f0f,0x0f0f,0x0fff,0x0f0f,0x0f0f,0x0f0f,0x0000,0x0000,0x0000,
//  147           0x0000,0x0fff,0x3c3c,0x3c3c,0x3c3c,0x0ffc,0x3c3c,0x3c3c,0x3c3c,0x0fff,0x0000,0x0000,0x0000,
//  148           0x0000,0x0ff0,0x3c3c,0x3c0f,0x000f,0x000f,0x000f,0x3c0f,0x3c3c,0x0ff0,0x0000,0x0000,0x0000,
//  149           0x0000,0x03ff,0x0f3c,0x3c3c,0x3c3c,0x3c3c,0x3c3c,0x3c3c,0x0f3c,0x03ff,0x0000,0x0000,0x0000,
//  150           0x0000,0x3fff,0x303c,0x003c,0x0c3c,0x0ffc,0x0c3c,0x003c,0x303c,0x3fff,0x0000,0x0000,0x0000,
//  151           0x0000,0x3fff,0x3c3c,0x303c,0x0c3c,0x0ffc,0x0c3c,0x003c,0x003c,0x00ff,0x0000,0x0000,0x0000,
//  152           0x0000,0x0ff0,0x3c3c,0x3c0f,0x000f,0x000f,0x3f0f,0x3c0f,0x3c3c,0x3ff0,0x0000,0x0000,0x0000,
//  153           0x0000,0x0f0f,0x0f0f,0x0f0f,0x0f0f,0x0fff,0x0f0f,0x0f0f,0x0f0f,0x0f0f,0x0000,0x0000,0x0000,
//  154           0x0000,0x03fc,0x00f0,0x00f0,0x00f0,0x00f0,0x00f0,0x00f0,0x00f0,0x03fc,0x0000,0x0000,0x0000,
//  155           0x0000,0x3fc0,0x0f00,0x0f00,0x0f00,0x0f00,0x0f0f,0x0f0f,0x0f0f,0x03fc,0x0000,0x0000,0x0000,
//  156           0x0000,0x3c3f,0x3c3c,0x0f3c,0x0f3c,0x03fc,0x0f3c,0x0f3c,0x3c3c,0x3c3f,0x0000,0x0000,0x0000,
//  157           0x0000,0x00ff,0x003c,0x003c,0x003c,0x003c,0x303c,0x3c3c,0x3c3c,0x3fff,0x0000,0x0000,0x0000,
//  158           0x0000,0x3c0f,0x3f3f,0x3fff,0x3fff,0x3ccf,0x3c0f,0x3c0f,0x3c0f,0x3c0f,0x0000,0x0000,0x0000,
//  159           0x0000,0x3c0f,0x3c0f,0x3c3f,0x3cff,0x3fff,0x3fcf,0x3f0f,0x3c0f,0x3c0f,0x0000,0x0000,0x0000,
//  160           0x0000,0x03f0,0x0f3c,0x3c0f,0x3c0f,0x3c0f,0x3c0f,0x3c0f,0x0f3c,0x03f0,0x0000,0x0000,0x0000,
//  161           0x0000,0x0fff,0x3c3c,0x3c3c,0x3c3c,0x0ffc,0x003c,0x003c,0x003c,0x00ff,0x0000,0x0000,0x0000,
//  162           0x0000,0x03f0,0x0f3c,0x3c0f,0x3c0f,0x3c0f,0x3f0f,0x3fcf,0x0ffc,0x0f00,0x3fc0,0x0000,0x0000,
//  163           0x0000,0x0fff,0x3c3c,0x3c3c,0x3c3c,0x0ffc,0x0f3c,0x3c3c,0x3c3c,0x3c3f,0x0000,0x0000,0x0000,
//  164           0x0000,0x03fc,0x0f0f,0x0f0f,0x000f,0x00fc,0x03c0,0x0f0f,0x0f0f,0x03fc,0x0000,0x0000,0x0000,
//  165           0x0000,0x0fff,0x0cf3,0x00f0,0x00f0,0x00f0,0x00f0,0x00f0,0x00f0,0x03fc,0x0000,0x0000,0x0000,
//  166           0x0000,0x0f0f,0x0f0f,0x0f0f,0x0f0f,0x0f0f,0x0f0f,0x0f0f,0x0f0f,0x03fc,0x0000,0x0000,0x0000,
//  167           0x0000,0x0f0f,0x0f0f,0x0f0f,0x0f0f,0x0f0f,0x0f0f,0x0f0f,0x03fc,0x00f0,0x0000,0x0000,0x0000,
//  168           0x0000,0x3c0f,0x3c0f,0x3c0f,0x3c0f,0x3ccf,0x3ccf,0x0f3c,0x0f3c,0x0f3c,0x0000,0x0000,0x0000,
//  169           0x0000,0x0f0f,0x0f0f,0x0f0f,0x03fc,0x00f0,0x03fc,0x0f0f,0x0f0f,0x0f0f,0x0000,0x0000,0x0000,
//  170           0x0000,0x0f0f,0x0f0f,0x0f0f,0x0f0f,0x03fc,0x00f0,0x00f0,0x00f0,0x03fc,0x0000,0x0000,0x0000,
//  171           0x0000,0x3fff,0x3f0f,0x03c3,0x03c0,0x00f0,0x003c,0x303c,0x3c0f,0x3fff,0x0000,0x0000,0x0000,
//  172           0x0000,0x0000,0x0000,0x0000,0x03fc,0x0f00,0x0ffc,0x0f0f,0x0f0f,0x3cfc,0x0000,0x0000,0x0000,
//  173           0x0000,0x003f,0x003c,0x003c,0x0ffc,0x3c3c,0x3c3c,0x3c3c,0x3c3c,0x0fcf,0x0000,0x0000,0x0000,
//  174           0x0000,0x0000,0x0000,0x0000,0x03fc,0x0f0f,0x000f,0x000f,0x0f0f,0x03fc,0x0000,0x0000,0x0000,
//  175           0x0000,0x0fc0,0x0f00,0x0f00,0x0ffc,0x0f0f,0x0f0f,0x0f0f,0x0f0f,0x3cfc,0x0000,0x0000,0x0000,
//  176           0x0000,0x0000,0x0000,0x0000,0x03fc,0x0f0f,0x0fff,0x000f,0x0f0f,0x03fc,0x0000,0x0000,0x0000,
//  177           0x0000,0x03f0,0x0f3c,0x003c,0x003c,0x03ff,0x003c,0x003c,0x003c,0x00ff,0x0000,0x0000,0x0000,
//  178           0x0000,0x0000,0x0000,0x0000,0x3cfc,0x0f0f,0x0f0f,0x0f0f,0x0ffc,0x0f00,0x0f0f,0x03fc,0x0000,
//  179           0x0000,0x003f,0x003c,0x003c,0x0f3c,0x3cfc,0x3c3c,0x3c3c,0x3c3c,0x3c3f,0x0000,0x0000,0x0000,
//  180           0x0000,0x03c0,0x03c0,0x0000,0x03fc,0x03c0,0x03c0,0x03c0,0x03c0,0x3ffc,0x0000,0x0000,0x0000,
//  181           0x0000,0x0f00,0x0f00,0x0000,0x0ff0,0x0f00,0x0f00,0x0f00,0x0f00,0x0f0f,0x0f0f,0x03fc,0x0000,
//  182           0x0000,0x003f,0x003c,0x003c,0x3c3c,0x0f3c,0x03fc,0x0f3c,0x3c3c,0x3c3f,0x0000,0x0000,0x0000,
//  183           0x0000,0x03fc,0x03c0,0x03c0,0x03c0,0x03c0,0x03c0,0x03c0,0x03c0,0x3ffc,0x0000,0x0000,0x0000,
//  184           0x0000,0x0000,0x0000,0x0000,0x0fff,0x3ccf,0x3ccf,0x3ccf,0x3ccf,0x3c0f,0x0000,0x0000,0x0000,
//  185           0x0000,0x0000,0x0000,0x0000,0x03ff,0x0f0f,0x0f0f,0x0f0f,0x0f0f,0x0f0f,0x0000,0x0000,0x0000,
//  186           0x0000,0x0000,0x0000,0x0000,0x03fc,0x0f0f,0x0f0f,0x0f0f,0x0f0f,0x03fc,0x0000,0x0000,0x0000,
//  187           0x0000,0x0000,0x0000,0x0000,0x0fcf,0x3c3c,0x3c3c,0x3c3c,0x3c3c,0x0ffc,0x003c,0x00ff,0x0000,
//  188           0x0000,0x0000,0x0000,0x0000,0x3cfc,0x0f0f,0x0f0f,0x0f0f,0x0f0f,0x0ffc,0x0f00,0x3fc0,0x0000,
//  189           0x0000,0x0000,0x0000,0x0000,0x0f3f,0x3f3c,0x3cfc,0x003c,0x003c,0x00ff,0x0000,0x0000,0x0000,
//  190           0x0000,0x0000,0x0000,0x0000,0x03fc,0x0f0f,0x003c,0x03c0,0x0f0f,0x03fc,0x0000,0x0000,0x0000,
//  191           0x0000,0x0000,0x0030,0x003c,0x0fff,0x003c,0x003c,0x003c,0x0f3c,0x03f0,0x0000,0x0000,0x0000,
//  192           0x0000,0x0000,0x0000,0x0000,0x0f0f,0x0f0f,0x0f0f,0x0f0f,0x0f0f,0x3cfc,0x0000,0x0000,0x0000,
//  193           0x0000,0x0000,0x0000,0x0000,0x0f0f,0x0f0f,0x0f0f,0x0f0f,0x03fc,0x00f0,0x0000,0x0000,0x0000,
//  194           0x0000,0x0000,0x0000,0x0000,0x3c0f,0x3c0f,0x3ccf,0x3ccf,0x0f3c,0x0f3c,0x0000,0x0000,0x0000,
//  195           0x0000,0x0000,0x0000,0x0000,0x3c0f,0x0f3c,0x03f0,0x03f0,0x0f3c,0x3c0f,0x0000,0x0000,0x0000,
//  196           0x0000,0x0000,0x0000,0x0000,0x3c3c,0x3c3c,0x3c3c,0x3c3c,0x0ff0,0x0f00,0x03c0,0x00ff,0x0000,
//  197           0x0000,0x0000,0x0000,0x0000,0x0fff,0x0f03,0x03c0,0x003c,0x0c0f,0x0fff,0x0000,0x0000,0x0000,
//  198           0x0000,0x03fc,0x0f0f,0x0f00,0x03c0,0x00f0,0x00f0,0x0000,0x00f0,0x00f0,0x0000,0x0000,0x0000,
//  199           0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
//  200           0x0000,0x0f00,0x03c0,0x00f0,0x003c,0x003c,0x003c,0x00f0,0x03c0,0x0f00,0x0000,0x0000,0x0000,
//  201           0x0000,0x003c,0x00f0,0x03c0,0x0f00,0x0f00,0x0f00,0x03c0,0x00f0,0x003c,0x0000,0x0000,0x0000,
//  202           0x0000,0x0000,0x0000,0x03f0,0x03f0,0x0000,0x0000,0x03f0,0x03f0,0x0000,0x0000,0x0000,0x0000,
//  203           0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x03f0,0x03f0,0x0000,0x0000,0x0000,
//  204           0x0000,0x0000,0x0000,0x0000,0x0000,0x3ffc,0x3ffc,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
//  205           0x0000,0x0000,0x0000,0x03c0,0x03c0,0x3ffc,0x3ffc,0x03c0,0x03c0,0x0000,0x0000,0x0000,0x0000,
//  206           0x0000,0x0000,0x0000,0x0000,0x3ffc,0x0000,0x0000,0x3ffc,0x0000,0x0000,0x0000,0x0000,0x0000,
//  207           0x0000,0x03fc,0x0f0f,0x0f0f,0x0f0f,0x03fc,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
//  208           0x0000,0x0ffc,0x3c0f,0x3f0f,0x3fcf,0x3ccf,0x3cff,0x3c3f,0x3c0f,0x0ffc,0x0000,0x0000,0x0000, //0
//  209           0x0000,0x00c0,0x00f0,0x00ff,0x00f0,0x00f0,0x00f0,0x00f0,0x00f0,0x0fff,0x0000,0x0000,0x0000, //1
//  210           0x0000,0x03fc,0x0f0f,0x0f0f,0x0f00,0x03c0,0x00f0,0x003c,0x0f0f,0x0fff,0x0000,0x0000,0x0000, //2
//  211           0x0000,0x03fc,0x0f0f,0x0f00,0x0f00,0x03f0,0x0f00,0x0f00,0x0f0f,0x03fc,0x0000,0x0000,0x0000, //3
//  212           0x0000,0x0f00,0x0fc0,0x0ff0,0x0f3c,0x0f0f,0x3fff,0x0f00,0x0f00,0x3fc0,0x0000,0x0000,0x0000, //4
//  213           0x0000,0x0fff,0x000f,0x000f,0x000f,0x03ff,0x0f00,0x0f00,0x0f0f,0x03fc,0x0000,0x0000,0x0000, //5
//  214           0x0000,0x03f0,0x003c,0x000f,0x000f,0x03ff,0x0f0f,0x0f0f,0x0f0f,0x03fc,0x0000,0x0000,0x0000, //6
//  215           0x0000,0x3fff,0x3c0f,0x3c0f,0x3c00,0x0f00,0x03c0,0x00f0,0x00f0,0x00f0,0x0000,0x0000,0x0000, //7
//  216           0x0000,0x03fc,0x0f0f,0x0f0f,0x0f3f,0x03fc,0x0fcf,0x0f0f,0x0f0f,0x03fc,0x0000,0x0000,0x0000, //8
//  217           0x0000,0x03fc,0x0f0f,0x0f0f,0x0f0f,0x0ffc,0x03c0,0x03c0,0x00f0,0x00fc,0x0000,0x0000,0x0000, //9
//  218 } ;
//  219 
//  220 /**************************************************************************************************
//  221  *                                       FUNCTIONS - API
//  222  **************************************************************************************************/
//  223 
//  224 void HalLcd_HW_Init(void);
//  225 void HalLcd_HW_InitBackLight(void);
//  226 void HalLcd_HW_SetContrast(uint8 level);
//  227 void HalLcd_HW_Wait(uint16 i);
//  228 void HalLcd_HW_Clear(void);
//  229 void HalLcd_HW_SendCmd(uint8 cmd[]);
//  230 void HalLcd_HW_SetAddress(int Address);
//  231 void HalLcd_HW_WriteLine(char str[], uint8 line);
//  232 
//  233 void HalLcd_HW_DrawCurrentBlock(unsigned int Value);
//  234 void HalLcd_HW_DrawBlock(unsigned int Address, unsigned int Value);
//  235 
//  236 void HalLcd_HW_Active(void);
//  237 #endif //LCD
//  238 
//  239 /**************************************************************************************************
//  240  * @fn      HalLcdInit
//  241  *
//  242  * @brief   Initilize LCD Service
//  243  *
//  244  * @param   init - pointer to void that contains the initialized value
//  245  *
//  246  * @return  None
//  247  **************************************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  248 void HalLcdInit(void)
HalLcdInit:
          CFI Block cfiBlock0 Using cfiCommon0
          CFI Function HalLcdInit
//  249 {
//  250 #if (HAL_LCD == TRUE)
//  251   Lcd_Line1 = NULL;
        FUNCALL HalLcdInit, HalLcd_HW_Init
        LOCFRAME CSTACK, 4, STACK
        MOV.W   #0x0, &Lcd_Line1
//  252   HalLcd_HW_Init();
        BRA     #HalLcd_HW_Init
          CFI EndBlock cfiBlock0
//  253 #endif
//  254 }
//  255 
//  256 /*************************************************************************************************
//  257  *                    LCD EMULATION FUNCTIONS
//  258  *
//  259  * Some evaluation boards are equipped with Liquid Crystal Displays
//  260  * (LCD) which may be used to display diagnostic information. These
//  261  * functions provide LCD emulation, sending the diagnostic strings
//  262  * to Z-Tool via the RS232 serial port. These functions are enabled
//  263  * when the "LCD_SUPPORTED" compiler flag is placed in the makefile.
//  264  *
//  265  * Most applications update both lines (1 and 2) of the LCD whenever
//  266  * text is posted to the device. This emulator assumes that line 1 is
//  267  * updated first (saved locally) and the formatting and send operation
//  268  * is triggered by receipt of line 2. Nothing will be transmitted if
//  269  * only line 1 is updated.
//  270  *
//  271  *************************************************************************************************/
//  272 
//  273 
//  274 /**************************************************************************************************
//  275  * @fn      HalLcdWriteString
//  276  *
//  277  * @brief   Write a string to the LCD
//  278  *
//  279  * @param   str    - pointer to the string that will be displayed
//  280  *          line   - line number to display
//  281  *
//  282  * @return  None
//  283  **************************************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  284 void HalLcdWriteString ( char *str, uint8 line)
HalLcdWriteString:
          CFI Block cfiBlock1 Using cfiCommon0
          CFI Function HalLcdWriteString
//  285 {
        FUNCALL HalLcdWriteString, osal_mem_alloc
        LOCFRAME CSTACK, 20, STACK
        FUNCALL HalLcdWriteString, HalLcdWriteString
        LOCFRAME CSTACK, 20, STACK
        FUNCALL HalLcdWriteString, osal_strlen
        LOCFRAME CSTACK, 20, STACK
        FUNCALL HalLcdWriteString, osal_memcpy
        LOCFRAME CSTACK, 20, STACK
        FUNCALL HalLcdWriteString, osal_strlen
        LOCFRAME CSTACK, 20, STACK
        FUNCALL HalLcdWriteString, osal_mem_alloc
        LOCFRAME CSTACK, 20, STACK
        FUNCALL HalLcdWriteString, osal_memcpy
        LOCFRAME CSTACK, 20, STACK
        FUNCALL HalLcdWriteString, osal_memcpy
        LOCFRAME CSTACK, 20, STACK
        FUNCALL HalLcdWriteString, osal_mem_free
        LOCFRAME CSTACK, 20, STACK
        FUNCALL HalLcdWriteString, HalLcd_HW_WriteLine
        LOCFRAME CSTACK, 20, STACK
        FUNCALL HalLcdWriteString, HalLcd_HW_WriteLine
        LOCFRAME CSTACK, 20, STACK
        PUSHM.W #0x8, R11
          CFI R4L Frame(CFA, -20)
          CFI R5L Frame(CFA, -18)
          CFI R6L Frame(CFA, -16)
          CFI R7L Frame(CFA, -14)
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+20
        MOV.W   R12, R8
        MOV.B   R13, R9
//  286 
//  287 #if (HAL_LCD == TRUE)
//  288   uint8 strLen = 0;
//  289   uint8 totalLen = 0;
//  290   uint8 *buf;
//  291   uint8 tmpLen;
//  292 
//  293   if ( Lcd_Line1 == NULL )
        CMP.W   #0x0, &Lcd_Line1
        JNE     ??HalLcdWriteString_0
//  294   {
//  295     Lcd_Line1 = osal_mem_alloc( HAL_LCD_MAX_CHARS+1 );
        MOV.W   #0x11, R12
        CALLA   #osal_mem_alloc
        MOV.W   R12, &Lcd_Line1
//  296     HalLcdWriteString( "TexasInstruments", 0 );
        MOV.B   #0x0, R13
        MOV.W   #`?<Constant "TexasInstruments">`, R12
        CALLA   #HalLcdWriteString
//  297   }
//  298 
//  299   strLen = (uint8)osal_strlen( (char*)str );
??HalLcdWriteString_0:
        MOV.W   R8, R12
        CALLA   #osal_strlen
        MOV.B   R12, R10
//  300 
//  301   /* Check boundries */
//  302   if ( strLen > HAL_LCD_MAX_CHARS )
        CMP.B   #0x11, R12
        JNC     ??HalLcdWriteString_1
//  303     strLen = HAL_LCD_MAX_CHARS;
        MOV.B   #0x10, R10
//  304 
//  305   if ( line == HAL_LCD_LINE_1 )
??HalLcdWriteString_1:
        MOV.B   R10, R6
        MOV.B   R10, R7
        MOV.W   #Lcd_Line1, R4
        CMP.B   #0x1, R9
        JNE     ??HalLcdWriteString_2
//  306   {
//  307     /* Line 1 gets saved for later */
//  308     osal_memcpy( Lcd_Line1, str, strLen );
        MOV.W   R7, R14
        MOV.W   R8, R13
        MOV.W   @R4, R12
        CALLA   #osal_memcpy
//  309     Lcd_Line1[strLen] = '\0';
        MOV.W   @R4, R15
        ADD.W   R6, R15
        MOV.B   #0x0, 0(R15)
        JMP     ??HalLcdWriteString_3
//  310   }
//  311   else
//  312   {
//  313     /* Line 2 triggers action */
//  314     tmpLen = (uint8)osal_strlen( (char*)Lcd_Line1 );
??HalLcdWriteString_2:
        MOV.W   @R4, R12
        CALLA   #osal_strlen
        MOV.B   R12, R11
//  315     totalLen =  tmpLen + 1 + strLen + 1;
//  316     buf = osal_mem_alloc( totalLen );
        ADD.B   R10, R12
        ADD.B   #0x2, R12
        CALLA   #osal_mem_alloc
        MOV.W   R12, R10
//  317     if ( buf != NULL )
        CMP.W   #0x0, R12
        JEQ     ??HalLcdWriteString_3
//  318     {
//  319       /* Concatenate strings */
//  320       osal_memcpy( buf, Lcd_Line1, tmpLen );
        MOV.B   R11, R14
        MOV.W   @R4, R13
        CALLA   #osal_memcpy
//  321       buf[tmpLen++] = ' ';
        MOV.W   R10, R15
        ADD.W   R11, R15
        MOV.B   #0x20, 0(R15)
        ADD.B   #0x1, R11
//  322       osal_memcpy( &buf[tmpLen], str, strLen );
        MOV.W   R7, R14
        MOV.W   R8, R13
        MOV.W   R10, R12
        ADD.W   R11, R12
        CALLA   #osal_memcpy
//  323       buf[tmpLen+strLen] = '\0';
        ADD.W   R6, R11
        MOV.W   R10, R15
        ADD.W   R11, R15
        MOV.B   #0x0, 0(R15)
//  324 
//  325       /* Send it out */
//  326 #if defined (ZTOOL_P1) || defined (ZTOOL_P2)
//  327 
//  328 #if (SERIAL_DEBUG_SUPPORTED)
//  329       debug_str( (uint8*)buf );
//  330 #endif //LCD_SUPPORTED
//  331 
//  332 #endif //ZTOOL_P1
//  333 
//  334       /* Free mem */
//  335       osal_mem_free( buf );
        MOV.W   R10, R12
        CALLA   #osal_mem_free
//  336     }
//  337   }
//  338   /* Clear the line - print 17 blanks */
//  339   HalLcd_HW_WriteLine ("                 ", line);
??HalLcdWriteString_3:
        MOV.B   R9, R13
        MOV.W   #`?<Constant "                 ">`, R12
        CALLA   #HalLcd_HW_WriteLine
//  340   /* Display the string */
//  341   HalLcd_HW_WriteLine (str, line);
        MOV.B   R9, R13
        MOV.W   R8, R12
        CALLA   #HalLcd_HW_WriteLine
//  342 
//  343 #endif //HAL_LCD
//  344 
//  345 }
        POPM.W  #0x8, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R4L SameValue
          CFI R5L SameValue
          CFI R6L SameValue
          CFI R7L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock1
//  346 
//  347 /**************************************************************************************************
//  348  * @fn      HalLcdWriteValue
//  349  *
//  350  * @brief   Write a value to the LCD
//  351  *
//  352  * @param   value  - value that will be displayed
//  353  *          radix  - 8, 10, 16
//  354  *          option - display options
//  355  *
//  356  * @return  None
//  357  **************************************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  358 void HalLcdWriteValue ( uint32 value, const uint8 radix, uint8 option)
HalLcdWriteValue:
          CFI Block cfiBlock2 Using cfiCommon0
          CFI Function HalLcdWriteValue
//  359 {
        FUNCALL HalLcdWriteValue, _ltoa
        LOCFRAME CSTACK, 32, STACK
        FUNCALL HalLcdWriteValue, HalLcdWriteString
        LOCFRAME CSTACK, 32, STACK
        PUSH.W  R10
          CFI R10L Frame(CFA, -6)
          CFI CFA SP+6
        SUB.W   #0x1a, SP
          CFI CFA SP+32
        MOV.B   R15, R10
//  360 #if (HAL_LCD == TRUE)
//  361   uint8 buf[LCD_MAX_BUF];
//  362 
//  363   _ltoa( value, &buf[0], radix );
        MOV.B   R14, R15
        MOV.W   SP, R14
        ADD.W   #0x0, R14
        CALLA   #_ltoa
//  364   HalLcdWriteString( (char*)buf, option );
        MOV.B   R10, R13
        MOV.W   SP, R12
        ADD.W   #0x0, R12
        CALLA   #HalLcdWriteString
//  365 #endif
//  366 }
        ADD.W   #0x1a, SP
          CFI CFA SP+6
        POP.W   R10
          CFI R10L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock2
//  367 
//  368 /**************************************************************************************************
//  369  * @fn      HalLcdWriteScreen
//  370  *
//  371  * @brief   Write a value to the LCD
//  372  *
//  373  * @param   line1  - string that will be displayed on line 1
//  374  *          line2  - string that will be displayed on line 2
//  375  *
//  376  * @return  None
//  377  **************************************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  378 void HalLcdWriteScreen( char *line1, char *line2 )
HalLcdWriteScreen:
          CFI Block cfiBlock3 Using cfiCommon0
          CFI Function HalLcdWriteScreen
//  379 {
        FUNCALL HalLcdWriteScreen, HalLcdWriteString
        LOCFRAME CSTACK, 6, STACK
        FUNCALL HalLcdWriteScreen, HalLcdWriteString
        LOCFRAME CSTACK, 6, STACK
        PUSH.W  R10
          CFI R10L Frame(CFA, -6)
          CFI CFA SP+6
        MOV.W   R13, R10
//  380 #if (HAL_LCD == TRUE)
//  381   HalLcdWriteString( line1, 1 );
        MOV.B   #0x1, R13
        CALLA   #HalLcdWriteString
//  382   HalLcdWriteString( line2, 2 );
        MOV.B   #0x2, R13
        MOV.W   R10, R12
        CALLA   #HalLcdWriteString
//  383 #endif
//  384 }
        POP.W   R10
          CFI R10L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock3
//  385 
//  386 /**************************************************************************************************
//  387  * @fn      HalLcdWriteStringValue
//  388  *
//  389  * @brief   Write a string followed by a value to the LCD
//  390  *
//  391  * @param   title  - Title that will be displayed before the value
//  392  *          value  - value
//  393  *          format - redix
//  394  *          line   - line number
//  395  *
//  396  * @return  None
//  397  **************************************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  398 void HalLcdWriteStringValue( char *title, uint16 value, uint8 format, uint8 line )
HalLcdWriteStringValue:
          CFI Block cfiBlock4 Using cfiCommon0
          CFI Function HalLcdWriteStringValue
//  399 {
        FUNCALL HalLcdWriteStringValue, osal_strlen
        LOCFRAME CSTACK, 42, STACK
        FUNCALL HalLcdWriteStringValue, osal_memcpy
        LOCFRAME CSTACK, 42, STACK
        FUNCALL HalLcdWriteStringValue, _ltoa
        LOCFRAME CSTACK, 42, STACK
        FUNCALL HalLcdWriteStringValue, HalLcdWriteString
        LOCFRAME CSTACK, 42, STACK
        PUSHM.W #0x6, R11
          CFI R6L Frame(CFA, -16)
          CFI R7L Frame(CFA, -14)
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+16
        SUB.W   #0x1a, SP
          CFI CFA SP+42
        MOV.W   R12, R7
        MOV.W   R13, R9
        MOV.B   R14, R6
        MOV.B   R15, R11
//  400 #if (HAL_LCD == TRUE)
//  401   uint8 tmpLen;
//  402   uint8 buf[LCD_MAX_BUF];
//  403   uint32 err;
//  404 
//  405   tmpLen = (uint8)osal_strlen( (char*)title );
        CALLA   #osal_strlen
        MOV.B   R12, R10
//  406   osal_memcpy( buf, title, tmpLen );
        MOV.W   SP, R8
        ADD.W   #0x0, R8
        MOV.B   R12, R14
        MOV.W   R7, R13
        MOV.W   R8, R12
        CALLA   #osal_memcpy
//  407   buf[tmpLen] = ' ';
        MOV.W   R8, R14
        ADD.W   R10, R14
        MOV.B   #0x20, 0(R14)
//  408   err = (uint32)(value);
//  409   _ltoa( err, &buf[tmpLen+1], format );
        MOV.B   R6, R15
        ADD.W   #0x1, R14
        CALLA   #?Subroutine0
//  410   HalLcdWriteString( (char*)buf, line );		
//  411 #endif
//  412 }
??CrossCallReturnLabel_0:
        ADD.W   #0x1a, SP
          CFI CFA SP+16
        POPM.W  #0x6, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R6L SameValue
          CFI R7L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock4

        RSEG CODE:CODE:REORDER:NOROOT(1)
?Subroutine0:
          CFI Block cfiCond5 Using cfiCommon0
          CFI Function HalLcdWriteStringValueValue
          CFI Conditional ??CrossCallReturnLabel_1
          CFI R4L Frame(CFA, -20)
          CFI R5L Frame(CFA, -18)
          CFI R6L Frame(CFA, -16)
          CFI R7L Frame(CFA, -14)
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+50
          CFI Block cfiCond6 Using cfiCommon0
          CFI (cfiCond6) Function HalLcdWriteStringValue
          CFI (cfiCond6) Conditional ??CrossCallReturnLabel_0
          CFI (cfiCond6) R6L Frame(CFA, -16)
          CFI (cfiCond6) R7L Frame(CFA, -14)
          CFI (cfiCond6) R8L Frame(CFA, -12)
          CFI (cfiCond6) R9L Frame(CFA, -10)
          CFI (cfiCond6) R10L Frame(CFA, -8)
          CFI (cfiCond6) R11L Frame(CFA, -6)
          CFI (cfiCond6) CFA SP+46
          CFI Block cfiPicker7 Using cfiCommon1
          CFI (cfiPicker7) NoFunction
          CFI (cfiPicker7) Picker
        MOV.W   R9, R12
        MOV.W   #0x0, R13
        CALLA   #_ltoa
        MOV.B   R11, R13
        MOV.W   R8, R12
        BRA     #HalLcdWriteString
          CFI EndBlock cfiCond5
          CFI EndBlock cfiCond6
          CFI EndBlock cfiPicker7
//  413 
//  414 /**************************************************************************************************
//  415  * @fn      HalLcdWriteStringValue
//  416  *
//  417  * @brief   Write a string followed by a value to the LCD
//  418  *
//  419  * @param   title   - Title that will be displayed before the value
//  420  *          value1  - value #1
//  421  *          format1 - redix of value #1
//  422  *          value2  - value #2
//  423  *          format2 - redix of value #2
//  424  *          line    - line number
//  425  *
//  426  * @return  None
//  427  **************************************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  428 void HalLcdWriteStringValueValue( char *title, uint16 value1, uint8 format1,
HalLcdWriteStringValueValue:
          CFI Block cfiBlock8 Using cfiCommon0
          CFI Function HalLcdWriteStringValueValue
//  429                                   uint16 value2, uint8 format2, uint8 line )
//  430 {
        FUNCALL HalLcdWriteStringValueValue, osal_strlen
        LOCFRAME CSTACK, 46, STACK
        FUNCALL HalLcdWriteStringValueValue, osal_memcpy
        LOCFRAME CSTACK, 46, STACK
        FUNCALL HalLcdWriteStringValueValue, _ltoa
        LOCFRAME CSTACK, 46, STACK
        FUNCALL HalLcdWriteStringValueValue, osal_strlen
        LOCFRAME CSTACK, 46, STACK
        FUNCALL HalLcdWriteStringValueValue, _ltoa
        LOCFRAME CSTACK, 46, STACK
        FUNCALL HalLcdWriteStringValueValue, HalLcdWriteString
        LOCFRAME CSTACK, 46, STACK
        PUSHM.W #0x8, R11
          CFI R4L Frame(CFA, -20)
          CFI R5L Frame(CFA, -18)
          CFI R6L Frame(CFA, -16)
          CFI R7L Frame(CFA, -14)
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+20
        SUB.W   #0x1a, SP
          CFI CFA SP+46
        MOV.W   R12, R4
        MOV.W   R13, R7
        MOV.B   R14, R5
        MOV.W   R15, R9
        MOV.B   0x2e(SP), R6
        MOV.B   0x30(SP), R11
//  431 
//  432 #if (HAL_LCD == TRUE)
//  433 
//  434   uint8 tmpLen;
//  435   uint8 buf[LCD_MAX_BUF];
//  436   uint32 err;
//  437 
//  438   tmpLen = (uint8)osal_strlen( (char*)title );
        CALLA   #osal_strlen
        MOV.B   R12, R10
//  439   if ( tmpLen )
        MOV.W   SP, R8
        ADD.W   #0x0, R8
        CMP.B   #0x0, R12
        JEQ     ??HalLcdWriteStringValueValue_0
//  440   {
//  441     osal_memcpy( buf, title, tmpLen );
        MOV.B   R12, R14
        MOV.W   R4, R13
        MOV.W   R8, R12
        CALLA   #osal_memcpy
//  442     buf[tmpLen++] = ' ';
        MOV.W   R8, R15
        ADD.W   R10, R15
        MOV.B   #0x20, 0(R15)
        ADD.B   #0x1, R10
//  443   }
//  444 
//  445   err = (uint32)(value1);
//  446   _ltoa( err, &buf[tmpLen], format1 );
??HalLcdWriteStringValueValue_0:
        MOV.B   R5, R15
        MOV.W   R8, R14
        ADD.W   R10, R14
        MOV.W   R7, R12
        MOV.W   #0x0, R13
        CALLA   #_ltoa
//  447   tmpLen = (uint8)osal_strlen( (char*)buf );
        MOV.W   R8, R12
        CALLA   #osal_strlen
        MOV.B   R12, R10
//  448 
//  449   buf[tmpLen++] = ',';
        MOV.W   R8, R15
        ADD.W   R10, R15
        MOV.B   #0x2c, 0(R15)
        ADD.B   #0x1, R10
//  450   buf[tmpLen++] = ' ';
        MOV.W   R8, R15
        ADD.W   R10, R15
        MOV.B   #0x20, 0(R15)
//  451   err = (uint32)(value2);
//  452   _ltoa( err, &buf[tmpLen], format2 );
        MOV.B   R6, R15
        ADD.B   #0x1, R10
        MOV.W   R8, R14
        ADD.W   R10, R14
        CALLA   #?Subroutine0
//  453 
//  454   HalLcdWriteString( (char *)buf, line );		
//  455 
//  456 #endif
//  457 }
??CrossCallReturnLabel_1:
        ADD.W   #0x1a, SP
          CFI CFA SP+20
        POPM.W  #0x8, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R4L SameValue
          CFI R5L SameValue
          CFI R6L SameValue
          CFI R7L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock8
//  458 
//  459 /**************************************************************************************************
//  460  * @fn      HalLcdDisplayPercentBar
//  461  *
//  462  * @brief   Display percentage bar on the LCD
//  463  *
//  464  * @param   title   -
//  465  *          value   -
//  466  *
//  467  * @return  None
//  468  **************************************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  469 void HalLcdDisplayPercentBar( char *title, uint8 value )
HalLcdDisplayPercentBar:
          CFI Block cfiBlock9 Using cfiCommon0
          CFI Function HalLcdDisplayPercentBar
//  470 {
        FUNCALL HalLcdDisplayPercentBar, HalLcdWriteString
        LOCFRAME CSTACK, 30, STACK
        FUNCALL HalLcdDisplayPercentBar, osal_memcpy
        LOCFRAME CSTACK, 30, STACK
        FUNCALL HalLcdDisplayPercentBar, _ltoa
        LOCFRAME CSTACK, 30, STACK
        FUNCALL HalLcdDisplayPercentBar, HalLcdWriteString
        LOCFRAME CSTACK, 30, STACK
        PUSHM.W #0x4, R11
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+12
        SUB.W   #0x12, SP
          CFI CFA SP+30
        MOV.B   R13, R10
//  471 #if (HAL_LCD == TRUE)
//  472 
//  473   uint8 percent;
//  474   uint8 leftOver;
//  475   uint8 buf[17];
//  476   uint32 err;
//  477   uint8 x;
//  478 
//  479   /* Write the title: */
//  480   HalLcdWriteString( title, HAL_LCD_LINE_1 );
        MOV.B   #0x1, R13
        CALLA   #HalLcdWriteString
//  481 
//  482   if ( value > 100 )
        CMP.B   #0x65, R10
        JNC     ??HalLcdDisplayPercentBar_1
//  483     value = 100;
        MOV.B   #0x64, R10
//  484 
//  485   /* convert to blocks */
//  486   percent = (uint8)(value / 10);
??HalLcdDisplayPercentBar_1:
        CALLA   #?Subroutine1
??CrossCallReturnLabel_2:
        MOV.B   R12, R9
//  487   leftOver = (uint8)(value % 10);
        CALLA   #?Subroutine1
??CrossCallReturnLabel_3:
        MOV.B   R14, R11
//  488 
//  489   /* Make window */
//  490   osal_memcpy( buf, "[          ]  ", 15 );
        MOV.W   SP, R8
        ADD.W   #0x0, R8
        MOV.W   #0xf, R14
        MOV.W   #`?<Constant "[          ]  ">`, R13
        MOV.W   R8, R12
        CALLA   #osal_memcpy
//  491 
//  492   for ( x = 0; x < percent; x ++ )
        MOV.B   #0x0, R15
        JMP     ??HalLcdDisplayPercentBar_2
//  493   {
//  494     buf[1+x] = '>';
??HalLcdDisplayPercentBar_0:
        MOV.B   #0x3e, 0x1(R14)
//  495   }
        ADD.B   #0x1, R15
??HalLcdDisplayPercentBar_2:
        MOV.W   R8, R14
        ADD.W   R15, R14
        CMP.B   R9, R15
        JNC     ??HalLcdDisplayPercentBar_0
//  496 
//  497   if ( leftOver >= 5 )
        CMP.B   #0x5, R11
        JNC     ??HalLcdDisplayPercentBar_3
//  498     buf[1+x] = '+';
        MOV.B   #0x2b, 0x1(R14)
//  499 
//  500   err = (uint32)value;
//  501   _ltoa( err, (uint8*)&buf[13], 10 );
??HalLcdDisplayPercentBar_3:
        MOV.B   #0xa, R15
        MOV.W   R8, R14
        ADD.W   #0xd, R14
        MOV.B   R10, R12
        MOV.W   #0x0, R13
        CALLA   #_ltoa
//  502 
//  503   HalLcdWriteString( (char*)buf, HAL_LCD_LINE_2 );
        MOV.B   #0x2, R13
        MOV.W   R8, R12
        CALLA   #HalLcdWriteString
//  504 
//  505 #endif
//  506 
//  507 }
        ADD.W   #0x12, SP
          CFI CFA SP+12
        POPM.W  #0x4, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock9

        RSEG CODE:CODE:REORDER:NOROOT(1)
?Subroutine1:
          CFI Block cfiCond10 Using cfiCommon0
          CFI Function HalLcdDisplayPercentBar
          CFI Conditional ??CrossCallReturnLabel_2
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+34
          CFI Block cfiCond11 Using cfiCommon0
          CFI (cfiCond11) Function HalLcdDisplayPercentBar
          CFI (cfiCond11) Conditional ??CrossCallReturnLabel_3
          CFI (cfiCond11) R8L Frame(CFA, -12)
          CFI (cfiCond11) R9L Frame(CFA, -10)
          CFI (cfiCond11) R10L Frame(CFA, -8)
          CFI (cfiCond11) R11L Frame(CFA, -6)
          CFI (cfiCond11) CFA SP+34
          CFI Block cfiPicker12 Using cfiCommon1
          CFI (cfiPicker12) NoFunction
          CFI (cfiPicker12) Picker
        MOV.B   R10, R12
        MOV.B   #0xa, R14
        BRA     #?DivMod8u
          CFI EndBlock cfiCond10
          CFI EndBlock cfiCond11
          CFI EndBlock cfiPicker12
//  508 
//  509 /**************************************************************************************************
//  510  *                                    HARDWARE LCD
//  511  **************************************************************************************************/
//  512 #define LCD_BACKLIGHT_OUT P8OUT
//  513 #define LCD_BACKLIGHT_DIR P8DIR
//  514 #define LCD_BACKLIGHT_SEL P8SEL
//  515 #define LCD_BACKLIGHT_PIN BIT3
//  516 
//  517 #define LCD_COMM_OUT_V2   P8OUT
//  518 #define LCD_COMM_DIR_V2   P8DIR
//  519 #define LCD_COMM_SEL_V2   P8SEL
//  520 #define LCD_CS_PIN_V2     BIT1
//  521 #define LCD_RESET_PIN_V2  BIT2
//  522 
//  523 #define LCD_COMM_OUT_V3   P9OUT
//  524 #define LCD_COMM_DIR_V3   P9DIR
//  525 #define LCD_COMM_SEL_V3   P9SEL
//  526 #define LCD_CS_PIN_V3     BIT6
//  527 #define LCD_RESET_PIN_V3  BIT7
//  528 
//  529 #if (HAL_LCD == TRUE)
//  530 /**************************************************************************************************
//  531  * @fn      HalLcd_HW_Init
//  532  *
//  533  * @brief   Initilize HW LCD Driver.
//  534  *
//  535  * @param   None
//  536  *
//  537  * @return  None
//  538  **************************************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  539 void HalLcd_HW_Init(void)
HalLcd_HW_Init:
          CFI Block cfiBlock13 Using cfiCommon0
          CFI Function HalLcd_HW_Init
//  540 {
        FUNCALL HalLcd_HW_Init, HalLcd_HW_InitBackLight
        LOCFRAME CSTACK, 6, STACK
        FUNCALL HalLcd_HW_Init, HalLcd_HW_SendCmd
        LOCFRAME CSTACK, 6, STACK
        FUNCALL HalLcd_HW_Init, HalLcd_HW_Active
        LOCFRAME CSTACK, 6, STACK
        FUNCALL HalLcd_HW_Init, HalLcd_HW_Clear
        LOCFRAME CSTACK, 6, STACK
        PUSH.W  R10
          CFI R10L Frame(CFA, -6)
          CFI CFA SP+6
//  541   int counter=0, i=0;
        MOV.W   #0x0, R10
//  542 
//  543   LCD_BACKLIGHT_DIR |= LCD_BACKLIGHT_PIN;
        BIS.B   #0x8, &0x265
//  544   LCD_BACKLIGHT_OUT |= LCD_BACKLIGHT_PIN;
        BIS.B   #0x8, &0x263
//  545   LCD_BACKLIGHT_SEL |= LCD_BACKLIGHT_PIN;
        BIS.B   #0x8, &0x26b
//  546 
//  547   if (HAL_MSP_EXP430F5438_REV_02())
        CMP.B   #0x0, &0x261
        JGE     ??HalLcd_HW_Init_1
//  548   {
//  549     LCD_COMM_DIR_V2 |= LCD_CS_PIN_V2 | LCD_RESET_PIN_V2;
        BIS.B   #0x6, &0x265
//  550     LCD_COMM_OUT_V2 |= LCD_CS_PIN_V2 | LCD_RESET_PIN_V2;
        BIS.B   #0x6, &0x263
//  551 
//  552     /* Reset LCD */
//  553     LCD_COMM_OUT_V2 &= ~LCD_RESET_PIN_V2;
        BIC.B   #0x4, &0x263
//  554     for (i = 0x47FF; i > 0; i--);
//  555     LCD_COMM_OUT_V2 |= LCD_RESET_PIN_V2;
        BIS.B   #0x4, &0x263
        JMP     ??HalLcd_HW_Init_2
//  556   }
//  557   else /* Must be MSP EXP430F5438_REV_03 */
//  558   {
//  559     LCD_COMM_DIR_V3 |= LCD_CS_PIN_V3 | LCD_RESET_PIN_V3;
??HalLcd_HW_Init_1:
        BIS.B   #0xc0, &0x284
//  560     LCD_COMM_OUT_V3 |= LCD_CS_PIN_V3 | LCD_RESET_PIN_V3;
        BIS.B   #0xc0, &0x282
//  561 
//  562     /* Reset LCD */
//  563     LCD_COMM_OUT_V3 &= ~LCD_RESET_PIN_V3;
        BIC.B   #0x80, &0x282
//  564     for (i = 0x47FF; i > 0; i--);
//  565     LCD_COMM_OUT_V3 |= LCD_RESET_PIN_V3;
        BIS.B   #0x80, &0x282
//  566   }
//  567 
//  568   /* UCLK, MOSI setup, SOMI cleared */
//  569   P9SEL |= BIT1 + BIT3;
??HalLcd_HW_Init_2:
        BIS.B   #0xa, &0x28a
//  570   P9SEL &= ~BIT2;
        BIC.B   #0x4, &0x28a
//  571   P9DIR |= BIT1 + BIT3;
        BIS.B   #0xa, &0x284
//  572   P9DIR &= ~BIT2;
        BIC.B   #0x4, &0x284
//  573 
//  574   /* 3-pin, 8-bit SPI master */
//  575   UCB2CTL0 |= UCMST+UCSYNC+UCCKPL+UCMSB;
        BIS.B   #0x69, &0x661
//  576 
//  577   /* SMCLK */
//  578   UCB2CTL1 |= UCSSEL_2;
        BIS.B   #0x80, &0x660
//  579   UCB2BR0 = 3;
        MOV.B   #0x3, &0x666
//  580   UCB2BR1 = 0;
        MOV.B   #0x0, &0x667
//  581 
//  582   /* Initialize USCI */
//  583   UCB2CTL1 &= ~UCSWRST;
        BIC.B   #0x1, &0x660
//  584   UCB2IFG &= ~UCRXIFG;
        BIC.B   #0x1, &0x67d
//  585 
//  586   /* Initialize backlight */
//  587 #if !defined (POWER_SAVING)
//  588   HalLcd_HW_InitBackLight();
        CALLA   #HalLcd_HW_InitBackLight
//  589 #endif
//  590 
//  591   /* LCD Initialization Routine Using Predefined settings */
//  592   while (counter < 8*6)
//  593   {
//  594     HalLcd_HW_SendCmd(&LcdInitMacro[counter]);
??HalLcd_HW_Init_0:
        MOV.W   R10, R12
        ADD.W   #LcdInitMacro, R12
        CALLA   #HalLcd_HW_SendCmd
//  595     counter += 6;
        ADD.W   #0x6, R10
//  596   }
        CMP.W   #0x30, R10
        JL      ??HalLcd_HW_Init_0
//  597 
//  598   /* Turn LCD ON */
//  599   HalLcd_HW_Active();
        CALLA   #HalLcd_HW_Active
//  600 
//  601   /* Clear screen */
//  602   HalLcd_HW_Clear();
        CALLA   #HalLcd_HW_Clear
//  603 }
        POP.W   R10
          CFI R10L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock13
        REQUIRE _A_PDDIR_L
        REQUIRE _A_PDOUT_L
        REQUIRE _A_PDSEL_L
        REQUIRE _A_PDIN_L
        REQUIRE _A_PEDIR_L
        REQUIRE _A_PEOUT_L
        REQUIRE _A_PESEL_L
        REQUIRE _A_UCB2CTLW0_L
        REQUIRE _A_UCB2BRW_L
        REQUIRE _A_UCB2ICTL_L
//  604 
//  605 /**************************************************************************************************
//  606  * @fn      HalLcd_HW_Control
//  607  *
//  608  * @brief   Write 6 bytes command to the LCD
//  609  *
//  610  * @param   uint8 cmd[] - 6 bytes command to be written to the LCD
//  611  *
//  612  * @return  None
//  613  **************************************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  614 void HalLcd_HW_SendCmd(uint8 cmd[])
HalLcd_HW_SendCmd:
          CFI Block cfiBlock14 Using cfiCommon0
          CFI Function HalLcd_HW_SendCmd
//  615 {
//  616   unsigned char i;
//  617   unsigned char rev02 = HAL_MSP_EXP430F5438_REV_02();
        BIT.B   #0x80, &0x261
        SUBC.B  R14, R14
        ADD.B   #0x1, R14
//  618 
//  619   if (rev02)
        BIT.B   #0x1, R14
        JNC     ??HalLcd_HW_SendCmd_2
//  620   {
//  621     LCD_COMM_OUT_V2 &= ~LCD_CS_PIN_V2;      //CS = 0 --> Start Transfer
        BIC.B   #0x2, &0x263
        JMP     ??HalLcd_HW_SendCmd_3
//  622   }
//  623   else /* Must be MSP EXP430F5438_REV_03 */
//  624   {
//  625     LCD_COMM_OUT_V3 &= ~LCD_CS_PIN_V3;      //CS = 0 --> Start Transfer
??HalLcd_HW_SendCmd_2:
        BIC.B   #0x40, &0x282
//  626   }
//  627 
//  628   for ( i=0; i<6; i++ )
??HalLcd_HW_SendCmd_3:
        MOV.B   #0x0, R15
//  629   {
//  630     while (!(UCB2IFG & UCTXIFG));
??HalLcd_HW_SendCmd_0:
        BIT.B   #0x2, &0x67d
        JNC     ??HalLcd_HW_SendCmd_0
//  631     UCB2TXBUF = cmd[i];
        MOV.W   R12, R13
        ADD.W   R15, R13
        MOV.B   @R13, &0x66e
//  632 
//  633     while (UCB2STAT & UCBUSY);
??HalLcd_HW_SendCmd_1:
        BIT.B   #0x1, &0x66a
        JC      ??HalLcd_HW_SendCmd_1
//  634     if (i==2)                               //Pull CS up after 3 bytes
        CMP.B   #0x2, R15
        JNE     ??HalLcd_HW_SendCmd_4
//  635     {
//  636       if (rev02)
        BIT.B   #0x1, R14
        JNC     ??HalLcd_HW_SendCmd_5
//  637       {
//  638         LCD_COMM_OUT_V2 |= LCD_CS_PIN_V2;   //CS = 1 --> Stop Transfer
        BIS.B   #0x2, &0x263
//  639         LCD_COMM_OUT_V2 &= ~LCD_CS_PIN_V2;  //CS = 0 --> Start Transfer	
        BIC.B   #0x2, &0x263
        JMP     ??HalLcd_HW_SendCmd_4
//  640       }
//  641       else /* Must be MSP EXP430F5438_REV_03 */
//  642       {
//  643         LCD_COMM_OUT_V3 |= LCD_CS_PIN_V3;   //CS = 1 --> Stop Transfer
??HalLcd_HW_SendCmd_5:
        BIS.B   #0x40, &0x282
//  644         LCD_COMM_OUT_V3 &= ~LCD_CS_PIN_V3;  //CS = 0 --> Start Transfer	
        BIC.B   #0x40, &0x282
//  645       }
//  646     }
//  647   }
??HalLcd_HW_SendCmd_4:
        ADD.B   #0x1, R15
        CMP.B   #0x6, R15
        JNC     ??HalLcd_HW_SendCmd_0
//  648 
//  649   if (rev02)
        BIT.B   #0x1, R14
        JNC     ??HalLcd_HW_SendCmd_6
//  650   {
//  651     LCD_COMM_OUT_V2 |= LCD_CS_PIN_V2;       //CS = 1 --> Stop Transfer
        BIS.B   #0x2, &0x263
        RETA
//  652   }
//  653   else /* Must be MSP EXP430F5438_REV_03 */
//  654   {
//  655     LCD_COMM_OUT_V3 |= LCD_CS_PIN_V3;       //CS = 1 --> Stop Transfer
??HalLcd_HW_SendCmd_6:
        BIS.B   #0x40, &0x282
//  656   }
//  657 }
        RETA
          CFI EndBlock cfiBlock14
        REQUIRE _A_PDIN_L
        REQUIRE _A_PDOUT_L
        REQUIRE _A_PEOUT_L
        REQUIRE _A_UCB2ICTL_L
        REQUIRE UCB2TXBUF
        REQUIRE UCB2STAT
//  658 
//  659 
//  660 /**************************************************************************************************
//  661  * @fn          HalLcd_HW_SetBackLight
//  662  *
//  663  * @brief       Initialize Backlight with predefined value
//  664  *
//  665  * @param       None
//  666  *
//  667  * @return      none
//  668  **************************************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  669 void HalLcd_HW_InitBackLight(void)
HalLcd_HW_InitBackLight:
          CFI Block cfiBlock15 Using cfiCommon0
          CFI Function HalLcd_HW_InitBackLight
//  670 {
//  671   uint8 dutyCycle = 0, i;
//  672 
//  673    if (HAL_LCD_BACKLIGHT_LEVEL > 0)
//  674   {
//  675     TA0CCTL3 = OUTMOD_4;
        MOV.W   #0x80, &0x348
//  676 
//  677     for (i = 0; i < HAL_LCD_BACKLIGHT_LEVEL; i++)
//  678     {
//  679       dutyCycle += 25;
//  680     }
//  681     TA0CCR3 = dutyCycle;
        MOV.W   #0xfa, &0x358
//  682   }
//  683   else
//  684   {  	
//  685     TA0CCTL3 = 0;
//  686   }
//  687 }
        RETA
          CFI EndBlock cfiBlock15
        REQUIRE TA0CCTL3
        REQUIRE TA0CCR3
//  688 
//  689 /**************************************************************************************************
//  690  * @fn      HalLcd_HW_Clear
//  691  *
//  692  * @brief   Clear the HW LCD
//  693  *
//  694  * @param   None
//  695  *
//  696  * @return  None
//  697  **************************************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  698 void HalLcd_HW_Clear(void)
HalLcd_HW_Clear:
          CFI Block cfiBlock16 Using cfiCommon0
          CFI Function HalLcd_HW_Clear
//  699 {
        FUNCALL HalLcd_HW_Clear, HalLcd_HW_SetAddress
        LOCFRAME CSTACK, 6, STACK
        FUNCALL HalLcd_HW_Clear, HalLcd_HW_DrawCurrentBlock
        LOCFRAME CSTACK, 6, STACK
        FUNCALL HalLcd_HW_Clear, HalLcd_HW_SetAddress
        LOCFRAME CSTACK, 6, STACK
        PUSH.W  R10
          CFI R10L Frame(CFA, -6)
          CFI CFA SP+6
//  700   int i;
//  701   HalLcd_HW_SetAddress(0);
        MOV.W   #0x0, R12
        CALLA   #HalLcd_HW_SetAddress
//  702   for ( i = 0; i < LCD_Size; i++)
        MOV.W   #0xdb1, R10
//  703       HalLcd_HW_DrawCurrentBlock(0x00);
??HalLcd_HW_Clear_0:
        MOV.W   #0x0, R12
        CALLA   #HalLcd_HW_DrawCurrentBlock
        ADD.W   #0xffff, R10
        JNE     ??HalLcd_HW_Clear_0
//  704   HalLcd_HW_SetAddress(0);
        MOV.W   #0x0, R12
        CALLA   #HalLcd_HW_SetAddress
//  705 }
        POP.W   R10
          CFI R10L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock16
//  706 
//  707 /**************************************************************************************************
//  708  * @fn          halLcdWriteLine
//  709  *
//  710  * @brief       Write one line on display
//  711  *
//  712  * @param       uint8 line - display line
//  713  *              char *pText - text buffer to write
//  714  *
//  715  * @return      none
//  716  **************************************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  717 void HalLcd_HW_WriteLine(char str[], uint8 line)
HalLcd_HW_WriteLine:
          CFI Block cfiBlock17 Using cfiCommon0
          CFI Function HalLcd_HW_WriteLine
//  718 {
        FUNCALL HalLcd_HW_WriteLine, HalLcd_HW_SetAddress
        LOCFRAME CSTACK, 16, STACK
        FUNCALL HalLcd_HW_WriteLine, HalLcd_HW_DrawBlock
        LOCFRAME CSTACK, 16, STACK
        FUNCALL HalLcd_HW_WriteLine, HalLcd_HW_SetAddress
        LOCFRAME CSTACK, 16, STACK
        PUSHM.W #0x6, R11
          CFI R6L Frame(CFA, -16)
          CFI R7L Frame(CFA, -14)
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+16
        MOV.W   R12, R11
//  719   int i,j,Counter=0, BlockValue;
//  720   int Address,  LCD_MEM_Add, ActualAddress;
//  721   char LookUpChar;
//  722   int temp;
//  723 
//  724   /* Set correct line based on font size */
//  725   HalLcd_HW_SetAddress( (line * FONT_HEIGHT) << 5) ;  // 0x20 = 2^5
        MOV.B   R13, R13
        MOV.W   R13, R12
        RPT     #0xb
        ADDX.W  R13, R12
        RPT     #0x5
        RLAX.W  R12
        CALLA   #HalLcd_HW_SetAddress
//  726 
//  727   ActualAddress = LcdAddress;
        MOV.W   &LcdAddress, R9
//  728   Counter =  LcdAddress & 0x1F;
        MOV.W   R9, R8
        AND.W   #0x1f, R8
//  729  	i=0;
        MOV.W   #0x0, R6
        JMP     ??HalLcd_HW_WriteLine_3
//  730 
//  731   while (str[i]!=0)
//  732   {
//  733     LookUpChar = fonts_lookup[str[i]];
//  734     for (j=0;j < FONT_HEIGHT ;j++)
//  735     {
//  736       Address = ActualAddress + j*0x20;
//  737       temp = Address >> 5;
//  738       temp = temp + (temp <<4);
//  739 
//  740       LCD_MEM_Add = temp + (Address & 0x1F);
//  741 
//  742       BlockValue = LCD_MEM[ LCD_MEM_Add ];
//  743 
//  744       if (HAL_LCD_TEXT_STYLE & INVERT_TEXT)
//  745       {
//  746         if (HAL_LCD_TEXT_STYLE & OVERWRITE_TEXT)
//  747           BlockValue = 0xFFFF - fonts[LookUpChar*13+j];
//  748         else
//  749           BlockValue |= 0xFFFF - fonts[LookUpChar*13+j];
//  750       }
//  751       else
//  752       {
//  753         if (HAL_LCD_TEXT_STYLE & OVERWRITE_TEXT)
//  754           BlockValue = fonts[LookUpChar*(FONT_HEIGHT+1) +j];
//  755         else
//  756           BlockValue |= fonts[LookUpChar*(FONT_HEIGHT+1) +j];
//  757       }
//  758       HalLcd_HW_DrawBlock( Address, BlockValue);
//  759     }
//  760 
//  761     Counter++;
//  762     if (Counter == 17)
//  763     {
//  764       Counter = 0;
//  765       ActualAddress += 0x20*FONT_HEIGHT  - 16;
//  766       if (ActualAddress > LCD_LAST_PIXEL-0x20*FONT_HEIGHT )
//  767         ActualAddress = 0;
//  768     }
//  769     else
//  770       ActualAddress++;
??HalLcd_HW_WriteLine_1:
        ADD.W   #0x1, R9
//  771     i++;
??HalLcd_HW_WriteLine_2:
        ADD.W   #0x1, R6
??HalLcd_HW_WriteLine_3:
        MOV.W   R11, R15
        ADD.W   R6, R15
        MOV.B   @R15, R15
        CMP.B   #0x0, R15
        JEQ     ??HalLcd_HW_WriteLine_4
        MOV.B   fonts_lookup(R15), R10
        MOV.W   #0x0, R7
??HalLcd_HW_WriteLine_0:
        MOV.W   R7, R15
        RPT     #0xd
        ADDX.W  R10, R15
        RLA.W   R15
        MOV.W   fonts(R15), R13
        MOV.W   R7, R15
        RPT     #0x5
        RLAX.W  R15
        MOV.W   R9, R12
        ADD.W   R15, R12
        CALLA   #HalLcd_HW_DrawBlock
        ADD.W   #0x1, R7
        CMP.W   #0xc, R7
        JL      ??HalLcd_HW_WriteLine_0
        ADD.W   #0x1, R8
        CMP.W   #0x11, R8
        JNE     ??HalLcd_HW_WriteLine_1
        MOV.W   #0x0, R8
        ADD.W   #0x170, R9
        CMP.W   #0xc32, R9
        JL      ??HalLcd_HW_WriteLine_2
        MOV.W   #0x0, R9
        JMP     ??HalLcd_HW_WriteLine_2
//  772   }
//  773   HalLcd_HW_SetAddress(ActualAddress);
??HalLcd_HW_WriteLine_4:
        MOV.W   R9, R12
        CALLA   #HalLcd_HW_SetAddress
//  774 }
        POPM.W  #0x6, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R6L SameValue
          CFI R7L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock17
//  775 
//  776 /**************************************************************************************************
//  777  * @fn          HalLcd_HW_InitContrast
//  778  *
//  779  * @brief       Initialize the constrast based on the predefined value
//  780  *
//  781  * @param       uint8 level 70 to 127 - min/max
//  782  *
//  783  * @return      none
//  784  **************************************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  785 void HalLcd_HW_SetContrast(uint8 level)
HalLcd_HW_SetContrast:
          CFI Block cfiBlock18 Using cfiCommon0
          CFI Function HalLcd_HW_SetContrast
//  786 {
//  787   HAL_LCD_SETCONTRAST_CONTROL[5] = level;
        FUNCALL HalLcd_HW_SetContrast, HalLcd_HW_SendCmd
        LOCFRAME CSTACK, 4, STACK
        MOV.B   R12, &HAL_LCD_SETCONTRAST_CONTROL + 5
//  788   HalLcd_HW_SendCmd(HAL_LCD_SETCONTRAST_CONTROL);
        MOV.W   #HAL_LCD_SETCONTRAST_CONTROL, R12
        BRA     #HalLcd_HW_SendCmd
          CFI EndBlock cfiBlock18
//  789 }
//  790 
//  791 /**************************************************************************************************
//  792  * @fn          HalLcd_HW_SetAddress
//  793  *
//  794  * @brief       The the current location address
//  795  *
//  796  * @param       Address = LcdAddress  					
//  797  *              LcdTableAddress = Correct Address Row + Column
//  798  *                              = (Address / 0x20)* 17 + Column
//  799  *
//  800  * @return      none
//  801  **************************************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  802 void HalLcd_HW_SetAddress(int Address)
HalLcd_HW_SetAddress:
          CFI Block cfiBlock19 Using cfiCommon0
          CFI Function HalLcd_HW_SetAddress
//  803 {
        FUNCALL HalLcd_HW_SetAddress, HalLcd_HW_SendCmd
        LOCFRAME CSTACK, 6, STACK
        PUSH.W  R10
          CFI R10L Frame(CFA, -6)
          CFI CFA SP+6
        MOV.W   R12, R10
//  804   int temp;
//  805   Draw_Block_Address_Macro[4] = Address >> 8;
        MOV.W   R12, R15
        RPT     #0x8
        RRAX.W  R15
        MOV.B   R15, &Draw_Block_Address_Macro + 4
//  806   Draw_Block_Address_Macro[5] = Address & 0xFF;
        MOV.B   R12, &Draw_Block_Address_Macro + 5
//  807   HalLcd_HW_SendCmd(Draw_Block_Address_Macro);
        MOV.W   #Draw_Block_Address_Macro, R12
        CALLA   #HalLcd_HW_SendCmd
//  808   LcdAddress = Address;
        MOV.W   R10, &LcdAddress
//  809   temp = Address >> 5;                      // Divided by 0x20
        MOV.W   R10, R14
        RPT     #0x5
        RRAX.W  R14
//  810   temp = temp + (temp << 4);
//  811   //Multiplied by (1+16) and added by the offset
//  812   LcdTableAddress = temp + (Address & 0x1F);
        MOV.W   R14, R15
        RLAM.W  #0x4, R15
        ADD.W   R15, R14
        AND.W   #0x1f, R10
        ADD.W   R10, R14
        MOV.W   R14, &LcdTableAddress
//  813 }
        POP.W   R10
          CFI R10L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock19
//  814 
//  815 /**************************************************************************************************
//  816  * @fn          HalLcd_Active
//  817  *
//  818  * @brief       Enable the LCD
//  819  *
//  820  * @param       None
//  821  *
//  822  * @return      None
//  823  **************************************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  824 void HalLcd_HW_Active(void)
HalLcd_HW_Active:
          CFI Block cfiBlock20 Using cfiCommon0
          CFI Function HalLcd_HW_Active
//  825 {
//  826   HalLcd_HW_SendCmd(LcdInitMacro);
        FUNCALL HalLcd_HW_Active, HalLcd_HW_SendCmd
        LOCFRAME CSTACK, 4, STACK
        FUNCALL HalLcd_HW_Active, HalLcd_HW_SendCmd
        LOCFRAME CSTACK, 4, STACK
        MOV.W   #LcdInitMacro, R12
        CALLA   #HalLcd_HW_SendCmd
//  827   LcdInitMacro[ 3 * 6 + 5 ] |= BIT3 ;
//  828   LcdInitMacro[ 3 * 6 + 5 ] &= ~BIT0;
        BIC.B   #0x1, &LcdInitMacro + 23
        BIS.B   #0x8, &LcdInitMacro + 23
//  829   HalLcd_HW_SendCmd(&LcdInitMacro[ 3 * 6 ]);
        MOV.W   #LcdInitMacro + 18, R12
        BRA     #HalLcd_HW_SendCmd
          CFI EndBlock cfiBlock20
//  830 }
//  831 
//  832 
//  833 /**************************************************************************************************
//  834  * @fn          HalLcd_HW_DrawCurrentBlock
//  835  *
//  836  * @brief       Draw the block at current position
//  837  *              Writes Value to LCD CGRAM
//  838  *              Writes Value to MSP430 Internal LCD Table
//  839  *              Updates LcdAddress and LcdTableAddress due to auto increment feature
//  840  *
//  841  * @param       Value - Value of the current block
//  842  *
//  843  * @return      None
//  844  **************************************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  845 void HalLcd_HW_DrawCurrentBlock(unsigned int Value)
HalLcd_HW_DrawCurrentBlock:
          CFI Block cfiBlock21 Using cfiCommon0
          CFI Function HalLcd_HW_DrawCurrentBlock
//  846 {
//  847   int temp;
//  848   Draw_Block_Value_Macro[4] = Value >> 8;
        FUNCALL HalLcd_HW_DrawCurrentBlock, HalLcd_HW_SendCmd
        LOCFRAME CSTACK, 4, STACK
        FUNCALL HalLcd_HW_DrawCurrentBlock, HalLcd_HW_SetAddress
        LOCFRAME CSTACK, 4, STACK
        FUNCALL HalLcd_HW_DrawCurrentBlock, HalLcd_HW_SetAddress
        LOCFRAME CSTACK, 4, STACK
        MOV.W   R12, R15
        RPT     #0x8
        RRUX.W  R15
        MOV.B   R15, &Draw_Block_Value_Macro + 4
//  849   Draw_Block_Value_Macro[5] = Value & 0xFF;
        MOV.B   R12, &Draw_Block_Value_Macro + 5
//  850   LCD_MEM[ LcdTableAddress ] = Value;
        MOV.W   &LcdTableAddress, R15
        RLA.W   R15
        MOV.W   R12, LCD_MEM(R15)
//  851   HalLcd_HW_SendCmd(Draw_Block_Value_Macro);
        MOV.W   #Draw_Block_Value_Macro, R12
        CALLA   #HalLcd_HW_SendCmd
//  852   LcdAddress++;
        ADD.W   #0x1, &LcdAddress
//  853   temp = LcdAddress >> 5;                   // Divided by 0x20
        MOV.W   &LcdAddress, R12
        MOV.W   R12, R14
        RPT     #0x5
        RRUX.W  R14
//  854   temp = temp + (temp << 4);
//  855   //Multiplied by (1+16) and added by the offset
//  856   LcdTableAddress = temp + (LcdAddress & 0x1F);
        MOV.W   R14, R15
        RLAM.W  #0x4, R15
        ADD.W   R15, R14
        MOV.W   R12, R15
        AND.W   #0x1f, R15
        ADD.W   R15, R14
        MOV.W   R14, &LcdTableAddress
//  857   // If LcdAddress gets off the right edge, move to next line
//  858   if ((LcdAddress & 0x1F) > 0x11)
        MOV.B   R12, R14
        AND.B   #0x1f, R14
        CMP.B   #0x12, R14
        JNC     ??HalLcd_HW_DrawCurrentBlock_0
//  859     HalLcd_HW_SetAddress( (LcdAddress & 0xFFE0) + 0x20 );
        AND.W   #0xffe0, R12
        ADD.W   #0x20, R12
        CALLA   #HalLcd_HW_SetAddress
//  860 
//  861   if (LcdAddress == LCD_Size)
??HalLcd_HW_DrawCurrentBlock_0:
        CMP.W   #0xdb1, &LcdAddress
        JNE     ??HalLcd_HW_DrawCurrentBlock_1
//  862     HalLcd_HW_SetAddress( 0 );
        MOV.W   #0x0, R12
        CALLA   #HalLcd_HW_SetAddress
//  863 }
??HalLcd_HW_DrawCurrentBlock_1:
        RETA
          CFI EndBlock cfiBlock21
//  864 
//  865 /**************************************************************************************************
//  866  * @fn          HalLcd_HW_DrawBlock
//  867  *
//  868  * @brief       Writes Value to LCD CGRAM and LCD_MEM at Address location
//  869  *
//  870  * @param       Value - Value of the current block
//  871  *
//  872  * @return      None
//  873  **************************************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  874 void HalLcd_HW_DrawBlock(unsigned int Address, unsigned int Value)
HalLcd_HW_DrawBlock:
          CFI Block cfiBlock22 Using cfiCommon0
          CFI Function HalLcd_HW_DrawBlock
//  875 {
        FUNCALL HalLcd_HW_DrawBlock, HalLcd_HW_SetAddress
        LOCFRAME CSTACK, 6, STACK
        FUNCALL HalLcd_HW_DrawBlock, HalLcd_HW_DrawCurrentBlock
        LOCFRAME CSTACK, 6, STACK
        PUSH.W  R10
          CFI R10L Frame(CFA, -6)
          CFI CFA SP+6
        MOV.W   R13, R10
//  876   HalLcd_HW_SetAddress(Address);
        CALLA   #HalLcd_HW_SetAddress
//  877   HalLcd_HW_DrawCurrentBlock(Value);
        MOV.W   R10, R12
        CALLA   #HalLcd_HW_DrawCurrentBlock
//  878 }
        POP.W   R10
          CFI R10L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock22
//  879 
//  880 /**************************************************************************************************
//  881  * @fn      HalLcd_HW_Wait
//  882  *
//  883  * @brief   wait for 4 "nop"
//  884  *
//  885  * @param   uint16 i - number of 4xNOP
//  886  *
//  887  * @return  None
//  888  **************************************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  889 void HalLcd_HW_Wait(uint16 i)
HalLcd_HW_Wait:
          CFI Block cfiBlock23 Using cfiCommon0
          CFI Function HalLcd_HW_Wait
//  890 {
        JMP     ??HalLcd_HW_Wait_1
//  891   while(i--)
//  892   {
//  893     asm("nop");
??HalLcd_HW_Wait_0:
        nop
//  894     asm("nop");
        nop
//  895     asm("nop");
        nop
//  896     asm("nop");
        nop
//  897   }
??HalLcd_HW_Wait_1:
        MOV.W   R12, R15
        ADD.W   #0xffff, R12
        CMP.W   #0x0, R15
        JNE     ??HalLcd_HW_Wait_0
//  898 }
        RETA
          CFI EndBlock cfiBlock23

        RSEG DATA16_ID:CONST:SORT:NOROOT(0)
`?<Initializer for LcdInitMacro>`:
        DC8 116, 0, 0, 118, 0, 1, 116, 0, 1, 118, 0, 13, 116, 0, 2, 118, 0, 76
        DC8 116, 0, 3, 118, 18, 20, 116, 0, 4, 118, 4, 102, 116, 0, 5, 118, 0
        DC8 16, 116, 0, 6, 118, 0, 0, 116, 0, 7, 118, 0, 21, 116, 0, 8, 118, 0
        DC8 3, 116, 0, 9, 118, 0, 0, 116, 0, 10, 118, 0, 21, 116, 0, 11, 118, 0
        DC8 3, 116, 0, 12, 118, 0, 3, 116, 0, 13, 118, 0, 0, 116, 0, 14, 118, 0
        DC8 21, 116, 0, 15, 118, 0, 3, 116, 0, 16, 118, 0, 21, 116, 0, 17, 118
        DC8 0, 3

        RSEG DATA16_ID:CONST:SORT:NOROOT(0)
`?<Initializer for HAL_LCD_SETCONTRAST_CONTROL>`:
        DC8 116, 0, 4, 118, 4, 100

        RSEG DATA16_ID:CONST:SORT:NOROOT(0)
`?<Initializer for Read_Block_Address_Macro>`:
        DC8 116, 0, 18, 119, 0, 0

        RSEG DATA16_ID:CONST:SORT:NOROOT(0)
`?<Initializer for Draw_Block_Value_Macro>`:
        DC8 116, 0, 18, 118, 255, 255

        RSEG DATA16_ID:CONST:SORT:NOROOT(0)
`?<Initializer for Draw_Block_Address_Macro>`:
        DC8 116, 0, 17, 118, 0, 0

        RSEG CODE:CODE:REORDER:NOROOT(1)
?setjmp_save_r4:
        REQUIRE ?setjmp_r4
        REQUIRE ?longjmp_r4

        RSEG CODE:CODE:REORDER:NOROOT(1)
?setjmp_save_r5:
        REQUIRE ?setjmp_r5
        REQUIRE ?longjmp_r5

        END
//  899 
//  900 /**************************************************************************************************
//  901  * @fn      _itoa
//  902  *
//  903  * @brief   convert a 16bit number to ASCII
//  904  *
//  905  * @param   num -
//  906  *          buf -
//  907  *          radix -
//  908  *
//  909  * @return  void
//  910  *
//  911  **************************************************************************************************/
//  912 /*
//  913 void _itoa(uint16 num, byte *buf, byte radix)
//  914 {
//  915   char c,i;
//  916   byte *p, rst[5];
//  917 
//  918   p = rst;
//  919   for ( i=0; i<5; i++,p++ )
//  920   {
//  921     c = num % radix;  // Isolate a digit
//  922     *p = c + (( c < 10 ) ? '0' : '7');  // Convert to Ascii
//  923     num /= radix;
//  924     if ( !num )
//  925       break;
//  926   }
//  927 
//  928   for ( c=0 ; c<=i; c++ )
//  929     *buf++ = *p--;  // Reverse character order
//  930 
//  931   *buf = '\0';
//  932 }
//  933 */
//  934 #endif
//  935 
//  936 /**************************************************************************************************
//  937 **************************************************************************************************/
//  938 
//  939 
// 
// 1 230 bytes in segment CODE
//    26 bytes in segment DATA16_AN
// 2 319 bytes in segment DATA16_C
//   132 bytes in segment DATA16_I
//   132 bytes in segment DATA16_ID
// 3 746 bytes in segment DATA16_Z
// 
// 1 230 bytes of CODE  memory
// 2 451 bytes of CONST memory
// 3 878 bytes of DATA  memory (+ 26 bytes shared)
//
//Errors: none
//Warnings: none
