///////////////////////////////////////////////////////////////////////////////
//                                                                            /
// IAR C/C++ Compiler V5.51.2.50607/W32 for MSP430      18/Apr/2013  16:58:53 /
// Copyright 1996-2012 IAR Systems AB.                                        /
//                                                                            /
//    __rt_version  =  3                                                      /
//    __double_size =  32                                                     /
//    __reg_r4      =  free                                                   /
//    __reg_r5      =  free                                                   /
//    __pic         =  no                                                     /
//    __core        =  430X                                                   /
//    __data_model  =  small                                                  /
//    Source file   =  C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5. /
//                     1\Projects\zstack\ZAP\TVSA\Source\tvsa.c               /
//    Command line  =  -f C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2 /
//                     .5.1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\Source\zap /
//                     .cfg (-DZAP_PHY_SPI=1 -DZAP_PHY_UART=0                 /
//                     -DZAP_DEVICETYPE=ZG_DEVICETYPE_ROUTER                  /
//                     -DTVSA_DEVICE_ID=0x0016 -DTVSA_DONGLE=1 -DHAL_UART=1   /
//                     -DZAP_PHY_RESET_ZNP=TRUE -DZAP_ZNP_MT=FALSE            /
//                     -DZAP_APP_MSG=FALSE -DZAP_SBL_PROXY=FALSE              /
//                     -DZAP_AUTO_CFG=TRUE -DZAP_AUTO_START=TRUE              /
//                     -DZAP_NV_RESTORE=FALSE -DLCD_SUPPORTED                 /
//                     -DZAP_AF_DATA_REQ_FRAG=FALSE                           /
//                     -DZAP_AF_DATA_REQ_AREQ=!ZAP_AF_DATA_REQ_FRAG           /
//                     -DZAP_ZDO_STARTUP_AREQ=TRUE -DZAP_AF_FUNC              /
//                     -DZAP_SAPI_FUNC -DZAP_SYS_FUNC -DZAP_UTIL_FUNC         /
//                     -DZAP_ZDO_FUNC -DSECURE=0 -DZG_SECURE_DYNAMIC=0        /
//                     "-DDEFAULT_CHANLIST=(uint32)0x00000800"                /
//                     -DZDAPP_CONFIG_PAN_ID=0xFFFF -DPOLL_RATE=1000          /
//                     -DNWK_START_DELAY=100 -DMAX_BINDING_CLUSTER_IDS=4)     /
//                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5. /
//                     1\Projects\zstack\ZAP\TVSA\Source\tvsa.c -D            /
//                     ZAP_DEVICETYPE=ZG_DEVICETYPE_ROUTER -D                 /
//                     TVSA_DEVICE_ID=0x0016 -lC "C:\Users\student\Documents\ /
//                     GitHub\MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\ /
//                     EXP5438\ZAP Router\List\" -lA                          /
//                     "C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5 /
//                     .1\Projects\zstack\ZAP\TVSA\EXP5438\ZAP Router\List\"  /
//                     --remarks --diag_suppress Pe001,Pe193,Pe236,Pe826 -o   /
//                     "C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5 /
//                     .1\Projects\zstack\ZAP\TVSA\EXP5438\ZAP Router\Obj\"   /
//                     --debug -D__MSP430F5438A__ -e --double=32 --clib -I    /
//                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5. /
//                     1\Projects\zstack\ZAP\TVSA\EXP5438\ -I                 /
//                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5. /
//                     1\Projects\zstack\ZAP\TVSA\EXP5438\..\Source\ -I       /
//                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5. /
//                     1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\Source\ -I    /
//                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5. /
//                     1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Comp /
//                     onents\hal\target\MSP5438ZAP\ -I                       /
//                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5. /
//                     1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Comp /
//                     onents\hal\include\ -I C:\Users\student\Documents\GitH /
//                     ub\MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5 /
//                     438\..\..\..\..\..\Components\mac\include\ -I          /
//                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5. /
//                     1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Comp /
//                     onents\mt\ -I C:\Users\student\Documents\GitHub\MHMS\Z /
//                     AP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\..\.. /
//                     \..\..\..\Components\osal\include\ -I                  /
//                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5. /
//                     1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Comp /
//                     onents\osal\mcu\msp430\ -I                             /
//                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5. /
//                     1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Comp /
//                     onents\services\saddr\ -I C:\Users\student\Documents\G /
//                     itHub\MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\E /
//                     XP5438\..\..\..\..\..\Components\services\sdata\ -I    /
//                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5. /
//                     1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Comp /
//                     onents\stack\af\ -I C:\Users\student\Documents\GitHub\ /
//                     MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438 /
//                     \..\..\..\..\..\Components\stack\nwk\ -I               /
//                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5. /
//                     1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Comp /
//                     onents\stack\sapi\ -I C:\Users\student\Documents\GitHu /
//                     b\MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP54 /
//                     38\..\..\..\..\..\Components\stack\sec\ -I             /
//                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5. /
//                     1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Comp /
//                     onents\stack\sys\ -I C:\Users\student\Documents\GitHub /
//                     \MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP543 /
//                     8\..\..\..\..\..\Components\stack\zdo\ -I              /
//                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5. /
//                     1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Comp /
//                     onents\zmac\ -I C:\Users\student\Documents\GitHub\MHMS /
//                     \ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\..\ /
//                     ..\..\..\..\Components\zmac\f8w\ --core=430X           /
//                     --data_model=small -Ohz --multiplier=32                /
//                     --multiplier_location=4C0 --require_prototypes         /
//                     --hw_workaround=CPU40 --hw_workaround=CPU42            /
//    List file     =  C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5. /
//                     1\Projects\zstack\ZAP\TVSA\EXP5438\ZAP                 /
//                     Router\List\tvsa.s43                                   /
//                                                                            /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////

        NAME tvsa

        RTMODEL "__SystemLibrary", "CLib"
        RTMODEL "__core", "430X"
        RTMODEL "__data_model", "small"
        RTMODEL "__double_size", "32"
        RTMODEL "__pic", "no"
        RTMODEL "__reg_r4", "free"
        RTMODEL "__reg_r5", "free"
        RTMODEL "__rt_version", "3"

        RSEG CSTACK:DATA:SORT:NOROOT(0)

        EXTERN ?CopyMemoryBytes
        EXTERN ?DivMod16u
        EXTERN ?cstart_init_copy
        EXTERN ?cstart_init_zero
        EXTERN ?longjmp_r4
        EXTERN ?longjmp_r5
        EXTERN ?setjmp_r4
        EXTERN ?setjmp_r5

        PUBWEAK ?setjmp_save_r4
        PUBWEAK ?setjmp_save_r5
        PUBLIC BPM
        PUBLIC IBI
        PUBLIC P
        PUBLIC Pulse
        PUBLIC QS
        PUBLIC Signal
        PUBLIC T
        PUBWEAK _A_PCDIR_L
        PUBWEAK _A_PCOUT_L
        PUBWEAK _A_REFCTL0_L
        PUBLIC amp
        FUNCTION calcFCS,0203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC firstBeat
        PUBLIC lastBeatTime
        PUBLIC pulseAppEvt
        FUNCTION pulseAppEvt,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 8, STACK
        PUBLIC pulseAppInit
        FUNCTION pulseAppInit,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 40, STACK
        PUBLIC pulseTaskId
        PUBLIC rate
        PUBLIC sampleCounter
        PUBLIC secondBeat
        FUNCTION sysPingRsp,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 12, STACK
        PUBLIC thresh
        FUNCTION tvsaAnnce,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 28, STACK
        PUBLIC tvsaCnfErrCnt
        FUNCTION tvsaDataRx,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 34, STACK
        FUNCTION tvsaSysEvtMsg,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 6, STACK
        PUBLIC tvsaTaskId
        FUNCTION tvsaUartRx,021603H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 10, STACK
        FUNCTION tvsaZdoStateChange,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        
          CFI Names cfiNames0
          CFI StackFrame CFA SP DATA
          CFI Resource PC:20, SP:20, SR:16, R4L:16, R4H:4, R4:20, R5L:16, R5H:4
          CFI Resource R5:20, R6L:16, R6H:4, R6:20, R7L:16, R7H:4, R7:20, R8L:16
          CFI Resource R8H:4, R8:20, R9L:16, R9H:4, R9:20, R10L:16, R10H:4
          CFI Resource R10:20, R11L:16, R11H:4, R11:20, R12L:16, R12H:4, R12:20
          CFI Resource R13L:16, R13H:4, R13:20, R14L:16, R14H:4, R14:20, R15L:16
          CFI Resource R15H:4, R15:20
          CFI ResourceParts R4 R4H, R4L
          CFI ResourceParts R5 R5H, R5L
          CFI ResourceParts R6 R6H, R6L
          CFI ResourceParts R7 R7H, R7L
          CFI ResourceParts R8 R8H, R8L
          CFI ResourceParts R9 R9H, R9L
          CFI ResourceParts R10 R10H, R10L
          CFI ResourceParts R11 R11H, R11L
          CFI ResourceParts R12 R12H, R12L
          CFI ResourceParts R13 R13H, R13L
          CFI ResourceParts R14 R14H, R14L
          CFI ResourceParts R15 R15H, R15L
          CFI EndNames cfiNames0
        
          CFI Common cfiCommon0 Using cfiNames0
          CFI CodeAlign 2
          CFI DataAlign 2
          CFI ReturnAddress PC CODE
          CFI CFA SP+4
          CFI PC Frame(CFA, -4)
          CFI SR Undefined
          CFI R4L SameValue
          CFI R4H 0
          CFI R4 Concat
          CFI R5L SameValue
          CFI R5H 0
          CFI R5 Concat
          CFI R6L SameValue
          CFI R6H 0
          CFI R6 Concat
          CFI R7L SameValue
          CFI R7H 0
          CFI R7 Concat
          CFI R8L SameValue
          CFI R8H 0
          CFI R8 Concat
          CFI R9L SameValue
          CFI R9H 0
          CFI R9 Concat
          CFI R10L SameValue
          CFI R10H 0
          CFI R10 Concat
          CFI R11L SameValue
          CFI R11H 0
          CFI R11 Concat
          CFI R12L Undefined
          CFI R12H Undefined
          CFI R12 Undefined
          CFI R13L Undefined
          CFI R13H Undefined
          CFI R13 Undefined
          CFI R14L Undefined
          CFI R14H Undefined
          CFI R14 Undefined
          CFI R15L Undefined
          CFI R15H Undefined
          CFI R15 Undefined
          CFI EndCommon cfiCommon0
        
        
          CFI Common cfiCommon1 Using cfiNames0
          CFI CodeAlign 2
          CFI DataAlign 2
          CFI ReturnAddress PC CODE
          CFI CFA SP+4
          CFI PC Frame(CFA, -4)
          CFI SR Undefined
          CFI R4L SameValue
          CFI R4H 0
          CFI R4 Concat
          CFI R5L SameValue
          CFI R5H 0
          CFI R5 Concat
          CFI R6L SameValue
          CFI R6H 0
          CFI R6 Concat
          CFI R7L SameValue
          CFI R7H 0
          CFI R7 Concat
          CFI R8L SameValue
          CFI R8H 0
          CFI R8 Concat
          CFI R9L SameValue
          CFI R9H 0
          CFI R9 Concat
          CFI R10L SameValue
          CFI R10H 0
          CFI R10 Concat
          CFI R11L SameValue
          CFI R11H 0
          CFI R11 Concat
          CFI R12L SameValue
          CFI R12H 0
          CFI R12 Concat
          CFI R13L SameValue
          CFI R13H 0
          CFI R13 Concat
          CFI R14L SameValue
          CFI R14H 0
          CFI R14 Concat
          CFI R15L SameValue
          CFI R15H 0
          CFI R15 Concat
          CFI EndCommon cfiCommon1
        
        EXTERN osal_start_timerEx
        FUNCTION osal_start_timerEx,0202H
        EXTERN osal_set_event
        FUNCTION osal_set_event,0202H
        EXTERN AF_DataRequest
        FUNCTION AF_DataRequest,0202H
        EXTERN osal_stop_timerEx
        FUNCTION osal_stop_timerEx,0202H
        EXTERN devState
        EXTERN osal_msg_deallocate
        FUNCTION osal_msg_deallocate,0202H
        EXTERN osal_msg_receive
        FUNCTION osal_msg_receive,0202H
        EXTERN HalUARTOpen
        FUNCTION HalUARTOpen,0202H
        EXTERN afRegister
        FUNCTION afRegister,0202H
        EXTERN HalUARTWrite
        FUNCTION HalUARTWrite,0202H
        EXTERN HalUARTRead
        FUNCTION HalUARTRead,0202H
        EXTERN osal_memcpy
        FUNCTION osal_memcpy,0202H

// C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\Source\tvsa.c
//    1 /**************************************************************************************************
//    2     Filename:       tvsa.c
//    3     Revised:        $Date: 2011-07-25 20:23:05 -0700 (Mon, 25 Jul 2011) $
//    4     Revision:       $Revision: 26899 $
//    5 
//    6     Description:
//    7 
//    8     This file implements the Temperature/Voltage Sample Application.
//    9 
//   10 
//   11 
//   12 
//   13     Copyright 2009 Texas Instruments Incorporated. All rights reserved.
//   14 
//   15     IMPORTANT: Your use of this Software is limited to those specific rights
//   16     granted under the terms of a software license agreement between the user
//   17     who downloaded the software, his/her employer (which must be your employer)
//   18     and Texas Instruments Incorporated (the "License").  You may not use this
//   19     Software unless you agree to abide by the terms of the License. The License
//   20     limits your use, and you acknowledge, that the Software may not be modified,
//   21     copied or distributed unless embedded on a Texas Instruments microcontroller
//   22     or used solely and exclusively in conjunction with a Texas Instruments radio
//   23     frequency transceiver, which is integrated into your product.  Other than for
//   24     the foregoing purpose, you may not use, reproduce, copy, prepare derivative
//   25     works of, modify, distribute, perform, display or sell this Software and/or
//   26     its documentation for any purpose.
//   27 
//   28     YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
//   29     PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
//   30     INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
//   31     NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
//   32     TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
//   33     NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
//   34     LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
//   35     INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
//   36     OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
//   37     OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
//   38     (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
//   39 
//   40     Should you have any questions regarding your right to use this Software,
//   41     contact Texas Instruments Incorporated at www.TI.com.
//   42 **************************************************************************************************/
//   43 
//   44 /* ------------------------------------------------------------------------------------------------
//   45  *                                          Includes
//   46  * ------------------------------------------------------------------------------------------------
//   47  */
//   48 
//   49 #include "af.h"
//   50 #if defined LCD_SUPPORTED
//   51 #include "hal_lcd.h"

        ASEGN DATA16_AN:DATA:NOROOT,0242H
// union <unnamed> _A_PCOUT_L
_A_PCOUT_L:
        DS8 2

        ASEGN DATA16_AN:DATA:NOROOT,0244H
// union <unnamed> _A_PCDIR_L
_A_PCDIR_L:
        DS8 2

        ASEGN DATA16_AN:DATA:NOROOT,01b0H
// union <unnamed> _A_REFCTL0_L
_A_REFCTL0_L:
        DS8 2

        RSEG DATA16_C:CONST:SORT:NOROOT(0)
`?<Constant {83, 0, 0, 0, 10, 13}>`:
        DC8 83, 0, 0, 0, 10, 13, 0
//   52 #endif
//   53 #include "hal_uart.h"
//   54 #include "OnBoard.h"
//   55 #include "OSAL.h"
//   56 #include "tvsa.h"
//   57 #include "ZComDef.h"
//   58 #include "ZDApp.h"
//   59 #include "hal_led.h"  //MHMS for indicating if pulse is found
//   60 #include "hal_adc.h"  //MHMS used for capturing signal from pulse sensor
//   61 
//   62 /*#if !TVSA_DONGLE  //MHMS dont' need this
//   63 #include "tvsa_cc2530znp.c"
//   64 #endif
//   65 */
//   66 
//   67 /* ------------------------------------------------------------------------------------------------
//   68  *                                           Constants
//   69  * ------------------------------------------------------------------------------------------------
//   70  */
//   71 
//   72 
//   73 

        RSEG DATA16_C:CONST:SORT:NOROOT(1)
//   74 static const cId_t TVSA_ClusterList[TVSA_CLUSTER_CNT] =
TVSA_ClusterList:
        DC16 2
//   75 {
//   76   TVSA_CLUSTER_ID
//   77 };
//   78 

        RSEG DATA16_C:CONST:SORT:NOROOT(1)
//   79 static const SimpleDescriptionFormat_t TVSA_SimpleDesc =
TVSA_SimpleDesc:
        DC8 3, 0
        DC16 3856, 22
        DC8 0, 1
        DC16 TVSA_ClusterList
        DC8 1, 0
        DC16 TVSA_ClusterList
//   80 {
//   81   TVSA_ENDPOINT,
//   82   TVSA_PROFILE_ID,
//   83   TVSA_DEVICE_ID,
//   84   TVSA_DEVICE_VERSION,
//   85   TVSA_FLAGS,
//   86   TVSA_CLUSTER_CNT,
//   87   (cId_t *)TVSA_ClusterList,
//   88   TVSA_CLUSTER_CNT,
//   89   (cId_t *)TVSA_ClusterList
//   90 };
//   91 

        RSEG DATA16_C:CONST:SORT:NOROOT(1)
//   92 static const endPointDesc_t TVSA_epDesc=
TVSA_epDesc:
        DC8 3, 0
        DC16 tvsaTaskId, TVSA_SimpleDesc
        DC8 0, 0
//   93 {
//   94   TVSA_ENDPOINT,
//   95   &tvsaTaskId,
//   96   (SimpleDescriptionFormat_t *)&TVSA_SimpleDesc,
//   97   noLatencyReqs,
//   98 };
//   99 
//  100 // Constants for Pulse Sensor
//  101 

        RSEG DATA16_C:CONST:SORT:NOROOT(1)
//  102 static const cId_t PULSE_ClusterList[PULSE_CLUSTER_CNT] =
PULSE_ClusterList:
        DC16 2
//  103 {
//  104   PULSE_CLUSTER_ID
//  105 };
//  106 

        RSEG DATA16_C:CONST:SORT:NOROOT(1)
//  107 static const SimpleDescriptionFormat_t PULSE_SimpleDesc =
PULSE_SimpleDesc:
        DC8 3, 0
        DC16 3856, 6
        DC8 0, 1
        DC16 PULSE_ClusterList
        DC8 1, 0
        DC16 PULSE_ClusterList
//  108 {
//  109   PULSE_ENDPOINT,
//  110   PULSE_PROFILE_ID,
//  111   PULSE_DEVICE_ID,
//  112   PULSE_DEVICE_VERSION,
//  113   PULSE_FLAGS,
//  114   PULSE_CLUSTER_CNT,
//  115   (cId_t *)PULSE_ClusterList,
//  116   PULSE_CLUSTER_CNT,
//  117   (cId_t *)PULSE_ClusterList
//  118 };
//  119 

        RSEG DATA16_C:CONST:SORT:NOROOT(1)
//  120 static const endPointDesc_t PULSE_epDesc=
PULSE_epDesc:
        DC8 3, 0
        DC16 pulseTaskId, PULSE_SimpleDesc
        DC8 0, 0
//  121 {
//  122   PULSE_ENDPOINT,
//  123   &pulseTaskId,
//  124   (SimpleDescriptionFormat_t *)&PULSE_SimpleDesc,
//  125   noLatencyReqs,
//  126 };
//  127 /* ------------------------------------------------------------------------------------------------
//  128  *                                           Typedefs
//  129  * ------------------------------------------------------------------------------------------------
//  130  */
//  131 
//  132 /* ------------------------------------------------------------------------------------------------
//  133  *                                           Macros
//  134  * ------------------------------------------------------------------------------------------------
//  135  */
//  136 
//  137 /* ------------------------------------------------------------------------------------------------
//  138  *                                           Global Variables
//  139  * ------------------------------------------------------------------------------------------------
//  140  */
//  141 
//  142 #if TVSA_DATA_CNF

        RSEG DATA16_Z:DATA:SORT:NOROOT(0)
        REQUIRE ?cstart_init_zero
//  143 uint8 tvsaCnfErrCnt;
tvsaCnfErrCnt:
        DS8 1
//  144 #endif

        RSEG DATA16_Z:DATA:SORT:NOROOT(0)
        REQUIRE ?cstart_init_zero
//  145 uint8 tvsaTaskId;
tvsaTaskId:
        DS8 1
//  146 
//  147 //MHMS  Global Variables

        RSEG DATA16_Z:DATA:SORT:NOROOT(0)
        REQUIRE ?cstart_init_zero
//  148 uint8 pulseTaskId;
pulseTaskId:
        DS8 1
//  149 
//  150 
//  151 /* ------------------------------------------------------------------------------------------------
//  152  *                                           Local Variables
//  153  * ------------------------------------------------------------------------------------------------
//  154  */
//  155 
//  156 // Network address of the TVSA Dongle.

        RSEG DATA16_Z:DATA:SORT:NOROOT(1)
        REQUIRE ?cstart_init_zero
//  157 static uint16 tvsaAddr;
tvsaAddr:
        DS8 2

        RSEG DATA16_Z:DATA:SORT:NOROOT(1)
        REQUIRE ?cstart_init_zero
//  158 static uint16 pulseAddr;
pulseAddr:
        DS8 2
//  159 // Report counter.

        RSEG DATA16_Z:DATA:SORT:NOROOT(1)
        REQUIRE ?cstart_init_zero
//  160 static uint16 tvsaCnt;
tvsaCnt:
        DS8 2
//  161 // ZigBee-required packet transaction sequence number in calls to AF_DataRequest().

        RSEG DATA16_Z:DATA:SORT:NOROOT(0)
        REQUIRE ?cstart_init_zero
//  162 static uint8 tvsaTSN;
tvsaTSN:
        DS8 1
//  163 static uint8 pulseTSN;           //MHMS
//  164 
//  165 #if TVSA_DONGLE

        RSEG DATA16_Z:DATA:SORT:NOROOT(0)
        REQUIRE ?cstart_init_zero
//  166 static uint8 pulseBuf[PULSE_BUF_LEN];
pulseBuf:
        DS8 26
//  167 #if defined TVSA_DEMO
//  168 static uint8 tvsaCmd, tvsaState;
//  169 #endif
//  170 #else
//  171 static uint8 tvsaDat[TVSA_DAT_LEN];
//  172 static uint8 pulseDat[PULSE_DAT_LEN];  //MHMS define data array length for Pulse sensor
//  173 #endif
//  174 
//  175 //MHMS From arduino interrupt

        RSEG DATA16_Z:DATA:SORT:NOROOT(1)
        REQUIRE ?cstart_init_zero
//  176 volatile int rate[10];                    // used to hold last ten IBI values
rate:
        DS8 20

        RSEG DATA16_Z:DATA:SORT:NOROOT(1)
        REQUIRE ?cstart_init_zero
//  177 volatile uint32 sampleCounter = 0;          // used to determine pulse timing
sampleCounter:
        DS8 4

        RSEG DATA16_Z:DATA:SORT:NOROOT(1)
        REQUIRE ?cstart_init_zero
//  178 volatile uint32 lastBeatTime = 0;           // used to find the inter beat interval
lastBeatTime:
        DS8 4

        RSEG DATA16_I:DATA:SORT:NOROOT(1)
        REQUIRE ?cstart_init_copy
//  179 volatile int P = 512;                      // used to find peak in pulse wave
P:
        DS8 2
        REQUIRE `?<Initializer for P>`

        RSEG DATA16_I:DATA:SORT:NOROOT(1)
        REQUIRE ?cstart_init_copy
//  180 volatile int T = 512;                     // used to find trough in pulse wave
T:
        DS8 2
        REQUIRE `?<Initializer for T>`

        RSEG DATA16_I:DATA:SORT:NOROOT(1)
        REQUIRE ?cstart_init_copy
//  181 volatile int thresh = 512;                // used to find instant moment of heart beat
thresh:
        DS8 2
        REQUIRE `?<Initializer for thresh>`

        RSEG DATA16_I:DATA:SORT:NOROOT(1)
        REQUIRE ?cstart_init_copy
//  182 volatile int amp = 100;                   // used to hold amplitude of pulse waveform
amp:
        DS8 2
        REQUIRE `?<Initializer for amp>`

        RSEG DATA16_I:DATA:SORT:NOROOT(0)
        REQUIRE ?cstart_init_copy
//  183 volatile bool firstBeat = true;        // used to seed rate array so we startup with reasonable BPM
firstBeat:
        DS8 1
        REQUIRE `?<Initializer for firstBeat>`

        RSEG DATA16_I:DATA:SORT:NOROOT(0)
        REQUIRE ?cstart_init_copy
//  184 volatile bool secondBeat = true;       // used to seed rate array so we startup with reasonable BPM
secondBeat:
        DS8 1
        REQUIRE `?<Initializer for secondBeat>`
//  185 
//  186 // these variables are volatile because they are used during the interrupt service routine!
//  187 //MHMS From Arduino 1.1

        RSEG DATA16_Z:DATA:SORT:NOROOT(1)
        REQUIRE ?cstart_init_zero
//  188 volatile int BPM;                   // used to hold the pulse rate
BPM:
        DS8 2

        RSEG DATA16_Z:DATA:SORT:NOROOT(1)
        REQUIRE ?cstart_init_zero
//  189 volatile int Signal;                // holds the incoming raw data
Signal:
        DS8 2

        RSEG DATA16_I:DATA:SORT:NOROOT(1)
        REQUIRE ?cstart_init_copy
//  190 volatile int IBI = 600;             // holds the time between beats, the Inter-Beat Interval
IBI:
        DS8 2
        REQUIRE `?<Initializer for IBI>`

        RSEG DATA16_Z:DATA:SORT:NOROOT(0)
        REQUIRE ?cstart_init_zero
//  191 volatile bool Pulse = false;     // true when pulse wave is high, false when it's low
Pulse:
        DS8 1

        RSEG DATA16_Z:DATA:SORT:NOROOT(0)
        REQUIRE ?cstart_init_zero
//  192 volatile bool QS = false;        // becomes true when Arduoino finds a beat.  
QS:
        DS8 1
//  193 
//  194 
//  195 
//  196 /* ------------------------------------------------------------------------------------------------
//  197  *                                           Local Functions
//  198  * ------------------------------------------------------------------------------------------------
//  199  */
//  200 
//  201 static void tvsaAfMsgRx(afIncomingMSGPacket_t *msg);
//  202 static void tvsaSysEvtMsg(void);
//  203 
//  204 #if !TVSA_DONGLE
//  205 static void pulseBPM(uint8 *pulsedata);  //MHMS Pulse calculation function
//  206 static void pulseDataCalc(void);
//  207 static void pulseDataReq(void);
//  208 
//  209 static void tvsaZdoStateChange(void);
//  210 #else //if TVSA_DONGLE
//  211 static void tvsaAnnce(void);
//  212 static void tvsaDataRx(afIncomingMSGPacket_t *msg);
//  213 static void tvsaUartRx(uint8 port, uint8 event);
//  214 static void tvsaZdoStateChange(void);
//  215 #ifndef TVSA_DEMO
//  216 static uint8 calcFCS(uint8 *pBuf, uint8 len);
//  217 static void sysPingRsp(void);
//  218 #endif
//  219 
//  220 #endif
//  221 
//  222 
//  223 
//  224 /**************************************************************************************************
//  225  * @fn          tvsaAfMsgRx
//  226  *
//  227  * @brief       This function is called by tvsaSysEvtMsg() to process an incoming AF message.
//  228  *
//  229  * input parameters
//  230  *
//  231  * @param       msg - A pointer to the afIncomingMSGPacket_t packet.
//  232  *
//  233  * output parameters
//  234  *
//  235  * None.
//  236  *
//  237  * @return      None.
//  238  **************************************************************************************************
//  239  */
//  240 static void tvsaAfMsgRx(afIncomingMSGPacket_t *msg)
//  241 {
//  242   uint8 *buf = msg->cmd.Data;
//  243 
//  244   switch (buf[PULSE_CMD_IDX])
//  245   {
//  246 #if TVSA_DONGLE
//  247   case PULSE_CMD_DAT:
//  248     tvsaDataRx(msg);
//  249     break;
//  250 #else
//  251 
//  252   case PULSE_CMD_BEG:
//  253     if (INVALID_NODE_ADDR == pulseAddr)
//  254     {
//  255       NLME_SetPollRate(0);
//  256       (void)osal_set_event(pulseTaskId, PULSE_EVT_DAT);
//  257     }
//  258     pulseAddr = BUILD_UINT16(buf[TVSA_ADR_LSB], buf[TVSA_ADR_MSB]);
//  259     break;
//  260 
//  261   case PULSE_CMD_END:
//  262     NLME_SetPollRate(POLL_RATE);
//  263     pulseAddr = INVALID_NODE_ADDR;
//  264     break;
//  265 #endif
//  266 
//  267   default:
//  268     break;
//  269   }
//  270 }
//  271 
//  272 /**************************************************************************************************
//  273  * @fn          tvsaSysEvtMsg
//  274  *
//  275  * @brief       This function is called by tvsaAppEvt() to process all of the pending OSAL messages.
//  276  *
//  277  * input parameters
//  278  *
//  279  * None.
//  280  *
//  281  * output parameters
//  282  *
//  283  * None.
//  284  *
//  285  * @return      None.
//  286  **************************************************************************************************
//  287  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  288 static void tvsaSysEvtMsg(void)
tvsaSysEvtMsg:
          CFI Block cfiBlock0 Using cfiCommon0
          CFI Function tvsaSysEvtMsg
//  289 {
        FUNCALL tvsaSysEvtMsg, tvsaZdoStateChange
        LOCFRAME CSTACK, 6, STACK
        FUNCALL tvsaSysEvtMsg, osal_msg_deallocate
        LOCFRAME CSTACK, 6, STACK
        FUNCALL tvsaSysEvtMsg, osal_msg_receive
        LOCFRAME CSTACK, 6, STACK
        FUNCALL tvsaSysEvtMsg, tvsaDataRx
        LOCFRAME CSTACK, 6, STACK
        PUSH.W  R10
          CFI R10L Frame(CFA, -6)
          CFI CFA SP+6
        JMP     ??tvsaSysEvtMsg_3
//  290   uint8 *msg;
//  291 
//  292   while ((msg = osal_msg_receive(pulseTaskId)))
//  293   {
//  294     switch (*msg)
//  295     {
//  296 #if TVSA_DATA_CNF
//  297     case AF_DATA_CONFIRM_CMD:
//  298       if (ZSuccess != ((afDataConfirm_t *)msg)->hdr.status)
//  299       {
//  300         if (0 == ++tvsaCnfErrCnt)
//  301         {
//  302           tvsaCnfErrCnt = 255;
//  303         }
//  304       }
//  305       break;
//  306 #endif
//  307 
//  308     case AF_INCOMING_MSG_CMD:
//  309       tvsaAfMsgRx((afIncomingMSGPacket_t *)msg);
//  310       break;
//  311 
//  312     case ZDO_STATE_CHANGE:
//  313       tvsaZdoStateChange();
??tvsaSysEvtMsg_0:
        CALLA   #tvsaZdoStateChange
//  314       break;
//  315 
//  316     default:
//  317       break;
//  318     }
//  319 
//  320     (void)osal_msg_deallocate(msg);  // Receiving task is responsible for releasing the memory.
??tvsaSysEvtMsg_1:
        MOV.W   R10, R12
        CALLA   #osal_msg_deallocate
??tvsaSysEvtMsg_3:
        MOV.B   &pulseTaskId, R12
        CALLA   #osal_msg_receive
        MOV.W   R12, R10
        CMP.W   #0x0, R12
        JEQ     ??tvsaSysEvtMsg_4
        MOV.B   @R12, R14
        SUB.B   #0x1a, R14
        JEQ     ??tvsaSysEvtMsg_5
        SUB.B   #0xb7, R14
        JEQ     ??tvsaSysEvtMsg_0
        SUB.B   #0x2c, R14
        JNE     ??tvsaSysEvtMsg_1
        CMP.B   #0x0, 0x1(R12)
        JEQ     ??tvsaSysEvtMsg_1
        ADD.B   #0x1, &tvsaCnfErrCnt
        JNE     ??tvsaSysEvtMsg_1
        MOV.B   #0xff, &tvsaCnfErrCnt
        JMP     ??tvsaSysEvtMsg_1
??tvsaSysEvtMsg_5:
        MOV.W   0x24(R12), R15
        CMP.B   #0x0, 0(R15)
        JNE     ??tvsaSysEvtMsg_1
        CALLA   #tvsaDataRx
        JMP     ??tvsaSysEvtMsg_1
//  321   }
//  322 }
??tvsaSysEvtMsg_4:
        POP.W   R10
          CFI R10L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock0
//  323 
//  324 #if !TVSA_DONGLE
//  325 
//  326 /**************************************************************************************************
//  327  * @fn          tvsaZdoStateChange
//  328  *
//  329  * @brief       This function is called by tvsaSysEvtMsg() for a ZDO_STATE_CHANGE message.
//  330  *
//  331  * input parameters
//  332  *
//  333  * None.
//  334  *
//  335  * output parameters
//  336  *
//  337  * None.
//  338  *
//  339  * @return      None.
//  340  **************************************************************************************************
//  341  */
//  342 static void tvsaZdoStateChange(void)
//  343 {
//  344   (void)osal_stop_timerEx(pulseTaskId, PULSE_EVT_DAT);
//  345 
//  346   if ((DEV_ZB_COORD == devState) || (DEV_ROUTER == devState) || (DEV_END_DEVICE == devState))
//  347   {
//  348     uint16 tmp = NLME_GetCoordShortAddr();
//  349     uint8 dly = TVSA_STG_DAT;
//  350 
//  351     pulseDat[TVSA_PAR_LSB] = LO_UINT16(tmp);
//  352     pulseDat[TVSA_PAR_MSB] = HI_UINT16(tmp);
//  353     if ((DEV_ROUTER == devState) || (DEV_ZB_COORD == devState))
//  354     {
//  355       pulseDat[TVSA_TYP_IDX] |= 0x80;
//  356     }
//  357     else
//  358     {
//  359       pulseDat[TVSA_TYP_IDX] &= (0xFF ^ 0x80);
//  360     }
//  361 
//  362 #if TVSA_DONGLE_IS_ZC  //MHMS do we need this?
//  363     if (INVALID_NODE_ADDR == tvsaAddr)
//  364     {
//  365       // Assume ZC is the TVSA Dongle until a TVSA_CMD_BEG gives a different address.
//  366       pulseAddr = NWK_PAN_COORD_ADDR;
//  367     }
//  368 #endif
//  369 
//  370     if (INVALID_NODE_ADDR != tvsaAddr)
//  371     {
//  372       if (ZSuccess != osal_start_timerEx(pulseTaskId, PULSE_EVT_DAT, (dly + TVSA_DLY_MIN)))
//  373       {
//  374         (void)osal_set_event(pulseTaskId, PULSE_EVT_DAT);
//  375       }
//  376     }
//  377 
//  378 #if !TVSA_DONGLE
//  379     if (0 == 0)//voltageAtTemp22)
//  380     {
//  381      // HalInitTV();
//  382       (void)osal_cpyExtAddr(pulseDat+PULSE_IEE_IDX, &aExtendedAddress);
//  383     }
//  384 #endif
//  385   }
//  386 #if defined LCD_SUPPORTED
//  387   HalLcdWriteValue(devState, 10, HAL_LCD_LINE_5);
//  388 #endif
//  389 }
//  390 
//  391 #else // if TVSA_DONGLE
//  392 /**************************************************************************************************
//  393  * @fn          tvsaAnnce
//  394  *
//  395  * @brief       This function is called by tvsaAppEvt() to send a TVSA announce to start or stop.
//  396  *
//  397  * input parameters
//  398  *
//  399  * None.
//  400  *
//  401  * output parameters
//  402  *
//  403  * None.
//  404  *
//  405  * @return      None.
//  406  **************************************************************************************************
//  407  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  408 static void tvsaAnnce(void)
tvsaAnnce:
          CFI Block cfiBlock1 Using cfiCommon0
          CFI Function tvsaAnnce
//  409 {
        FUNCALL tvsaAnnce, osal_start_timerEx
        LOCFRAME CSTACK, 20, STACK
        FUNCALL tvsaAnnce, osal_set_event
        LOCFRAME CSTACK, 20, STACK
        FUNCALL tvsaAnnce, AF_DataRequest
        LOCFRAME CSTACK, 28, STACK
        FUNCALL tvsaAnnce, osal_set_event
        LOCFRAME CSTACK, 20, STACK
        SUB.W   #0x10, SP
          CFI CFA SP+20
//  410   uint8 msg[3];
//  411   afAddrType_t addr;
//  412   
//  413   addr.addr.shortAddr = NWK_BROADCAST_SHORTADDR_DEVALL;
        MOV.W   #0xffff, 0x4(SP)
//  414   addr.addrMode = afAddrBroadcast;
        MOV.B   #0xf, 0xc(SP)
//  415   addr.endPoint = TVSA_ENDPOINT;
        MOV.B   #0x3, 0xd(SP)
//  416 
//  417   if (INVALID_NODE_ADDR != tvsaAddr)
        CMP.W   #0xfffe, &tvsaAddr
        JEQ     ??tvsaAnnce_0
//  418   {
//  419     msg[TVSA_CMD_IDX] = TVSA_CMD_BEG;
        MOV.B   #0x1, 0(SP)
//  420     if (ZSuccess != osal_start_timerEx(pulseTaskId, TVSA_EVT_ANN, TVSA_DLY_ANN))
        CALLA   #?Subroutine1
??CrossCallReturnLabel_1:
        JEQ     ??tvsaAnnce_1
//  421     {
//  422       (void)osal_set_event(pulseTaskId, TVSA_EVT_ANN);
        CALLA   #?Subroutine0
//  423     }
//  424   }
??CrossCallReturnLabel_0:
        JMP     ??tvsaAnnce_1
//  425   else
//  426   {
//  427     msg[TVSA_CMD_IDX] = TVSA_CMD_END;
??tvsaAnnce_0:
        MOV.B   #0x2, 0(SP)
//  428   }
//  429 
//  430   msg[TVSA_ADR_LSB] = LO_UINT16(tvsaAddr);
??tvsaAnnce_1:
        MOV.B   &tvsaAddr, 0x1(SP)
//  431   msg[TVSA_ADR_MSB] = HI_UINT16(tvsaAddr);
        MOV.B   &tvsaAddr + 1, 0x2(SP)
//  432 
//  433   if (afStatus_SUCCESS != AF_DataRequest(&addr, (endPointDesc_t *)&TVSA_epDesc, TVSA_CLUSTER_ID,
//  434                                           3, msg, &tvsaTSN, AF_TX_OPTIONS_NONE, AF_DEFAULT_RADIUS))
        PUSH.B  #0x1e
          CFI CFA SP+22
        PUSH.B  #0x0
          CFI CFA SP+24
        PUSH.W  #tvsaTSN
          CFI CFA SP+26
        MOV.W   SP, R15
        ADD.W   #0x6, R15
        PUSH.W  R15
          CFI CFA SP+28
        MOV.W   #0x3, R15
        MOV.W   #0x2, R14
        MOV.W   #TVSA_epDesc, R13
        MOV.W   SP, R12
        ADD.W   #0xc, R12
        CALLA   #AF_DataRequest
        ADD.W   #0x8, SP
          CFI CFA SP+20
        CMP.B   #0x0, R12
        JEQ     ??tvsaAnnce_2
//  435   {
//  436     osal_set_event(tvsaTaskId, TVSA_EVT_REQ);
        MOV.W   #0x2000, R13
        MOV.B   &tvsaTaskId, R12
        CALLA   #osal_set_event
        JMP     ??tvsaAnnce_3
//  437   }
//  438   else
//  439   {
//  440     tvsaCnt++;
??tvsaAnnce_2:
        ADD.W   #0x1, &tvsaCnt
//  441   }
//  442 }
??tvsaAnnce_3:
        ADD.W   #0x10, SP
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock1

        RSEG CODE:CODE:REORDER:NOROOT(1)
?Subroutine1:
          CFI Block cfiCond2 Using cfiCommon0
          CFI Function tvsaAnnce
          CFI Conditional ??CrossCallReturnLabel_1
          CFI CFA SP+24
          CFI Block cfiCond3 Using cfiCommon0
          CFI (cfiCond3) Function tvsaZdoStateChange
          CFI (cfiCond3) Conditional ??CrossCallReturnLabel_2
          CFI (cfiCond3) CFA SP+8
          CFI Block cfiPicker4 Using cfiCommon1
          CFI (cfiPicker4) NoFunction
          CFI (cfiPicker4) Picker
        MOV.W   #0xea60, R14
        CALLA   #?Subroutine4
??CrossCallReturnLabel_9:
        CALLA   #osal_start_timerEx
        CMP.B   #0x0, R12
        RETA
          CFI EndBlock cfiCond2
          CFI EndBlock cfiCond3
          CFI EndBlock cfiPicker4

        RSEG CODE:CODE:REORDER:NOROOT(1)
?Subroutine4:
          CFI Block cfiCond5 Using cfiCommon0
          CFI Function tvsaZdoStateChange
          CFI Conditional ??CrossCallReturnLabel_7
          CFI CFA SP+8
          CFI Block cfiCond6 Using cfiCommon0
          CFI (cfiCond6) Function tvsaAnnce
          CFI (cfiCond6) Conditional ??CrossCallReturnLabel_9, ??CrossCallReturnLabel_1
          CFI (cfiCond6) CFA SP+28
          CFI Block cfiCond7 Using cfiCommon0
          CFI (cfiCond7) Function tvsaZdoStateChange
          CFI (cfiCond7) Conditional ??CrossCallReturnLabel_9, ??CrossCallReturnLabel_2
          CFI (cfiCond7) CFA SP+12
          CFI Block cfiCond8 Using cfiCommon0
          CFI (cfiCond8) Function tvsaAnnce
          CFI (cfiCond8) Conditional ??CrossCallReturnLabel_8, ??CrossCallReturnLabel_0
          CFI (cfiCond8) CFA SP+28
          CFI Block cfiCond9 Using cfiCommon0
          CFI (cfiCond9) Function tvsaZdoStateChange
          CFI (cfiCond9) Conditional ??CrossCallReturnLabel_8, ??tvsaZdoStateChange_1
          CFI (cfiCond9) CFA SP+12
          CFI Block cfiCond10 Using cfiCommon0
          CFI (cfiCond10) Function tvsaDataRx
          CFI (cfiCond10) Conditional ??CrossCallReturnLabel_8, ??tvsaDataRx_1
          CFI (cfiCond10) R8L Frame(CFA, -12)
          CFI (cfiCond10) R9L Frame(CFA, -10)
          CFI (cfiCond10) R10L Frame(CFA, -8)
          CFI (cfiCond10) R11L Frame(CFA, -6)
          CFI (cfiCond10) CFA SP+42
          CFI Block cfiPicker11 Using cfiCommon1
          CFI (cfiPicker11) NoFunction
          CFI (cfiPicker11) Picker
        MOV.W   #0x4000, R13
        MOV.B   &pulseTaskId, R12
        RETA
          CFI EndBlock cfiCond5
          CFI EndBlock cfiCond6
          CFI EndBlock cfiCond7
          CFI EndBlock cfiCond8
          CFI EndBlock cfiCond9
          CFI EndBlock cfiCond10
          CFI EndBlock cfiPicker11

        RSEG CODE:CODE:REORDER:NOROOT(1)
?Subroutine0:
          CFI Block cfiCond12 Using cfiCommon0
          CFI Function tvsaAnnce
          CFI Conditional ??CrossCallReturnLabel_0
          CFI CFA SP+24
          CFI Block cfiCond13 Using cfiCommon0
          CFI (cfiCond13) Function tvsaZdoStateChange
          CFI (cfiCond13) Conditional ??tvsaZdoStateChange_1
          CFI (cfiCond13) CFA SP+8
          CFI Block cfiCond14 Using cfiCommon0
          CFI (cfiCond14) Function tvsaDataRx
          CFI (cfiCond14) Conditional ??tvsaDataRx_1
          CFI (cfiCond14) R8L Frame(CFA, -12)
          CFI (cfiCond14) R9L Frame(CFA, -10)
          CFI (cfiCond14) R10L Frame(CFA, -8)
          CFI (cfiCond14) R11L Frame(CFA, -6)
          CFI (cfiCond14) CFA SP+38
          CFI Block cfiPicker15 Using cfiCommon1
          CFI (cfiPicker15) NoFunction
          CFI (cfiPicker15) Picker
        CALLA   #?Subroutine4
??CrossCallReturnLabel_8:
        BRA     #osal_set_event
          CFI EndBlock cfiCond12
          CFI EndBlock cfiCond13
          CFI EndBlock cfiCond14
          CFI EndBlock cfiPicker15
//  443 
//  444 /**************************************************************************************************
//  445  * @fn          tvsaDataRx
//  446  *
//  447  * @brief       This function is called by tvsaAfMsgRx() to process incoming TVSA data.
//  448  *
//  449  * input parameters
//  450  *
//  451  * @param       msg - A pointer to the afIncomingMSGPacket_t packet.
//  452  *
//  453  * output parameters
//  454  *
//  455  * None.
//  456  *
//  457  * @return      None.
//  458  **************************************************************************************************
//  459  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  460 static void tvsaDataRx(afIncomingMSGPacket_t *msg)
tvsaDataRx:
          CFI Block cfiBlock16 Using cfiCommon0
          CFI Function tvsaDataRx
//  461 {
        FUNCALL tvsaDataRx, osal_set_event
        LOCFRAME CSTACK, 34, STACK
        FUNCALL tvsaDataRx, osal_memcpy
        LOCFRAME CSTACK, 34, STACK
        FUNCALL tvsaDataRx, calcFCS
        LOCFRAME CSTACK, 34, STACK
        FUNCALL tvsaDataRx, HalUARTWrite
        LOCFRAME CSTACK, 34, STACK
        PUSHM.W #0x4, R11
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+12
        SUB.W   #0x16, SP
          CFI CFA SP+34
        MOV.W   R12, R11
//  462   uint8 fcs = 0, idx;
        MOV.B   #0x0, R8
//  463 
//  464   // Last announce broadcast to stop must have expired before a parent could forward to a ZED.
//  465   if (INVALID_NODE_ADDR == tvsaAddr)
        CMP.W   #0xfffe, &tvsaAddr
        JNE     ??tvsaDataRx_1
//  466   {
//  467     (void)osal_set_event(pulseTaskId, TVSA_EVT_ANN);
        CALLA   #?Subroutine0
//  468   }
//  469 
//  470   pulseBuf[PULSE_SOP_IDX] = PULSE_SOP_VAL;
??tvsaDataRx_1:
        MOV.B   #0xfe, &pulseBuf
//  471   pulseBuf[PULSE_ADR_LSB] = LO_UINT16(msg->srcAddr.addr.shortAddr);
        MOV.W   R11, R10
        ADD.W   #0x6, R10
        MOV.B   @R10, &pulseBuf + 1
//  472   pulseBuf[PULSE_ADR_MSB] = HI_UINT16(msg->srcAddr.addr.shortAddr);
        MOV.B   0x1(R10), &pulseBuf + 2
//  473 
//  474   // 1st byte of message is skipped - CMD is always 0 for data.
//  475   (void)osal_memcpy(pulseBuf+PULSE_DAT_OFF, msg->cmd.Data+1, PULSE_DAT_LEN-1);  //MHMS copies one buffer to another
        MOV.W   #0x16, R14
        MOV.W   0x24(R11), R13
        ADD.W   #0x1, R13
        MOV.W   #pulseBuf + 3, R12
        CALLA   #osal_memcpy
//  476 
//  477   for (idx = PULSE_ADR_LSB; idx < PULSE_FCS_IDX; idx++)
        MOV.B   #0x1, R15
//  478   {
//  479     fcs ^= pulseBuf[idx];
??tvsaDataRx_0:
        XOR.B   pulseBuf(R15), R8
//  480   }
        ADD.B   #0x1, R15
        CMP.B   #0x19, R15
        JNC     ??tvsaDataRx_0
//  481   pulseBuf[idx] = fcs;
        MOV.B   R8, pulseBuf(R15)
//  482   
//  483 #ifdef TVSA_DEMO
//  484 
//  485   HalUARTWrite(TVSA_PORT, pulseBuf, TVSA_BUF_LEN);
//  486 
//  487 #else
//  488   
//  489   
//  490   uint8 deviceBPM;
//  491   uint8 deviceVolt;
//  492   uint8 parentAddrLSB;
//  493   uint8 parentAddrMSB;
//  494   uint8 zsensorBuf[15];
//  495   
//  496   parentAddrLSB= pulseBuf[11];
        MOV.B   &pulseBuf + 11, R14
//  497   parentAddrMSB= pulseBuf[12];  
        MOV.B   &pulseBuf + 12, R15
//  498   deviceBPM = pulseBuf[14];
        MOV.B   &pulseBuf + 14, R13
//  499   deviceVolt = 0xFF;
//  500   
//  501   //Start of Frame Delimiter
//  502   zsensorBuf[0]=0xFE;
        MOV.B   #0xfe, 0x7(SP)
//  503   
//  504   
//  505   zsensorBuf[1]=10;
        MOV.B   #0xa, 0x8(SP)
//  506   zsensorBuf[2]=LO_UINT16(0x8746);
        MOV.B   #0x46, 0x9(SP)
//  507   zsensorBuf[3]=HI_UINT16(0x8746);
        MOV.B   #0x87, 0xa(SP)
//  508   
//  509   //Source Address
//  510   zsensorBuf[4] = LO_UINT16(msg->srcAddr.addr.shortAddr);
        MOV.B   @R10, 0xb(SP)
//  511   zsensorBuf[5] = HI_UINT16(msg->srcAddr.addr.shortAddr);
        MOV.B   0x1(R10), 0xc(SP)
//  512   
//  513   zsensorBuf[6]=LO_UINT16(2);
        MOV.B   #0x2, 0xd(SP)
//  514   zsensorBuf[7]=HI_UINT16(2);
        MOV.B   #0x0, 0xe(SP)
//  515   zsensorBuf[8]=LO_UINT16(4);
        MOV.B   #0x4, 0xf(SP)
//  516   zsensorBuf[9]=HI_UINT16(4);
        MOV.B   #0x0, 0x10(SP)
//  517   
//  518   //Temperature and Voltage Data
//  519   zsensorBuf[10]= deviceBPM;
        MOV.B   R13, 0x11(SP)
//  520   zsensorBuf[11]= deviceBPM; //deviceVolt;
        MOV.B   R13, 0x12(SP)
//  521   
//  522   //Parent Address
//  523   zsensorBuf[12]=parentAddrLSB;
        MOV.B   R14, 0x13(SP)
//  524   zsensorBuf[13]=parentAddrMSB;
        MOV.B   R15, 0x14(SP)
//  525 
//  526 
//  527   //FCS Check on the middle 13 bytes
//  528   zsensorBuf[14] = calcFCS(&zsensorBuf[1], 13 );
        MOV.B   #0xd, R13
        MOV.W   SP, R12
        ADD.W   #0x8, R12
        CALLA   #calcFCS
        MOV.B   R12, 0x15(SP)
//  529 
//  530 
//  531   //HalUARTWrite(TVSA_PORT, zsensorBuf, 15);
//  532   
//  533   //MHMS USB communication with Pulse sensor Processor application
//  534 
//  535   uint8 BPMBuf[7] = {'B',0,0,0,10,13};
//  536   uint8 IBIBuf[7] = {'Q',0,0,0,10,13};
//  537   uint8 SignalBuf[7] = {'S',0,0,0,10,13};
        MOV.W   SP, R12
        ADD.W   #0x0, R12
        MOV.W   #`?<Constant {83, 0, 0, 0, 10, 13}>`, R14
        MOV.W   #0x7, R13
        CALLA   #?CopyMemoryBytes
//  538   
//  539   //conversion Signal Dec to ASCII
//  540   uint16 temp = (BUILD_UINT16(pulseBuf[16], pulseBuf[17])) - 400;
        MOV.B   &pulseBuf + 16, R10
        MOV.B   &pulseBuf + 17, R15
        RPT     #0x8
        RLAX.W  R15
        ADD.W   R15, R10
        ADD.W   #0xfe70, R10
//  541   if(temp > 999){
        CMP.W   #0x3e8, R10
        JNC     ??tvsaDataRx_2
//  542     SignalBuf[1] = '9';
        MOV.B   #0x39, 0x1(SP)
//  543     SignalBuf[2] = '9';
        MOV.B   #0x39, 0x2(SP)
//  544     SignalBuf[3] = '9';
        MOV.B   #0x39, 0x3(SP)
        JMP     ??tvsaDataRx_3
//  545   }
??tvsaDataRx_2:
        CALLA   #?Subroutine2
??CrossCallReturnLabel_3:
        ADD.B   #0x30, R12
        MOV.B   R12, 0x1(SP)
//  546   else { 
//  547     SignalBuf[1] = (uint8)((temp/100)+ 48);
//  548     SignalBuf[2] = (uint8)((((temp%100) - (temp % 100)%10)/10) + 48);
        CALLA   #?Subroutine2
??CrossCallReturnLabel_4:
        MOV.W   R14, R11
        MOV.W   R14, R12
        MOV.W   #0xa, R14
        CALLA   #?DivMod16u
        MOV.B   R14, R10
        SUB.W   R14, R11
        MOV.W   R11, R12
        MOV.W   #0xa, R14
        CALLA   #?DivMod16u
        ADD.B   #0x30, R12
        MOV.B   R12, 0x2(SP)
//  549     SignalBuf[3] = (uint8)(((temp % 100)%10)+ 48);
        ADD.B   #0x30, R10
        MOV.B   R10, 0x3(SP)
//  550   }
//  551   
//  552   //conversion BPM Dec to ASCII
//  553   temp = (uint16)pulseBuf[14];
//  554   BPMBuf[1] = (uint8)((temp/100)+ 48);
//  555   BPMBuf[2] = (uint8)((((temp%100) - (temp % 100)%10)/10) + 48);
//  556   BPMBuf[3] = (uint8)(((temp % 100)%10)+ 48);
//  557   
//  558   //conversion IBI Dec to ASCII
//  559   temp = (uint16)pulseBuf[19];
//  560   IBIBuf[1] = (uint8)((temp/100)+ 48);
//  561   IBIBuf[2] = (uint8)((((temp%100) - (temp % 100)%10)/10) + 48);
//  562   IBIBuf[3] = (uint8)(((temp % 100)%10)+ 48);
//  563    
//  564   
//  565   HalUARTWrite(TVSA_PORT, SignalBuf, 6);
??tvsaDataRx_3:
        MOV.W   #0x6, R14
        CALLA   #?Subroutine3
//  566  // HalUARTWrite(TVSA_PORT, BPMBuf, 6);
//  567  // HalUARTWrite(TVSA_PORT, IBIBuf, 6);
//  568 
//  569   
//  570 
//  571 #endif  
//  572 //pulseAddr = BUILD_UINT16(buf[TVSA_ADR_LSB], buf[TVSA_ADR_MSB]);
//  573 }
??CrossCallReturnLabel_5:
        ADD.W   #0x16, SP
          CFI CFA SP+12
        POPM.W  #0x4, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock16

        RSEG CODE:CODE:REORDER:NOROOT(1)
?Subroutine3:
          CFI Block cfiCond17 Using cfiCommon0
          CFI Function sysPingRsp
          CFI Conditional ??CrossCallReturnLabel_6
          CFI CFA SP+16
          CFI Block cfiCond18 Using cfiCommon0
          CFI (cfiCond18) Function tvsaDataRx
          CFI (cfiCond18) Conditional ??CrossCallReturnLabel_5
          CFI (cfiCond18) R8L Frame(CFA, -12)
          CFI (cfiCond18) R9L Frame(CFA, -10)
          CFI (cfiCond18) R10L Frame(CFA, -8)
          CFI (cfiCond18) R11L Frame(CFA, -6)
          CFI (cfiCond18) CFA SP+38
          CFI Block cfiPicker19 Using cfiCommon1
          CFI (cfiPicker19) NoFunction
          CFI (cfiPicker19) Picker
        MOV.W   SP, R13
        ADD.W   #0x4, R13
        MOV.B   #0x0, R12
        BRA     #HalUARTWrite
          CFI EndBlock cfiCond17
          CFI EndBlock cfiCond18
          CFI EndBlock cfiPicker19

        RSEG CODE:CODE:REORDER:NOROOT(1)
?Subroutine2:
          CFI Block cfiCond20 Using cfiCommon0
          CFI Function tvsaDataRx
          CFI Conditional ??CrossCallReturnLabel_3
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+38
          CFI Block cfiCond21 Using cfiCommon0
          CFI (cfiCond21) Function tvsaDataRx
          CFI (cfiCond21) Conditional ??CrossCallReturnLabel_4
          CFI (cfiCond21) R8L Frame(CFA, -12)
          CFI (cfiCond21) R9L Frame(CFA, -10)
          CFI (cfiCond21) R10L Frame(CFA, -8)
          CFI (cfiCond21) R11L Frame(CFA, -6)
          CFI (cfiCond21) CFA SP+38
          CFI Block cfiPicker22 Using cfiCommon1
          CFI (cfiPicker22) NoFunction
          CFI (cfiPicker22) Picker
        MOV.W   R10, R12
        MOV.W   #0x64, R14
        BRA     #?DivMod16u
          CFI EndBlock cfiCond20
          CFI EndBlock cfiCond21
          CFI EndBlock cfiPicker22
//  574 
//  575 /**************************************************************************************************
//  576  * @fn          tvsaUartRx
//  577  *
//  578  * @brief       This function is the Uart callback for Rx data.
//  579  *
//  580  * input parameters
//  581  *
//  582  * @param       port - Don't care.
//  583  * @param       event - Don't care.
//  584  *
//  585  * output parameters
//  586  *
//  587  * None.
//  588  *
//  589  * @return      None.
//  590  **************************************************************************************************
//  591  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  592 static void tvsaUartRx(uint8 port, uint8 event)
tvsaUartRx:
          CFI Block cfiBlock23 Using cfiCommon0
          CFI Function tvsaUartRx
//  593 {
        FUNCALL tvsaUartRx, HalUARTRead
        LOCFRAME CSTACK, 10, STACK
        FUNCALL tvsaUartRx, sysPingRsp
        LOCFRAME CSTACK, 10, STACK
        SUB.W   #0x6, SP
          CFI CFA SP+10
//  594 #ifdef TVSA_DEMO
//  595   uint8 ch;
//  596 
//  597   while (HalUARTRead(TVSA_PORT, &ch, 1))
//  598   {
//  599     switch (tvsaState)
//  600     {
//  601     case SOP_STATE:
//  602       if (TVSA_SOP_VAL == ch)
//  603       {
//  604         tvsaState = CMD_STATE;
//  605       }
//  606       break;
//  607 
//  608     case CMD_STATE:
//  609       tvsaCmd = ch;
//  610       tvsaState = FCS_STATE;
//  611       break;
//  612 
//  613     case FCS_STATE:
//  614       if (tvsaCmd == ch)
//  615       {
//  616         if (tvsaCmd == TVSA_CMD_BEG)
//  617         {
//  618           tvsaAddr = NLME_GetShortAddr();
//  619         }
//  620         else if (tvsaCmd == TVSA_CMD_END)
//  621         {
//  622           tvsaAddr = INVALID_NODE_ADDR;
//  623         }
//  624         (void)osal_set_event(pulseTaskId, TVSA_EVT_ANN);
//  625       }
//  626 
//  627       tvsaState = SOP_STATE;
//  628       break;
//  629 
//  630     default:
//  631      break;
//  632     }
//  633   }
//  634 #else
//  635   uint8 ch[5];
//  636   
//  637   HalUARTRead(TVSA_PORT, ch, 5);
        MOV.W   #0x5, R14
        MOV.W   SP, R13
        ADD.W   #0x0, R13
        MOV.B   #0x0, R12
        CALLA   #HalUARTRead
//  638   if (ch[2]==0x21)   //if statement to check for command from Z-Sensor Monitor
        CMP.B   #0x21, 0x2(SP)
        JNE     ??tvsaUartRx_0
//  639   {
//  640     sysPingRsp();
        CALLA   #sysPingRsp
//  641   }
//  642 #endif
//  643 }
??tvsaUartRx_0:
        ADD.W   #0x6, SP
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock23
//  644 
//  645 /**************************************************************************************************
//  646  * @fn          tvsaZdoStateChange
//  647  *
//  648  * @brief       This function is called by tvsaSysEvtMsg() for a ZDO_STATE_CHANGE message.
//  649  *
//  650  * input parameters
//  651  *
//  652  * None.
//  653  *
//  654  * output parameters
//  655  *
//  656  * None.
//  657  *
//  658  * @return      None.
//  659  **************************************************************************************************
//  660  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  661 static void tvsaZdoStateChange(void)
tvsaZdoStateChange:
          CFI Block cfiBlock24 Using cfiCommon0
          CFI Function tvsaZdoStateChange
//  662 {
//  663   (void)osal_stop_timerEx(pulseTaskId, TVSA_EVT_ANN);
        FUNCALL tvsaZdoStateChange, osal_stop_timerEx
        LOCFRAME CSTACK, 4, STACK
        FUNCALL tvsaZdoStateChange, osal_start_timerEx
        LOCFRAME CSTACK, 4, STACK
        FUNCALL tvsaZdoStateChange, osal_set_event
        LOCFRAME CSTACK, 4, STACK
        CALLA   #?Subroutine4
??CrossCallReturnLabel_7:
        CALLA   #osal_stop_timerEx
//  664 
//  665   if ((DEV_ZB_COORD == devState) || (DEV_ROUTER == devState) || (DEV_END_DEVICE == devState))
        MOV.B   &devState, R14
        CMP.B   #0x9, R14
        JEQ     ??tvsaZdoStateChange_0
        CMP.B   #0x7, R14
        JEQ     ??tvsaZdoStateChange_0
        CMP.B   #0x6, R14
        JNE     ??tvsaZdoStateChange_1
//  666   {
//  667 #if TVSA_DONGLE_IS_ZC
//  668     if (INVALID_NODE_ADDR == tvsaAddr)
??tvsaZdoStateChange_0:
        CMP.W   #0xfffe, &tvsaAddr
        JNE     ??tvsaZdoStateChange_2
//  669     {
//  670       // Assume ZC is the TVSA Dongle until a TVSA_CMD_BEG gives a different address.
//  671       tvsaAddr = NWK_PAN_COORD_ADDR;
        MOV.W   #0x0, &tvsaAddr
//  672     }
//  673 #endif
//  674 
//  675     if (INVALID_NODE_ADDR != tvsaAddr)
//  676     {
//  677       if (ZSuccess != osal_start_timerEx(pulseTaskId, TVSA_EVT_ANN, TVSA_DLY_ANN))
??tvsaZdoStateChange_2:
        CALLA   #?Subroutine1
??CrossCallReturnLabel_2:
        JEQ     ??tvsaZdoStateChange_1
//  678       {
//  679         (void)osal_set_event(pulseTaskId, TVSA_EVT_ANN);
        CALLA   #?Subroutine0
//  680       }
//  681     }
//  682   }
//  683 }
??tvsaZdoStateChange_1:
        RETA
          CFI EndBlock cfiBlock24
//  684 
//  685 #ifndef TVSA_DEMO
//  686 /******************************************************************************
//  687  * @fn          calcFCS
//  688  *
//  689  * @brief       This function calculates the FCS checksum for the serial message 
//  690  *
//  691  * @param       pBuf - Pointer to the end of a buffer to calculate the FCS.
//  692  *              len - Length of the pBuf.
//  693  *
//  694  * @return      The calculated FCS.
//  695  ******************************************************************************
//  696  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  697 static uint8 calcFCS(uint8 *pBuf, uint8 len)
calcFCS:
          CFI Block cfiBlock25 Using cfiCommon0
          CFI Function calcFCS
//  698 {
//  699   uint8 rtrn = 0;
        MOV.B   #0x0, R15
        JMP     ??calcFCS_1
//  700 
//  701   while (len--)
//  702   {
//  703     rtrn ^= *pBuf++;
??calcFCS_0:
        XOR.B   @R12+, R15
//  704   }
??calcFCS_1:
        MOV.B   R13, R14
        ADD.B   #0xff, R13
        CMP.B   #0x0, R14
        JNE     ??calcFCS_0
//  705 
//  706   return rtrn;
        MOV.B   R15, R12
        RETA
          CFI EndBlock cfiBlock25
//  707 }
//  708 
//  709 /*************************************************************************************************
//  710  * @fn          sysPingRsp
//  711  *
//  712  * @brief       Build and send Ping response
//  713  *
//  714  * @param       none
//  715  *              
//  716  * @return      none
//  717 **************************************************************************************************
//  718  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  719 static void sysPingRsp(void)
sysPingRsp:
          CFI Block cfiBlock26 Using cfiCommon0
          CFI Function sysPingRsp
//  720 {
        FUNCALL sysPingRsp, calcFCS
        LOCFRAME CSTACK, 12, STACK
        FUNCALL sysPingRsp, HalUARTWrite
        LOCFRAME CSTACK, 12, STACK
        SUB.W   #0x8, SP
          CFI CFA SP+12
//  721   uint8 pingBuff[7];
//  722   
//  723   // Start of Frame Delimiter
//  724   pingBuff[0] = 0xFE;
        MOV.B   #0xfe, 0(SP)
//  725   
//  726   // Length
//  727   pingBuff[1] = 0x02; 
        MOV.B   #0x2, 0x1(SP)
//  728   
//  729   // Command type
//  730   pingBuff[2] = LO_UINT16(0x0161); 
        MOV.B   #0x61, 0x2(SP)
//  731   pingBuff[3] = HI_UINT16(0x0161);
        MOV.B   #0x1, 0x3(SP)
//  732   
//  733   // Stack profile
//  734   pingBuff[4] = LO_UINT16(0x0041);
        MOV.B   #0x41, 0x4(SP)
//  735   pingBuff[5] = HI_UINT16(0x0041);
        MOV.B   #0x0, 0x5(SP)
//  736   
//  737   // Frame Check Sequence
//  738   pingBuff[6] = calcFCS(&pingBuff[1], 5);
        MOV.B   #0x5, R13
        MOV.W   SP, R12
        ADD.W   #0x1, R12
        CALLA   #calcFCS
        MOV.B   R12, 0x6(SP)
//  739   
//  740   
//  741   HalUARTWrite(TVSA_PORT,pingBuff, 7);
        MOV.W   #0x7, R14
        CALLA   #?Subroutine3
//  742 
//  743 }
??CrossCallReturnLabel_6:
        ADD.W   #0x8, SP
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock26
//  744 
//  745 
//  746 #endif
//  747 
//  748 
//  749 
//  750 
//  751 
//  752 #endif
//  753 
//  754 /**************************************************************************************************
//  755 */
//  756 
//  757 
//  758 
//  759 /*  //MHMS Pulse Sensor Functions */ 
//  760 
//  761 /**************************************************************************************************
//  762  * @fn          pulseAppInit
//  763  *
//  764  * @brief       This function is the application's task initialization.
//  765  *
//  766  * input parameters
//  767  *
//  768  * None.
//  769  *
//  770  * output parameters
//  771  *
//  772  * None.
//  773  *
//  774  * @return      None.
//  775  **************************************************************************************************
//  776  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  777 void pulseAppInit(uint8 id)
pulseAppInit:
          CFI Block cfiBlock27 Using cfiCommon0
          CFI Function pulseAppInit
//  778 {
        FUNCALL pulseAppInit, HalUARTOpen
        LOCFRAME CSTACK, 40, STACK
        FUNCALL pulseAppInit, afRegister
        LOCFRAME CSTACK, 40, STACK
        PUSH.W  R10
          CFI R10L Frame(CFA, -6)
          CFI CFA SP+6
        SUB.W   #0x22, SP
          CFI CFA SP+40
        MOV.B   R12, R10
//  779 #if TVSA_DONGLE
//  780   halUARTCfg_t uartConfig;
//  781 
//  782   uartConfig.configured           = TRUE;              // 2x30 don't care - see uart driver.
        MOV.B   #0x1, 0(SP)
//  783   
//  784 #ifdef TVSA_DEMO
//  785   uartConfig.baudRate             = HAL_UART_BR_115200;
//  786 #else
//  787   //uartConfig.baudRate             = HAL_UART_BR_38400;        //MHMS This baud rate is required to communicate with Zigbee Sensor Monitor
//  788   uartConfig.baudRate             = HAL_UART_BR_115200;         //MHMS This baud rate is required to communicate with the Pulse processing program on PC
        MOV.B   #0x4, 0x1(SP)
//  789 #endif
//  790   
//  791   uartConfig.flowControl          = FALSE;
        MOV.B   #0x0, 0x2(SP)
//  792   uartConfig.flowControlThreshold = 16;                // 2x30 don't care - see uart driver.
        MOV.W   #0x10, 0x4(SP)
//  793   uartConfig.rx.maxBufSize        = 32;                // 2x30 don't care - see uart driver.
        MOV.W   #0x20, 0xc(SP)
//  794   uartConfig.tx.maxBufSize        = 254;               // 2x30 don't care - see uart driver.
        MOV.W   #0xfe, 0x14(SP)
//  795   uartConfig.idleTimeout          = 6;                 // 2x30 don't care - see uart driver.
        MOV.B   #0x6, 0x6(SP)
//  796   uartConfig.intEnable            = TRUE;              // 2x30 don't care - see uart driver.
        MOV.B   #0x1, 0x18(SP)
//  797   uartConfig.callBackFunc         = tvsaUartRx;
        MOV.W   #LWRD(tvsaUartRx), 0x1e(SP)
        MOV.W   #HWRD(tvsaUartRx), 0x20(SP)
//  798   HalUARTOpen(TVSA_PORT, &uartConfig);
        MOV.W   SP, R13
        ADD.W   #0x0, R13
        MOV.B   #0x0, R12
        CALLA   #HalUARTOpen
//  799 #else
//  800 //  tvsaDat[TVSA_TYP_IDX] = (uint8)TVSA_DEVICE_ID;
//  801     pulseDat[PULSE_TYP_IDX] = (uint8)PULSE_DEVICE_ID;
//  802 #if defined PULSE_SRC_RTG
//  803 //  tvsaDat[TVSA_OPT_IDX] = TVSA_OPT_SRC_RTG;
//  804     pulseDat[PULSE_OPT_IDX] = PULSE_OPT_SRC_RTG;
//  805 #endif
//  806 #endif
//  807 
//  808   pulseTaskId = id;                                    
        MOV.B   R10, &pulseTaskId
//  809   pulseAddr = INVALID_NODE_ADDR;
        MOV.W   #0xfffe, &pulseAddr
//  810   (void)afRegister((endPointDesc_t *)&PULSE_epDesc);  //MHMS registers endpoint object
        MOV.W   #PULSE_epDesc, R12
        CALLA   #afRegister
//  811   
//  812   //Initialize Px.y (5.0) to power Pulse sensor
//  813   P5DIR = 0x1;  //Set IO direction as output
        MOV.B   #0x1, &0x244
//  814   P5OUT = 0x1;  //Set output to high
        MOV.B   #0x1, &0x242
//  815  
//  816   //Setup ADC reference 
//  817   REFCTL0 = REFVSEL_2;  /* REF Reference Voltage Level Select 2.5V */
        MOV.W   #0x20, &0x1b0
//  818 }
        ADD.W   #0x22, SP
          CFI CFA SP+6
        POP.W   R10
          CFI R10L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock27
        REQUIRE _A_PCDIR_L
        REQUIRE _A_PCOUT_L
        REQUIRE _A_REFCTL0_L
//  819 
//  820 /**************************************************************************************************
//  821  * @fn          pulseAppEvt
//  822  *
//  823  * @brief       This function is called to process the OSAL events for the task.
//  824  *
//  825  * input parameters
//  826  *
//  827  * @param       id - OSAL task Id.
//  828  * @param       evts - OSAL events bit mask of pending events.
//  829  *
//  830  * output parameters
//  831  *
//  832  * None.
//  833  *
//  834  * @return      evts - OSAL events bit mask of unprocessed events.
//  835  **************************************************************************************************
//  836  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  837 uint16 pulseAppEvt(uint8 id, uint16 evts)
pulseAppEvt:
          CFI Block cfiBlock28 Using cfiCommon0
          CFI Function pulseAppEvt
//  838 {
        FUNCALL pulseAppEvt, tvsaSysEvtMsg
        LOCFRAME CSTACK, 8, STACK
        FUNCALL pulseAppEvt, tvsaAnnce
        LOCFRAME CSTACK, 8, STACK
        PUSHM.W #0x2, R11
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+8
        MOV.W   R13, R10
//  839   uint16 mask = 0;
//  840   (void)id;  //MHMS casts a void to ignore warning for not using variable
//  841   
//  842   if (evts & SYS_EVENT_MSG)
        CMP.W   #0x0, R13
        JGE     ??pulseAppEvt_0
//  843   {
//  844     mask = SYS_EVENT_MSG;
        MOV.W   #0x8000, R11
//  845     tvsaSysEvtMsg();
        CALLA   #tvsaSysEvtMsg
        JMP     ??pulseAppEvt_1
//  846   }
//  847 #if TVSA_DONGLE
//  848   else if (evts & TVSA_EVT_ANN)
??pulseAppEvt_0:
        BIT.W   #0x4000, R13
        JNC     ??pulseAppEvt_2
//  849   {
//  850     mask = TVSA_EVT_ANN;
        MOV.W   #0x4000, R11
//  851    tvsaAnnce();
        CALLA   #tvsaAnnce
        JMP     ??pulseAppEvt_1
//  852   }
//  853 #else
//  854   else if (evts & PULSE_EVT_DAT)
//  855   {
//  856     mask = PULSE_EVT_DAT;
//  857     pulseDataCalc();
//  858   }
//  859   else if (evts & PULSE_EVT_REQ)
//  860   {
//  861     mask = PULSE_EVT_REQ;
//  862     pulseDataReq();
//  863   }
//  864 #endif
//  865   else
//  866   {
//  867     mask = evts;  // Discard unknown events - should never happen.
??pulseAppEvt_2:
        MOV.W   R13, R11
//  868   }
//  869 
//  870   return (evts ^ mask);  // Return unprocessed events.
??pulseAppEvt_1:
        XOR.W   R11, R10
        MOV.W   R10, R12
        POPM.W  #0x2, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock28
//  871 }

        RSEG DATA16_ID:CONST:SORT:NOROOT(1)
`?<Initializer for P>`:
        DC16 512

        RSEG DATA16_ID:CONST:SORT:NOROOT(1)
`?<Initializer for T>`:
        DC16 512

        RSEG DATA16_ID:CONST:SORT:NOROOT(1)
`?<Initializer for thresh>`:
        DC16 512

        RSEG DATA16_ID:CONST:SORT:NOROOT(1)
`?<Initializer for amp>`:
        DC16 100

        RSEG DATA16_ID:CONST:SORT:NOROOT(0)
`?<Initializer for firstBeat>`:
        DC8 1

        RSEG DATA16_ID:CONST:SORT:NOROOT(0)
`?<Initializer for secondBeat>`:
        DC8 1

        RSEG DATA16_ID:CONST:SORT:NOROOT(1)
`?<Initializer for IBI>`:
        DC16 600

        RSEG CODE:CODE:REORDER:NOROOT(1)
?setjmp_save_r4:
        REQUIRE ?setjmp_r4
        REQUIRE ?longjmp_r4

        RSEG CODE:CODE:REORDER:NOROOT(1)
?setjmp_save_r5:
        REQUIRE ?setjmp_r5
        REQUIRE ?longjmp_r5

        END
//  872 
//  873 
//  874 //MHMS put coord stuff here, recieve func and sys
//  875 
//  876 
//  877 #if !TVSA_DONGLE  //Group 1
//  878 /**************************************************************************************************
//  879  * @fn          pulseDataCalc
//  880  *
//  881  * @brief       This function is called by tvsaAppEvt() to calculate the data for a PULSE report.
//  882  *              The function will called on a 2ms interval and detect whether a pulse is being measured.
//  883  *              If a pulse is determined it will invoke the PulsedataReq interrupt timer (20ms intervals)
//  884  *
//  885  * input parameters
//  886  *
//  887  * None.
//  888  *
//  889  * output parameters
//  890  *
//  891  * None.
//  892  *
//  893  * @return      None.
//  894  **************************************************************************************************
//  895  */
//  896 static void pulseDataCalc(void)
//  897 {
//  898   if (INVALID_NODE_ADDR == pulseAddr)
//  899   {
//  900     return;
//  901   }
//  902 
//  903   if (ZSuccess != osal_start_timerEx(pulseTaskId, PULSE_EVT_DAT, PULSE_DLY_DAT))  //If the timer can't be started set event flag again for it to be service again
//  904   {
//  905     (void)osal_set_event(pulseTaskId, PULSE_EVT_DAT);
//  906   }
//  907   pulseBPM(pulseDat);
//  908   //  HalCalcTV(tvsaDat);
//  909 #if TVSA_DATA_CNF
//  910   tvsaDat[TVSA_RTG_IDX] = tvsaCnfErrCnt;
//  911 #else
//  912   tvsaDat[TVSA_RTG_IDX] = 0;
//  913 #endif
//  914   //osal_set_event(tvsaTaskId, TVSA_EVT_REQ);
//  915   if(QS == true && SUCCESS == osal_set_event(pulseTaskId, PULSE_EVT_REQ)){}  //If pulse is being measured synchronize pulsedatareq event
//  916   
//  917  
//  918 }
//  919 static void pulseBPM(uint8 *pulsedata)
//  920 {
//  921 
//  922 //MHMS 
//  923 int BPM = pulsedata[PULSE_BPM];                         // used to hold the pulse rate
//  924 int Signal;                                             // holds the incoming raw data
//  925 int IBI = pulsedata[PULSE_IBI];                         // holds the time between beats, the Inter-Beat Interval
//  926 
//  927 //    cli();                                            // disable interrupts while we do this
//  928 //    Signal = analogRead(pulsePin);                    // read the Pulse Sensor  //MHMS orginal arduino code
//  929 
//  930 //MHMS using HAL layer API to set channel to read and 10 Bit resolution
//  931   Signal = HalAdcRead(HAL_ADC_CHANNEL_7, HAL_ADC_RESOLUTION_10);
//  932   
//  933   sampleCounter += 2;                                   // keep track of the time in mS with this variable
//  934   int Number = (sampleCounter - lastBeatTime);          // monitor the time since the last beat to avoid noise
//  935 
//  936 //  find the peak and trough of the pulse wave
//  937     if(Signal < thresh && Number > (IBI/5)*3){          // avoid dichrotic noise by waiting 3/5 of last IBI
//  938         if (Signal < T){                                // T is the trough
//  939             T = Signal;                                 // keep track of lowest point in pulse wave 
//  940          }
//  941        }
//  942       
//  943     if(Signal > thresh && Signal > P){          // thresh condition helps avoid noise
//  944         P = Signal;                             // P is the peak
//  945        }                                        // keep track of highest point in pulse wave
//  946     
//  947   //  NOW IT'S TIME TO LOOK FOR THE HEART BEAT
//  948   // signal surges up in value every time there is a pulse
//  949 if (Number > 250){                                   // avoid high frequency noise //MHMS increased from 250 to 500 to reduce high freq noise
//  950   if ((Signal > thresh) && (Pulse == false) && (Number > (int)(IBI/5)*3) ){        
//  951     Pulse = true;                               // set the Pulse flag when we think there is a pulse
//  952     
//  953     //MHMS  could define some external LED or just write to LCD screen "Pulse found"
//  954     HalLedSet (HAL_LED_2, HAL_LED_MODE_OFF);    //MHMS beat found
//  955     HalLedSet (HAL_LED_1, HAL_LED_MODE_ON);     //MHMS LED on during upbeat
//  956     
//  957     IBI = sampleCounter - lastBeatTime;         // measure time between beats in mS
//  958     lastBeatTime = sampleCounter;               // keep track of time for next pulse
//  959          
//  960          if(firstBeat){                         // if it's the first time we found a beat, if firstBeat == TRUE
//  961              firstBeat = false;                 // clear firstBeat flag
//  962              return;                            // IBI value is unreliable so discard it
//  963             }   
//  964          if(secondBeat){                        // if this is the second beat, if secondBeat == TRUE
//  965             secondBeat = false;                 // clear secondBeat flag
//  966                for(int i=0; i<=9; i++){         // seed the running total to get a realisitic BPM at startup
//  967                     rate[i] = IBI;                      
//  968                     }
//  969             }
//  970           
//  971     // keep a running total of the last 10 IBI values
//  972     int16 runningTotal = 0; //word runningTotal = 0;                   // clear the runningTotal variable    
//  973 
//  974     for(int i=0; i<=8; i++){                // shift data in the rate array
//  975           rate[i] = rate[i+1];              // and drop the oldest IBI value 
//  976           runningTotal += rate[i];          // add up the 9 oldest IBI values
//  977         }
//  978         
//  979     rate[9] = IBI;                          // add the latest IBI to the rate array
//  980     runningTotal += rate[9];                // add the latest IBI to runningTotal
//  981     runningTotal /= 10;                     // average the last 10 IBI values 
//  982     BPM = 60000/runningTotal;               // how many beats can fit into a minute? that's BPM!
//  983     QS = true;                              // set Quantified Self flag //MHMS we will use this to flag other event to transmit data over network
//  984     
//  985     
//  986     HalLcdWriteStringValue("BPM:",BPM, 10, 6); //MHMS display BPM on LCD screen
//  987     }                       
//  988 }
//  989 
//  990   if (Signal < thresh && Pulse == true){     // when the values are going down, the beat is over
//  991       //digitalWrite(blinkPin,LOW);            // turn off pin 13 LED
//  992      //MHMS  could define some external LED or just write to LCD screen "Pulse Not found"
//  993       HalLedSet (HAL_LED_1, HAL_LED_MODE_OFF);
//  994       
//  995       Pulse = false;                         // reset the Pulse flag so we can do it again
//  996       amp = P - T;                           // get amplitude of the pulse wave
//  997       thresh = amp/2 + T + 100;              // set thresh at 50% of the amplitude  //MHMS offset up by 100 to ignore small flucuations due to noise
//  998       P = thresh;                            // reset these for next time
//  999       T = thresh;
// 1000      }
// 1001   
// 1002   if (Number > 2500){                        // if 2.5 seconds go by without a beat
// 1003       HalLedSet (HAL_LED_2, HAL_LED_MODE_ON);//MHMS No beat found
// 1004       thresh = 512 + 100;                    // set thresh default //MHMS offset up by 100 to ignore small flucuations due to noise
// 1005       P = 512;                               // set P default
// 1006       T = 512;                               // set T default
// 1007       lastBeatTime = sampleCounter;          // bring the lastBeatTime up to date        
// 1008       firstBeat = true;                      // set these to avoid noise
// 1009       secondBeat = true;                     // when we get the heartbeat back
// 1010       QS = false;                            // Clears Pulse measurement quantifier flag so no data  is sent over the air
// 1011      }
// 1012 
// 1013 //MHMS Loading 16 bit results into 8 bit blocks for pulsedata array              
// 1014 pulsedata[PULSE_BPM] = (uint8)((BPM & 0x00FF));
// 1015 pulsedata[PULSE_RAW_MSB] = (uint8)((Signal >> 8));
// 1016 pulsedata[PULSE_RAW_LSB] = (uint8)((Signal & 0x00FF));
// 1017 pulsedata[PULSE_IBI] = (uint8)((IBI & 0x00FF));
// 1018 
// 1019 pulsedata[PULSE_BPM_CHAR] = 'B';
// 1020 pulsedata[PULSE_RAW_CHAR] = 'Q';
// 1021 pulsedata[PULSE_IBI_CHAR] = 'S';
// 1022 
// 1023 //HalLcdWriteStringValue("Signal:",Signal, 10, 7); //MHMS  for testing ADC values
// 1024 
// 1025 
// 1026   //sei();                                     // enable interrupts when youre done!
// 1027 }// end isr
// 1028 
// 1029 /**************************************************************************************************
// 1030  * @fn          pulseDataReq
// 1031  *
// 1032  * @brief       This function is called by tvsaAppEvt() to send a PULSE data report. When it is detected that
// 1033  *              a pulse is found (QS flag is set) this function will start to transfer BPM, IBI, and raw Signal
// 1034  *              data over the air to the coordinator at 20ms intervals. When there is no BPM detected
// 1035  *              this function will stop sending information over the air to the coordinator.
// 1036  *
// 1037  * input parameters
// 1038  *
// 1039  * None.
// 1040  *
// 1041  * output parameters
// 1042  *
// 1043  * None.
// 1044  *
// 1045  * @return      None.
// 1046  **************************************************************************************************
// 1047  */
// 1048 static void pulseDataReq(void)
// 1049 {
// 1050   static bool pulseDataReqFlag;
// 1051   pulseDataReqFlag = false;
// 1052   afAddrType_t addr;                    //AF address stucture defined for info on the destination Endpoint object that data will be sent to
// 1053   
// 1054   addr.addr.shortAddr = pulseAddr;      //loading short address (16-bit) with pulse address
// 1055   addr.addrMode = afAddr16Bit;          //Set to directly sent to a node
// 1056   addr.endPoint = PULSE_ENDPOINT;       //Sets the endpoint of the final destination (coordinator?)
// 1057 
// 1058   if (afStatus_SUCCESS != AF_DataRequest(&addr, (endPointDesc_t *)&PULSE_epDesc, PULSE_CLUSTER_ID,
// 1059                                           PULSE_DAT_LEN, pulseDat, &pulseTSN,
// 1060                                           AF_DISCV_ROUTE
// 1061 #if TVSA_DATA_CNF
// 1062                                         | AF_ACK_REQUEST
// 1063 #endif
// 1064                                          ,AF_DEFAULT_RADIUS))  //MHMS
// 1065   { //if data transfer is unsuccessful place event immediately back into queue to attempt to send again
// 1066         osal_set_event(pulseTaskId, PULSE_EVT_REQ);
// 1067   }
// 1068   else
// 1069   {
// 1070     tvsaCnt++;
// 1071   }
// 1072   if((QS == true) && (pulseDataReqFlag == false)){
// 1073     osal_start_timerEx(pulseTaskId, PULSE_EVT_REQ, PULSE_DLY_DATAREQ);  //send next Pulse data report in 20ms
// 1074     pulseDataReqFlag = true;  //to prevent restarting of timer if existing already running
// 1075     
// 1076   }
// 1077   
// 1078   //testing USB
// 1079   //MHMS USB communication with Pulse sensor Processor application
// 1080 
// 1081   uint8 BPMBuf[7] = {'B',0,0,0,10,13};
// 1082   uint8 IBIBuf[7] = {'Q',0,0,0,10,13};
// 1083   uint8 SignalBuf[7] = {'S',0,0,0,10,13};
// 1084   
// 1085   //conversion Signal Dec to ASCII
// 1086   uint16 temp = (BUILD_UINT16(pulseDat[14], pulseDat[15])) - 400;
// 1087   if(temp > 999){
// 1088     SignalBuf[1] = '9';
// 1089     SignalBuf[2] = '9';
// 1090     SignalBuf[3] = '9';
// 1091   }
// 1092   else { 
// 1093     SignalBuf[1] = (uint8)((temp/100)+ 48);
// 1094     SignalBuf[2] = (uint8)((((temp%100) - (temp % 100)%10)/10) + 48);
// 1095     SignalBuf[3] = (uint8)(((temp % 100)%10)+ 48);
// 1096   }
// 1097   
// 1098   //conversion BPM Dec to ASCII
// 1099   temp = (uint16)pulseDat[12];
// 1100   BPMBuf[1] = (uint8)((temp/100)+ 48);
// 1101   BPMBuf[2] = (uint8)((((temp%100) - (temp % 100)%10)/10) + 48);
// 1102   BPMBuf[3] = (uint8)(((temp % 100)%10)+ 48);
// 1103   
// 1104   //conversion IBI Dec to ASCII
// 1105   temp = (uint16)pulseDat[17];
// 1106   IBIBuf[1] = (uint8)((temp/100)+ 48);
// 1107   IBIBuf[2] = (uint8)((((temp%100) - (temp % 100)%10)/10) + 48);
// 1108   IBIBuf[3] = (uint8)(((temp % 100)%10)+ 48);
// 1109    
// 1110   
// 1111   HalUARTWrite(0, SignalBuf, 6);
// 1112   HalUARTWrite(0, BPMBuf, 6);
// 1113   HalUARTWrite(0, IBIBuf, 6);
// 1114 }
// 1115 #endif //Group 1
// 
// 898 bytes in segment CODE
//   6 bytes in segment DATA16_AN
//  55 bytes in segment DATA16_C
//  12 bytes in segment DATA16_I
//  12 bytes in segment DATA16_ID
//  70 bytes in segment DATA16_Z
// 
// 898 bytes of CODE  memory
//  67 bytes of CONST memory
//  82 bytes of DATA  memory (+ 6 bytes shared)
//
//Errors: none
//Warnings: 5
