///////////////////////////////////////////////////////////////////////////////
//                                                                            /
// IAR C/C++ Compiler V5.51.2.50607/W32 for MSP430      24/Apr/2013  12:06:18 /
// Copyright 1996-2012 IAR Systems AB.                                        /
//                                                                            /
//    __rt_version  =  3                                                      /
//    __double_size =  32                                                     /
//    __reg_r4      =  free                                                   /
//    __reg_r5      =  free                                                   /
//    __pic         =  no                                                     /
//    __core        =  430X                                                   /
//    __data_model  =  small                                                  /
//    Source file   =  C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5. /
//                     1\Components\hal\target\MSP5438ZAP\hal_uart.c          /
//    Command line  =  -f C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2 /
//                     .5.1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\Source\zap /
//                     .cfg (-DTVSA_DEVICE_ID=0x0016 -DTVSA_DONGLE=1          /
//                     -DHAL_UART=1 -DZAP_PHY_SPI=1                           /
//                     -DZAP_PHY_UART=!ZAP_PHY_SPI -DZAP_PHY_RESET_ZNP=TRUE   /
//                     -DZAP_ZNP_MT=FALSE -DZAP_APP_MSG=FALSE                 /
//                     -DZAP_SBL_PROXY=FALSE -DZAP_AUTO_CFG=TRUE              /
//                     -DZAP_AUTO_START=TRUE -DZAP_NV_RESTORE=FALSE           /
//                     -DLCD_SUPPORTED -DZAP_AF_DATA_REQ_FRAG=FALSE           /
//                     -DZAP_AF_DATA_REQ_AREQ=!ZAP_AF_DATA_REQ_FRAG           /
//                     -DZAP_ZDO_STARTUP_AREQ=TRUE -DZAP_AF_FUNC              /
//                     -DZAP_SAPI_FUNC -DZAP_SYS_FUNC -DZAP_UTIL_FUNC         /
//                     -DZAP_ZDO_FUNC -DSECURE=0 -DZG_SECURE_DYNAMIC=0        /
//                     "-DDEFAULT_CHANLIST=(uint32)0x00000800"                /
//                     -DZDAPP_CONFIG_PAN_ID=0xFFFF -DPOLL_RATE=1000          /
//                     -DNWK_START_DELAY=100 -DMAX_BINDING_CLUSTER_IDS=4)     /
//                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5. /
//                     1\Components\hal\target\MSP5438ZAP\hal_uart.c -D       /
//                     ZAP_DEVICETYPE=ZG_DEVICETYPE_ROUTER -D                 /
//                     TVSA_DEVICE_ID=0x0016 -lC "C:\Users\student\Documents\ /
//                     GitHub\MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\ /
//                     EXP5438\ZAP Router\List\" -lA                          /
//                     "C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5 /
//                     .1\Projects\zstack\ZAP\TVSA\EXP5438\ZAP Router\List\"  /
//                     --remarks --diag_suppress Pe001,Pe193,Pe236,Pe826 -o   /
//                     "C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5 /
//                     .1\Projects\zstack\ZAP\TVSA\EXP5438\ZAP Router\Obj\"   /
//                     --debug -D__MSP430F5438A__ -e --double=32 --clib -I    /
//                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5. /
//                     1\Projects\zstack\ZAP\TVSA\EXP5438\ -I                 /
//                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5. /
//                     1\Projects\zstack\ZAP\TVSA\EXP5438\..\Source\ -I       /
//                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5. /
//                     1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\Source\ -I    /
//                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5. /
//                     1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Comp /
//                     onents\hal\target\MSP5438ZAP\ -I                       /
//                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5. /
//                     1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Comp /
//                     onents\hal\include\ -I C:\Users\student\Documents\GitH /
//                     ub\MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5 /
//                     438\..\..\..\..\..\Components\mac\include\ -I          /
//                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5. /
//                     1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Comp /
//                     onents\mt\ -I C:\Users\student\Documents\GitHub\MHMS\Z /
//                     AP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\..\.. /
//                     \..\..\..\Components\osal\include\ -I                  /
//                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5. /
//                     1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Comp /
//                     onents\osal\mcu\msp430\ -I                             /
//                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5. /
//                     1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Comp /
//                     onents\services\saddr\ -I C:\Users\student\Documents\G /
//                     itHub\MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\E /
//                     XP5438\..\..\..\..\..\Components\services\sdata\ -I    /
//                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5. /
//                     1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Comp /
//                     onents\stack\af\ -I C:\Users\student\Documents\GitHub\ /
//                     MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438 /
//                     \..\..\..\..\..\Components\stack\nwk\ -I               /
//                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5. /
//                     1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Comp /
//                     onents\stack\sapi\ -I C:\Users\student\Documents\GitHu /
//                     b\MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP54 /
//                     38\..\..\..\..\..\Components\stack\sec\ -I             /
//                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5. /
//                     1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Comp /
//                     onents\stack\sys\ -I C:\Users\student\Documents\GitHub /
//                     \MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP543 /
//                     8\..\..\..\..\..\Components\stack\zdo\ -I              /
//                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5. /
//                     1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Comp /
//                     onents\zmac\ -I C:\Users\student\Documents\GitHub\MHMS /
//                     \ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\..\ /
//                     ..\..\..\..\Components\zmac\f8w\ --core=430X           /
//                     --data_model=small -Ohz --multiplier=32                /
//                     --multiplier_location=4C0 --require_prototypes         /
//                     --hw_workaround=CPU40 --hw_workaround=CPU42            /
//    List file     =  C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5. /
//                     1\Projects\zstack\ZAP\TVSA\EXP5438\ZAP                 /
//                     Router\List\hal_uart.s43                               /
//                                                                            /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////

        NAME hal_uart

        RTMODEL "__SystemLibrary", "CLib"
        RTMODEL "__core", "430X"
        RTMODEL "__data_model", "small"
        RTMODEL "__double_size", "32"
        RTMODEL "__pic", "no"
        RTMODEL "__reg_r4", "free"
        RTMODEL "__reg_r5", "free"
        RTMODEL "__rt_version", "3"

        RSEG CSTACK:DATA:SORT:NOROOT(0)

        EXTERN ?cstart_init_copy
        EXTERN ?cstart_init_zero
        EXTERN ?longjmp_r4
        EXTERN ?longjmp_r5
        EXTERN ?setjmp_r4
        EXTERN ?setjmp_r5

        PUBWEAK `??halBoardUart1Isr??INTVEC 92`
        PUBWEAK ?setjmp_save_r4
        PUBWEAK ?setjmp_save_r5
        PUBLIC HalUARTClose
        FUNCTION HalUARTClose,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC HalUARTInit
        FUNCTION HalUARTInit,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC HalUARTOpen
        FUNCTION HalUARTOpen,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 6, STACK
        PUBLIC HalUARTPoll
        FUNCTION HalUARTPoll,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC HalUARTRead
        FUNCTION HalUARTRead,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 8, STACK
        PUBLIC HalUARTWrite
        FUNCTION HalUARTWrite,080203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 8, STACK
        FUNCTION Hal_UART_BufferInit,0203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC Hal_UART_FlowControlSet
        FUNCTION Hal_UART_FlowControlSet,0203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC Hal_UART_RxBufLen
        FUNCTION Hal_UART_RxBufLen,0203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        FUNCTION Hal_UART_RxProcessEvent,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        FUNCTION Hal_UART_SendCallBack,041203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC Hal_UART_TxBufLen
        FUNCTION Hal_UART_TxBufLen,0203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        FUNCTION Hal_UART_TxProcessEvent,0203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC UBRRTable
        PUBWEAK UCA1RXBUF
        PUBWEAK UCA1TXBUF
        PUBWEAK _A_PCDIR_L
        PUBWEAK _A_PCSEL_L
        PUBWEAK _A_UCA1BRW_L
        PUBWEAK _A_UCA1CTLW0_L
        PUBWEAK _A_UCA1ICTL_L
        PUBLIC halBoardUart1Isr
        FUNCTION halBoardUart1Isr,021233H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 12, STACK
        PUBLIC uartRecord
        
          CFI Names cfiNames0
          CFI StackFrame CFA SP DATA
          CFI Resource PC:20, SP:20, SR:16, R4L:16, R4H:4, R4:20, R5L:16, R5H:4
          CFI Resource R5:20, R6L:16, R6H:4, R6:20, R7L:16, R7H:4, R7:20, R8L:16
          CFI Resource R8H:4, R8:20, R9L:16, R9H:4, R9:20, R10L:16, R10H:4
          CFI Resource R10:20, R11L:16, R11H:4, R11:20, R12L:16, R12H:4, R12:20
          CFI Resource R13L:16, R13H:4, R13:20, R14L:16, R14H:4, R14:20, R15L:16
          CFI Resource R15H:4, R15:20
          CFI ResourceParts R4 R4H, R4L
          CFI ResourceParts R5 R5H, R5L
          CFI ResourceParts R6 R6H, R6L
          CFI ResourceParts R7 R7H, R7L
          CFI ResourceParts R8 R8H, R8L
          CFI ResourceParts R9 R9H, R9L
          CFI ResourceParts R10 R10H, R10L
          CFI ResourceParts R11 R11H, R11L
          CFI ResourceParts R12 R12H, R12L
          CFI ResourceParts R13 R13H, R13L
          CFI ResourceParts R14 R14H, R14L
          CFI ResourceParts R15 R15H, R15L
          CFI EndNames cfiNames0
        
          CFI Common cfiCommon0 Using cfiNames0
          CFI CodeAlign 2
          CFI DataAlign 2
          CFI ReturnAddress PC CODE
          CFI CFA SP+4
          CFI PC Frame(CFA, -4)
          CFI SR Undefined
          CFI R4L SameValue
          CFI R4H 0
          CFI R4 Concat
          CFI R5L SameValue
          CFI R5H 0
          CFI R5 Concat
          CFI R6L SameValue
          CFI R6H 0
          CFI R6 Concat
          CFI R7L SameValue
          CFI R7H 0
          CFI R7 Concat
          CFI R8L SameValue
          CFI R8H 0
          CFI R8 Concat
          CFI R9L SameValue
          CFI R9H 0
          CFI R9 Concat
          CFI R10L SameValue
          CFI R10H 0
          CFI R10 Concat
          CFI R11L SameValue
          CFI R11H 0
          CFI R11 Concat
          CFI R12L Undefined
          CFI R12H Undefined
          CFI R12 Undefined
          CFI R13L Undefined
          CFI R13H Undefined
          CFI R13 Undefined
          CFI R14L Undefined
          CFI R14H Undefined
          CFI R14 Undefined
          CFI R15L Undefined
          CFI R15H Undefined
          CFI R15 Undefined
          CFI EndCommon cfiCommon0
        
        
          CFI Common cfiCommon1 Using cfiNames0
          CFI CodeAlign 2
          CFI DataAlign 2
          CFI ReturnAddress PC CODE
          CFI CFA SP+4
          CFI PC Frame(CFA, -4)
          CFI SR Undefined
          CFI R4L SameValue
          CFI R4H 0
          CFI R4 Concat
          CFI R5L SameValue
          CFI R5H 0
          CFI R5 Concat
          CFI R6L SameValue
          CFI R6H 0
          CFI R6 Concat
          CFI R7L SameValue
          CFI R7H 0
          CFI R7 Concat
          CFI R8L SameValue
          CFI R8H 0
          CFI R8 Concat
          CFI R9L SameValue
          CFI R9H 0
          CFI R9 Concat
          CFI R10L SameValue
          CFI R10H 0
          CFI R10 Concat
          CFI R11L SameValue
          CFI R11H 0
          CFI R11 Concat
          CFI R12L SameValue
          CFI R12H 0
          CFI R12 Concat
          CFI R13L SameValue
          CFI R13H 0
          CFI R13 Concat
          CFI R14L SameValue
          CFI R14H 0
          CFI R14 Concat
          CFI R15L SameValue
          CFI R15H 0
          CFI R15 Concat
          CFI EndCommon cfiCommon1
        
        
          CFI Common cfiCommon2 Using cfiNames0
          CFI CodeAlign 2
          CFI DataAlign 2
          CFI ReturnAddress PC CODE
          CFI CFA SP+4
          CFI PC or(load(2, DATA, add(CFA, literal(-2))), lshift(and(load(2, DATA, add(CFA, literal(-4))), 61440), 4))
          CFI SR Frame(CFA, -4)
          CFI R4L SameValue
          CFI R4H 0
          CFI R4 Concat
          CFI R5L SameValue
          CFI R5H 0
          CFI R5 Concat
          CFI R6L SameValue
          CFI R6H 0
          CFI R6 Concat
          CFI R7L SameValue
          CFI R7H 0
          CFI R7 Concat
          CFI R8L SameValue
          CFI R8H 0
          CFI R8 Concat
          CFI R9L SameValue
          CFI R9H 0
          CFI R9 Concat
          CFI R10L SameValue
          CFI R10H 0
          CFI R10 Concat
          CFI R11L SameValue
          CFI R11H 0
          CFI R11 Concat
          CFI R12L SameValue
          CFI R12H 0
          CFI R12 Concat
          CFI R13L SameValue
          CFI R13H 0
          CFI R13 Concat
          CFI R14L SameValue
          CFI R14H 0
          CFI R14 Concat
          CFI R15L SameValue
          CFI R15H 0
          CFI R15 Concat
          CFI EndCommon cfiCommon2
        
halBoardUart1Isr    SYMBOL "halBoardUart1Isr"
`??halBoardUart1Isr??INTVEC 92` SYMBOL "??INTVEC 92", halBoardUart1Isr

        EXTERN osal_GetSystemClock
        FUNCTION osal_GetSystemClock,0202H
        EXTERN osal_mem_free
        FUNCTION osal_mem_free,0202H
        EXTERN osal_mem_alloc
        FUNCTION osal_mem_alloc,0202H

// C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1\Components\hal\target\MSP5438ZAP\hal_uart.c
//    1 /**************************************************************************************************
//    2   Filename:       hal_uart.c
//    3   Revised:        $Date: 2010-12-01 14:21:40 -0800 (Wed, 01 Dec 2010) $
//    4   Revision:       $Revision: 24527 $
//    5 
//    6   Description:    This file contains the interface to the UART.
//    7 
//    8 
//    9   Copyright 2007-2010 Texas Instruments Incorporated. All rights reserved.
//   10 
//   11   IMPORTANT: Your use of this Software is limited to those specific rights
//   12   granted under the terms of a software license agreement between the user
//   13   who downloaded the software, his/her employer (which must be your employer)
//   14   and Texas Instruments Incorporated (the "License").  You may not use this
//   15   Software unless you agree to abide by the terms of the License. The License
//   16   limits your use, and you acknowledge, that the Software may not be modified,
//   17   copied or distributed unless embedded on a Texas Instruments microcontroller
//   18   or used solely and exclusively in conjunction with a Texas Instruments radio
//   19   frequency transceiver, which is integrated into your product.  Other than for
//   20   the foregoing purpose, you may not use, reproduce, copy, prepare derivative
//   21   works of, modify, distribute, perform, display or sell this Software and/or
//   22   its documentation for any purpose.
//   23 
//   24   YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
//   25   PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
//   26   INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
//   27   NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
//   28   TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
//   29   NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
//   30   LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
//   31   INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
//   32   OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
//   33   OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
//   34   (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
//   35 
//   36   Should you have any questions regarding your right to use this Software,
//   37   contact Texas Instruments Incorporated at www.TI.com.
//   38 **************************************************************************************************/
//   39 
//   40 /*********************************************************************
//   41  * INCLUDES
//   42  */
//   43 
//   44 #include "hal_board_cfg.h"

        ASEGN DATA16_AN:DATA:NOROOT,0244H
// union <unnamed> _A_PCDIR_L
_A_PCDIR_L:
        DS8 2

        ASEGN DATA16_AN:DATA:NOROOT,024aH
// union <unnamed> _A_PCSEL_L
_A_PCSEL_L:
        DS8 2

        ASEGN DATA16_AN:DATA:NOROOT,0600H
// union <unnamed> _A_UCA1CTLW0_L
_A_UCA1CTLW0_L:
        DS8 2

        ASEGN DATA16_AN:DATA:NOROOT,0606H
// union <unnamed> _A_UCA1BRW_L
_A_UCA1BRW_L:
        DS8 2

        ASEGN DATA16_AN:DATA:NOROOT,060cH
// unsigned char const volatile UCA1RXBUF
UCA1RXBUF:
        DS8 1

        ASEGN DATA16_AN:DATA:NOROOT,060eH
// unsigned char volatile UCA1TXBUF
UCA1TXBUF:
        DS8 1

        ASEGN DATA16_AN:DATA:NOROOT,061cH
// union <unnamed> _A_UCA1ICTL_L
_A_UCA1ICTL_L:
        DS8 2
//   45 #include "hal_mcu.h"
//   46 #include "hal_types.h"
//   47 #include "hal_uart.h"
//   48 #include "osal.h"
//   49 #include "OSAL_Timers.h"
//   50 
//   51 /*-------------------------------------------------------------------------------------------------
//   52                                                MACROS
//   53  ------------------------------------------------------------------------------------------------*/
//   54 
//   55 /* Get 1 byte from UART */
//   56 #define HAL_UART_GETBYTE() UCxRXBUF
//   57 
//   58 /* Put 1 byte into the UART */
//   59 #define HAL_UART_PUTBYTE(x)            { UCxTXBUF = (x); }
//   60 
//   61 /* Set Baud rate */
//   62 #define HAL_UART_SETBAUDRATE(baudrate) { UCxBR1 = (baudrate) >> 8;  UCxBR0 = (baudrate); }
//   63 
//   64 /* Set Source Clock */
//   65 #define HAL_UART_SET_SRC_CLK()         { UCxCTL1 |= UCSSEL_3; } /* SMCLK */
//   66 
//   67 /* Setup TXD and RXD Port */
//   68 #define HAL_UART_PORT_CONFIG()         { PxSEL |= PxTX | PxRX; \ 
//   69                                          PxDIR |= PxTX; \ 
//   70                                          PxDIR &= ~PxRX; }
//   71 
//   72 /* Setup format frame */
//   73 #define HAL_UART_FRAME_CONFIG()        { UCxCTL0 = UCMODE_0;   /* UART Mode */        \ 
//   74                                          UCxCTL0 &= ~UCPEN;    /* Disable parity */   \ 
//   75                                          UCxCTL0 &= ~UCSPB;    /* 1 stop bit */       \ 
//   76                                          UCxCTL0 &= ~UC7BIT;   /* 8bit data*/         \ 
//   77                                          UCxCTL0 &= ~UCSYNC; } /* Asynchronous mode */
//   78 
//   79 /* Enable/Disable TX INT */
//   80 #define HAL_UART_TX_INT_ENABLE()       { UCxIE |= UCTXIE; }
//   81 #define HAL_UART_TX_INT_DISABLE()      { UCxIE &= ~UCTXIE; }
//   82 
//   83 /* Enable/Disable RX */
//   84 #define HAL_UART_RX_ENABLE()           /* N/A */
//   85 #define HAL_UART_RX_DISABLE()          /* N/A */
//   86 
//   87 /* Enable/Disable TX INT */
//   88 #define HAL_UART_RX_INT_ENABLE()       { UCxIE |= UCRXIE; }
//   89 #define HAL_UART_RX_INT_DISABLE()      { UCxIE &= ~UCRXIE; }
//   90 
//   91 /* Enable/Disable SWRST */
//   92 #define HAL_UART_SWRST_ENABLE()        { UCxCTL1 |= UCSWRST; }
//   93 #define HAL_UART_SWRST_DISABLE()       { UCxCTL1 &= ~UCSWRST; }
//   94 
//   95 /* Get Rx/Tx status bit */
//   96 #define HAL_UART_GET_RXTX_STATUS()    (UCxIFG & (UCRXIFG | UCTXIFG))
//   97 #define HAL_UART_GET_RX_STATUS()      (UCxIFG & UCRXIFG)
//   98 #define HAL_UART_GET_TX_STATUS()      (UCxIFG & UCTXIFG)
//   99 #define HAL_UART_CLR_TX_STATUS()      (UCxIFG &= ~UCTXIFG)
//  100 
//  101 /* UART CTS and RTS */
//  102 #define HAL_UART_CTS_PORT             /* N/A */
//  103 #define HAL_UART_CTS_BIT              /* N/A */
//  104 
//  105 #define HAL_UART_RTS_PORT             /* N/A */
//  106 #define HAL_UART_RTS_BIT              /* N/A */
//  107 
//  108 #define HAL_UART_FLOWCONTROL_INIT()   /* N/A */
//  109 
//  110 /*-------------------------------------------------------------------------------------------------
//  111                                           GLOBAL VARIABLES
//  112 -------------------------------------------------------------------------------------------------*/
//  113 

        RSEG DATA16_Z:DATA:SORT:NOROOT(1)
        REQUIRE ?cstart_init_zero
//  114 halUARTCfg_t uartRecord;
uartRecord:
        DS8 34
//  115 
//  116 #define HAL_GET_UBRR(BAUD_BPS)   ((uint32)(HAL_CPU_CLOCK_MHZ * 1000000) / (uint32)BAUD_BPS)
//  117 
//  118 /* UBRR table */

        RSEG DATA16_I:DATA:SORT:NOROOT(1)
        REQUIRE ?cstart_init_copy
//  119 uint16 UBRRTable[] = { HAL_GET_UBRR (9600),
UBRRTable:
        DS8 10
        REQUIRE `?<Initializer for UBRRTable>`
//  120                        HAL_GET_UBRR (19200),
//  121                        HAL_GET_UBRR (38400),
//  122                        HAL_GET_UBRR (57600),
//  123                        HAL_GET_UBRR (115200) };
//  124 
//  125 /*-------------------------------------------------------------------------------------------------
//  126                                          FUNCTIONS - LOCAL
//  127 -------------------------------------------------------------------------------------------------*/
//  128 
//  129 static void Hal_UART_BufferInit(void);
//  130 static void Hal_UART_RxProcessEvent(void);
//  131 static void Hal_UART_TxProcessEvent(void);
//  132 static void Hal_UART_SendCallBack(uint8 port, uint8 event);
//  133 
//  134 /*-------------------------------------------------------------------------------------------------
//  135                                   Application Level Functions
//  136 -------------------------------------------------------------------------------------------------*/
//  137 
//  138 /*************************************************************************************************
//  139  * @fn      HalUARTInit()
//  140  *
//  141  * @brief   Initialize the UART
//  142  *
//  143  * @param   none
//  144  *
//  145  * @return  none
//  146  *************************************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  147 void HalUARTInit ( void )
HalUARTInit:
          CFI Block cfiBlock0 Using cfiCommon0
          CFI Function HalUARTInit
//  148 {
//  149   Hal_UART_BufferInit();
        FUNCALL HalUARTInit, Hal_UART_BufferInit
        LOCFRAME CSTACK, 4, STACK
        BRA     #Hal_UART_BufferInit
          CFI EndBlock cfiBlock0
//  150 }
//  151 
//  152 /*************************************************************************************************
//  153  * @fn      HalBufferInit()
//  154  *
//  155  * @brief   Initialize the UART Buffers
//  156  *
//  157  * @param   none
//  158  *
//  159  * @return  none
//  160  *************************************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  161 static void Hal_UART_BufferInit (void)
Hal_UART_BufferInit:
          CFI Block cfiBlock1 Using cfiCommon0
          CFI Function Hal_UART_BufferInit
//  162 {
//  163   uartRecord.configured        = FALSE;
        MOV.B   #0x0, &uartRecord
//  164   uartRecord.rx.bufferHead     = 0;
        MOV.W   #0x0, &uartRecord + 8
//  165   uartRecord.rx.bufferTail     = 0;
        MOV.W   #0x0, &uartRecord + 10
//  166   uartRecord.rx.pBuffer        = (uint8 *)NULL;
        MOV.W   #0x0, &uartRecord + 14
//  167   uartRecord.tx.bufferHead     = 0;
        MOV.W   #0x0, &uartRecord + 16
//  168   uartRecord.tx.bufferTail     = 0;
        MOV.W   #0x0, &uartRecord + 18
//  169   uartRecord.tx.pBuffer        = (uint8 *)NULL;
        MOV.W   #0x0, &uartRecord + 22
//  170   uartRecord.rxChRvdTime       = 0;
        MOV.W   #0x0, &uartRecord + 26
        MOV.W   #0x0, &uartRecord + 28
//  171   uartRecord.intEnable         = FALSE;
        MOV.B   #0x0, &uartRecord + 24
//  172 }
        RETA
          CFI EndBlock cfiBlock1
//  173 
//  174 /*************************************************************************************************
//  175  * @fn      HalUARTOpen()
//  176  *
//  177  * @brief   Open a port based on the configuration
//  178  *
//  179  * @param   port   - UART port
//  180  *          config - contains configuration information
//  181  *          cBack  - Call back function where events will be reported back
//  182  *
//  183  * @return  Status of the function call
//  184  *************************************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  185 uint8 HalUARTOpen ( uint8 port, halUARTCfg_t *config )
HalUARTOpen:
          CFI Block cfiBlock2 Using cfiCommon0
          CFI Function HalUARTOpen
//  186 {
        FUNCALL HalUARTOpen, osal_mem_alloc
        LOCFRAME CSTACK, 6, STACK
        FUNCALL HalUARTOpen, osal_mem_alloc
        LOCFRAME CSTACK, 6, STACK
        PUSH.W  R10
          CFI R10L Frame(CFA, -6)
          CFI CFA SP+6
        MOV.W   R13, R10
//  187   /* Save important information */
//  188   uartRecord.baudRate             = config->baudRate;
        MOV.B   0x1(R13), &uartRecord + 1
//  189   uartRecord.flowControl          = config->flowControl;
        MOV.B   0x2(R13), &uartRecord + 2
        MOV.W   0x4(R13), &uartRecord + 4
//  190   uartRecord.flowControlThreshold = config->flowControlThreshold;
//  191   uartRecord.rx.maxBufSize        = config->rx.maxBufSize;
        MOV.W   0xc(R13), &uartRecord + 12
//  192   uartRecord.tx.maxBufSize        = config->tx.maxBufSize;
        MOV.W   0x14(R13), &uartRecord + 20
//  193   uartRecord.idleTimeout          = config->idleTimeout;
        MOV.B   0x6(R13), &uartRecord + 6
//  194   uartRecord.intEnable            = config->intEnable;
        MOV.B   0x18(R13), &uartRecord + 24
//  195   uartRecord.callBackFunc         = config->callBackFunc;
        MOV.W   0x1e(R13), &uartRecord + 30
        MOV.W   0x20(R13), &uartRecord + 32
//  196 
//  197   /* Set SWRST - UART logic held in reset state */
//  198   HAL_UART_SWRST_ENABLE();
        BIS.B   #0x1, &0x600
//  199 
//  200   /* Setup GPIO */
//  201   HAL_UART_PORT_CONFIG();
        BIS.B   #0xc0, &0x24a
        BIS.B   #0x40, &0x244
        BIC.B   #0x80, &0x244
//  202 
//  203   /* Set Frame Format */
//  204   HAL_UART_FRAME_CONFIG();
        MOV.B   #0x0, &0x601
        BIC.B   #0x80, &0x601
        BIC.B   #0x8, &0x601
        BIC.B   #0x10, &0x601
        BIC.B   #0x1, &0x601
//  205 
//  206   /* Set source clock */
//  207   HAL_UART_SET_SRC_CLK();
        BIS.B   #0xc0, &0x600
//  208 
//  209   /* Setup Baudrate */
//  210   if (config->baudRate > HAL_UART_BR_115200)
        MOV.B   0x1(R13), R15
        CMP.B   #0x5, R15
        JNC     ??HalUARTOpen_1
//  211   {
//  212     return HAL_UART_BAUDRATE_ERROR;
        MOV.B   #0x4, R12
        JMP     ??HalUARTOpen_2
//  213   }
//  214   else
//  215   {
//  216     HAL_UART_SETBAUDRATE(UBRRTable[config->baudRate]);  /* Set baud rate */
??HalUARTOpen_1:
        RLA.W   R15
        MOV.B   UBRRTable + 1(R15), &0x607
        MOV.B   0x1(R13), R15
        RLA.W   R15
        MOV.B   UBRRTable(R15), &0x606
//  217   }
//  218 
//  219   /* Setup Flow Control */
//  220   if (uartRecord.flowControl)
//  221   {
//  222     HAL_UART_FLOWCONTROL_INIT();
//  223     Hal_UART_FlowControlSet (port, uartRecord.flowControl);
//  224   }
//  225 
//  226   /* Setup threshold */
//  227   if (config->flowControlThreshold > config->rx.maxBufSize)
        MOV.W   0x4(R13), R15
        CMP.W   R15, 0xc(R13)
        JC      ??HalUARTOpen_0
//  228     uartRecord.flowControlThreshold = 0;
        MOV.W   #0x0, R15
//  229   else
//  230     uartRecord.flowControlThreshold = config->flowControlThreshold;
??HalUARTOpen_0:
        MOV.W   R15, &uartRecord + 4
//  231 
//  232   /* Allocate memory for Rx and Tx buffer */
//  233   uartRecord.rx.pBuffer = osal_mem_alloc (uartRecord.rx.maxBufSize);
        MOV.W   &uartRecord + 12, R12
        CALLA   #osal_mem_alloc
        MOV.W   R12, &uartRecord + 14
//  234   uartRecord.tx.pBuffer = osal_mem_alloc (uartRecord.tx.maxBufSize);
        MOV.W   &uartRecord + 20, R12
        CALLA   #osal_mem_alloc
        MOV.W   R12, &uartRecord + 22
//  235 
//  236   /* Validate buffers */
//  237   if ((uartRecord.rx.pBuffer) && (uartRecord.tx.pBuffer))
        CMP.W   #0x0, &uartRecord + 14
        JEQ     ??HalUARTOpen_3
        CMP.W   #0x0, R12
        JEQ     ??HalUARTOpen_3
//  238   {
//  239     /* Enable RX  Enable Rx Int */
//  240     HAL_UART_RX_ENABLE();
//  241 
//  242     /* Clear SWRST - releaset to operation */
//  243     HAL_UART_SWRST_DISABLE();
        BIC.B   #0x1, &0x600
//  244 
//  245     /* Enable interrupt (optional) */
//  246     if (config->intEnable)
        CMP.B   #0x0, 0x18(R10)
        JEQ     ??HalUARTOpen_4
//  247     {
//  248       HAL_UART_RX_INT_ENABLE();
        BIS.B   #0x1, &0x61c
        JMP     ??HalUARTOpen_5
//  249     }
//  250     else
//  251     {
//  252       HAL_UART_RX_INT_DISABLE();
??HalUARTOpen_4:
        BIC.B   #0x1, &0x61c
//  253     }
//  254 
//  255     HAL_UART_CLR_TX_STATUS();
??HalUARTOpen_5:
        BIC.B   #0x2, &0x61d
//  256 
//  257     /* Mark record as "configured" */
//  258     uartRecord.configured = TRUE;
        MOV.B   #0x1, &uartRecord
//  259 
//  260     /* Ready to be used. */
//  261     return HAL_UART_SUCCESS;
        MOV.B   #0x0, R12
        JMP     ??HalUARTOpen_2
//  262   }
//  263   else
//  264   {
//  265     /* If memory allocation failed, not "configured" */
//  266     uartRecord.configured = FALSE;
??HalUARTOpen_3:
        MOV.B   #0x0, &uartRecord
//  267 
//  268     /* Failed to allocate Rx and Tx Buffer, end of the story */
//  269     return HAL_UART_MEM_FAIL;
        MOV.B   #0x3, R12
??HalUARTOpen_2:
        POP.W   R10
          CFI R10L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock2
        REQUIRE _A_UCA1CTLW0_L
        REQUIRE _A_PCSEL_L
        REQUIRE _A_PCDIR_L
        REQUIRE _A_UCA1BRW_L
        REQUIRE _A_UCA1ICTL_L
//  270   }
//  271 }
//  272 
//  273 /*************************************************************************************************
//  274  * @fn      Hal_UARTPoll
//  275  *
//  276  * @brief   This routine simulate polling and has to be called by the main loop
//  277  *
//  278  * @param   void
//  279  *
//  280  * @return  void
//  281  *************************************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  282 void HalUARTPoll(void)
HalUARTPoll:
          CFI Block cfiBlock3 Using cfiCommon0
          CFI Function HalUARTPoll
//  283 {
//  284   if (!uartRecord.configured)  // If port is not configured, no point to poll it.
        FUNCALL HalUARTPoll, Hal_UART_RxProcessEvent
        LOCFRAME CSTACK, 4, STACK
        FUNCALL HalUARTPoll, Hal_UART_TxProcessEvent
        LOCFRAME CSTACK, 4, STACK
        FUNCALL HalUARTPoll, Hal_UART_RxBufLen
        LOCFRAME CSTACK, 4, STACK
        FUNCALL HalUARTPoll, Hal_UART_SendCallBack
        LOCFRAME CSTACK, 4, STACK
        FUNCALL HalUARTPoll, osal_GetSystemClock
        LOCFRAME CSTACK, 4, STACK
        FUNCALL HalUARTPoll, Hal_UART_SendCallBack
        LOCFRAME CSTACK, 4, STACK
        FUNCALL HalUARTPoll, Hal_UART_RxBufLen
        LOCFRAME CSTACK, 4, STACK
        FUNCALL HalUARTPoll, Hal_UART_SendCallBack
        LOCFRAME CSTACK, 4, STACK
        FUNCALL HalUARTPoll, Hal_UART_RxBufLen
        LOCFRAME CSTACK, 4, STACK
        CMP.B   #0x0, &uartRecord
        JEQ     ??HalUARTPoll_0
//  285   {
//  286     return;
//  287   }
//  288 
//  289   if (!uartRecord.intEnable)  // Check Port for items to process.
        CMP.B   #0x0, &uartRecord + 24
        JNE     ??HalUARTPoll_1
//  290   {
//  291     if (HAL_UART_GET_RX_STATUS())
        BIT.B   #0x1, &0x61d
        JNC     ??HalUARTPoll_2
//  292     {
//  293       Hal_UART_RxProcessEvent();
        CALLA   #Hal_UART_RxProcessEvent
//  294     }
//  295 
//  296     if (HAL_UART_GET_TX_STATUS())
??HalUARTPoll_2:
        BIT.B   #0x2, &0x61d
        JNC     ??HalUARTPoll_1
//  297     {
//  298       Hal_UART_TxProcessEvent();
        CALLA   #Hal_UART_TxProcessEvent
//  299     }
//  300   }
//  301 
//  302   if ((Hal_UART_RxBufLen(0) + 1) >= uartRecord.rx.maxBufSize)  // Report if Rx Buffer is full.
??HalUARTPoll_1:
        CALLA   #?Subroutine0
??CrossCallReturnLabel_1:
        ADD.W   #0x1, R12
        CMP.W   &uartRecord + 12, R12
        JNC     ??HalUARTPoll_3
//  303   {
//  304     Hal_UART_SendCallBack (0, HAL_UART_RX_FULL) ;
        MOV.B   #0x1, R13
        MOV.B   #0x0, R12
        CALLA   #Hal_UART_SendCallBack
//  305   }
//  306 
//  307   if ((uartRecord.rxChRvdTime != 0) &&  // Report if Rx Buffer is idled.
//  308      ((osal_GetSystemClock() - uartRecord.rxChRvdTime) > uartRecord.idleTimeout))
??HalUARTPoll_3:
        MOV.W   &uartRecord + 26, R15
        BIS.W   &uartRecord + 28, R15
        CMP.W   #0x0, R15
        JEQ     ??HalUARTPoll_4
        CALLA   #osal_GetSystemClock
        MOV.B   &uartRecord + 6, R14
        MOV.W   #0x0, R15
        SUB.W   &uartRecord + 26, R12
        SUBC.W  &uartRecord + 28, R13
        CMP.W   R13, R15
        JNC     ??HalUARTPoll_5
        JNE     ??HalUARTPoll_4
        CMP.W   R12, R14
        JC      ??HalUARTPoll_4
//  309   {
//  310     Hal_UART_SendCallBack (0, HAL_UART_RX_TIMEOUT) ;
??HalUARTPoll_5:
        MOV.B   #0x4, R13
        MOV.B   #0x0, R12
        CALLA   #Hal_UART_SendCallBack
//  311     uartRecord.rxChRvdTime = 0;
        MOV.W   #0x0, &uartRecord + 26
        MOV.W   #0x0, &uartRecord + 28
//  312   }
//  313 
//  314   /* Send back warning when buffer it threshold  and turn off flow */
//  315   if (Hal_UART_RxBufLen(0) >= uartRecord.rx.maxBufSize - uartRecord.flowControlThreshold)
??HalUARTPoll_4:
        CALLA   #?Subroutine0
??CrossCallReturnLabel_0:
        MOV.W   &uartRecord + 12, R15
        SUB.W   &uartRecord + 4, R15
        CMP.W   R15, R12
        JNC     ??HalUARTPoll_6
//  316   {
//  317     Hal_UART_SendCallBack (0, HAL_UART_RX_ABOUT_FULL) ;
        MOV.B   #0x2, R13
        MOV.B   #0x0, R12
        CALLA   #Hal_UART_SendCallBack
//  318   }
//  319 
//  320   if (uartRecord.flowControl)
??HalUARTPoll_6:
        CMP.B   #0x0, &uartRecord + 2
        JEQ     ??HalUARTPoll_0
//  321   {
//  322     if (Hal_UART_RxBufLen(0) > uartRecord.rx.maxBufSize / 2)
        CALLA   #?Subroutine0
//  323     {
//  324       Hal_UART_FlowControlSet (0, HAL_UART_FLOW_OFF);
//  325     }
//  326     else
//  327     {
//  328       Hal_UART_FlowControlSet (0, HAL_UART_FLOW_ON);
//  329     }
//  330   }
??HalUARTPoll_0:
        RETA
          CFI EndBlock cfiBlock3
        REQUIRE _A_UCA1ICTL_L
//  331 }

        RSEG CODE:CODE:REORDER:NOROOT(1)
?Subroutine0:
          CFI Block cfiCond4 Using cfiCommon0
          CFI Function HalUARTRead
          CFI Conditional ??CrossCallReturnLabel_2
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+12
          CFI Block cfiCond5 Using cfiCommon0
          CFI (cfiCond5) Function HalUARTPoll
          CFI (cfiCond5) Conditional ??CrossCallReturnLabel_1
          CFI (cfiCond5) CFA SP+8
          CFI Block cfiCond6 Using cfiCommon0
          CFI (cfiCond6) Function HalUARTPoll
          CFI (cfiCond6) Conditional ??CrossCallReturnLabel_0
          CFI (cfiCond6) CFA SP+8
          CFI Block cfiCond7 Using cfiCommon0
          CFI (cfiCond7) Function HalUARTPoll
          CFI (cfiCond7) Conditional ??HalUARTPoll_0
          CFI (cfiCond7) CFA SP+8
          CFI Block cfiPicker8 Using cfiCommon1
          CFI (cfiPicker8) NoFunction
          CFI (cfiPicker8) Picker
        MOV.B   #0x0, R12
        BRA     #Hal_UART_RxBufLen
          CFI EndBlock cfiCond4
          CFI EndBlock cfiCond5
          CFI EndBlock cfiCond6
          CFI EndBlock cfiCond7
          CFI EndBlock cfiPicker8
//  332 
//  333 /*************************************************************************************************
//  334  * @fn      HalUARTClose()
//  335  *
//  336  * @brief   Close the UART
//  337  *
//  338  * @param   port - UART port (not used.)
//  339  *
//  340  * @return  none
//  341  *************************************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  342 void HalUARTClose ( uint8 port )
HalUARTClose:
          CFI Block cfiBlock9 Using cfiCommon0
          CFI Function HalUARTClose
//  343 {
//  344   /* Disable Rx Int */
//  345   HAL_UART_RX_INT_DISABLE();
        FUNCALL HalUARTClose, osal_mem_free
        LOCFRAME CSTACK, 4, STACK
        FUNCALL HalUARTClose, osal_mem_free
        LOCFRAME CSTACK, 4, STACK
        FUNCALL HalUARTClose, Hal_UART_BufferInit
        LOCFRAME CSTACK, 4, STACK
        BIC.B   #0x1, &0x61c
//  346 
//  347   /* Disable RX */
//  348   HAL_UART_RX_DISABLE();
//  349 
//  350   /* Deallocate Rx and Tx Buffers */
//  351   if (uartRecord.configured)
        CMP.B   #0x0, &uartRecord
        JEQ     ??HalUARTClose_0
//  352   {
//  353     /* Free Tx and Rx buffer */
//  354     osal_mem_free (uartRecord.rx.pBuffer);
        MOV.W   &uartRecord + 14, R12
        CALLA   #osal_mem_free
//  355     osal_mem_free (uartRecord.tx.pBuffer);
        MOV.W   &uartRecord + 22, R12
        CALLA   #osal_mem_free
//  356 
//  357     /* Re-Initialze buffers again */
//  358     Hal_UART_BufferInit();
        CALLA   #Hal_UART_BufferInit
//  359   }
//  360 }
??HalUARTClose_0:
        RETA
          CFI EndBlock cfiBlock9
        REQUIRE _A_UCA1ICTL_L
//  361 
//  362 /*************************************************************************************************
//  363  * @fn      HalUARTRead()
//  364  *
//  365  * @brief   Read a buffer from the UART
//  366  *
//  367  * @param   port - UART port (not used.)
//  368  *          ppBuffer - pointer to a pointer that points to the data that will be read
//  369  *          length - length of the requested buffer
//  370  *
//  371  * @return  length of buffer that was read
//  372  *************************************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  373 uint16 HalUARTRead ( uint8 port, uint8 *pBuffer, uint16 length )
HalUARTRead:
          CFI Block cfiBlock10 Using cfiCommon0
          CFI Function HalUARTRead
//  374 {
        FUNCALL HalUARTRead, Hal_UART_RxBufLen
        LOCFRAME CSTACK, 8, STACK
        PUSHM.W #0x2, R11
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+8
//  375   uint16 cnt, idx;
//  376 
//  377   if (!uartRecord.configured)  // If port is not configured, no point to read it.
        CMP.B   #0x0, &uartRecord
        JNE     ??HalUARTRead_1
//  378   {
//  379     return 0;
        MOV.W   #0x0, R12
        JMP     ??HalUARTRead_2
//  380   }
//  381 
//  382   // If requested length is bigger than what in buffer, re-adjust it to the buffer length.
//  383   cnt = Hal_UART_RxBufLen(0);
??HalUARTRead_1:
        CALLA   #?Subroutine0
//  384   if (cnt < length)
??CrossCallReturnLabel_2:
        CMP.W   R14, R12
        JC      ??HalUARTRead_3
//  385   {
//  386     length = cnt;
        MOV.W   R12, R14
//  387   }
//  388 
//  389   idx = uartRecord.rx.bufferHead;
??HalUARTRead_3:
        MOV.W   &uartRecord + 8, R10
//  390   for (cnt = 0; cnt < length; cnt++)
        MOV.W   #0x0, R12
        JMP     ??HalUARTRead_4
//  391   {
//  392     pBuffer[cnt] = uartRecord.rx.pBuffer[idx++];
??HalUARTRead_0:
        MOV.W   &uartRecord + 14, R11
        ADD.W   R10, R11
        MOV.W   R13, R15
        ADD.W   R12, R15
        MOV.B   @R11, 0(R15)
        ADD.W   #0x1, R10
//  393 
//  394     if (idx >= uartRecord.rx.maxBufSize)
        CMP.W   &uartRecord + 12, R10
        JNC     ??HalUARTRead_5
//  395     {
//  396       idx = 0;
        MOV.W   #0x0, R10
//  397     }
//  398   }
??HalUARTRead_5:
        ADD.W   #0x1, R12
??HalUARTRead_4:
        CMP.W   R14, R12
        JNC     ??HalUARTRead_0
//  399   uartRecord.rx.bufferHead = idx;
        MOV.W   R10, &uartRecord + 8
//  400 
//  401   return length;  // Return number of bytes read.
        MOV.W   R14, R12
??HalUARTRead_2:
        POPM.W  #0x2, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock10
//  402 }
//  403 
//  404 /*************************************************************************************************
//  405  * @fn      HalUARTWrite()
//  406  *
//  407  * @brief   Write a buffer to the UART
//  408  *
//  409  * @param   port    - UART port (not used.)
//  410  *          pBuffer - pointer to the buffer that will be written
//  411  *          length  - length of
//  412  *
//  413  * @return  length of the buffer that was sent
//  414  *************************************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  415 uint16 HalUARTWrite ( uint8 port, uint8 *pBuffer, uint16 length )
HalUARTWrite:
          CFI Block cfiBlock11 Using cfiCommon0
          CFI Function HalUARTWrite
//  416 {
        PUSHM.W #0x2, R11
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+8
//  417   uint16 cnt, idx;
//  418   halIntState_t intState;
//  419 
//  420   if (!uartRecord.configured)
        CMP.B   #0x0, &uartRecord
        JEQ     ??HalUARTWrite_1
//  421   {
//  422     return 0;
//  423   }
//  424 
//  425   // Capture the value of the volatile variables.
//  426   idx = uartRecord.tx.bufferHead;
        MOV.W   &uartRecord + 16, R15
//  427   cnt = uartRecord.tx.bufferTail;
        MOV.W   &uartRecord + 18, R12
//  428   if (cnt == idx)
        CMP.W   R15, R12
        JNE     ??HalUARTWrite_2
//  429   {
//  430     cnt = uartRecord.tx.maxBufSize;
        MOV.W   &uartRecord + 20, R15
        JMP     ??HalUARTWrite_3
//  431   }
//  432   else if (cnt > idx)
??HalUARTWrite_2:
        CMP.W   R12, R15
        JC      ??HalUARTWrite_4
//  433   {
//  434     cnt = uartRecord.tx.maxBufSize - cnt + idx;
        MOV.W   &uartRecord + 20, R10
        SUB.W   R12, R10
        ADD.W   R15, R10
        MOV.W   R10, R15
        JMP     ??HalUARTWrite_3
//  435   }
//  436   else // (cnt < idx)
//  437   {
//  438     cnt = idx - cnt;
??HalUARTWrite_4:
        SUB.W   R12, R15
//  439   }
//  440    
//  441   // Accept "all-or-none" on write request.
//  442   if (cnt < length)
??HalUARTWrite_3:
        CMP.W   R14, R15
        JC      ??HalUARTWrite_5
//  443   {
//  444     return 0;
??HalUARTWrite_1:
        MOV.W   #0x0, R12
        JMP     ??HalUARTWrite_6
//  445   }
//  446 
//  447   idx = uartRecord.tx.bufferTail;
??HalUARTWrite_5:
        MOV.W   &uartRecord + 18, R12
//  448 
//  449   for (cnt = 0; cnt < length; cnt++)
        MOV.W   #0x0, R15
        JMP     ??HalUARTWrite_7
//  450   {
//  451     uartRecord.tx.pBuffer[idx++] = pBuffer[cnt];
??HalUARTWrite_0:
        MOV.W   R13, R10
        ADD.W   R15, R10
        MOV.W   &uartRecord + 22, R11
        ADD.W   R12, R11
        MOV.B   @R10, 0(R11)
        ADD.W   #0x1, R12
//  452 
//  453     if (idx >= uartRecord.tx.maxBufSize)
        CMP.W   &uartRecord + 20, R12
        JNC     ??HalUARTWrite_8
//  454     {
//  455       idx = 0;
        MOV.W   #0x0, R12
//  456     }
//  457   }
??HalUARTWrite_8:
        ADD.W   #0x1, R15
??HalUARTWrite_7:
        CMP.W   R14, R15
        JNC     ??HalUARTWrite_0
//  458 
//  459   HAL_ENTER_CRITICAL_SECTION(intState);  // Hold off interrupts.
        MOV.W   SR, R15
        dint
        nop
//  460   cnt = uartRecord.tx.bufferTail;
        MOV.W   &uartRecord + 18, R13
//  461   if (cnt == uartRecord.tx.bufferHead)
        CMP.W   &uartRecord + 16, R13
        JNE     ??HalUARTWrite_9
//  462   {
//  463     if (uartRecord.intEnable)
        CMP.B   #0x0, &uartRecord + 24
        JEQ     ??HalUARTWrite_10
//  464     {
//  465       HAL_UART_TX_INT_ENABLE();
        BIS.B   #0x2, &0x61c
//  466     }
//  467     HAL_UART_PUTBYTE(uartRecord.tx.pBuffer[uartRecord.tx.bufferHead]);  // Send a char to UART.
??HalUARTWrite_10:
        MOV.W   &uartRecord + 22, R11
        ADD.W   &uartRecord + 16, R11
        MOV.B   @R11, &0x60e
//  468   }
//  469   uartRecord.tx.bufferTail = idx;
??HalUARTWrite_9:
        MOV.W   R12, &uartRecord + 18
//  470   HAL_EXIT_CRITICAL_SECTION(intState);  // Restore interrupt enable.
        MOV.W   R15, SR
//  471 
//  472   return length;  // Return the number of bytes actually put into the buffer.
        MOV.W   R14, R12
??HalUARTWrite_6:
        POPM.W  #0x2, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock11
        REQUIRE _A_UCA1ICTL_L
        REQUIRE UCA1TXBUF
//  473 }
//  474 
//  475 /*************************************************************************************************
//  476  * @fn      Hal_UART_RxBufLen()
//  477  *
//  478  * @brief   Calculate Rx Buffer length of a port
//  479  *
//  480  * @param   port - UART port (not used.)
//  481  *
//  482  * @return  length of current Rx Buffer
//  483  *************************************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  484 uint16 Hal_UART_RxBufLen (uint8 port)
Hal_UART_RxBufLen:
          CFI Block cfiBlock12 Using cfiCommon0
          CFI Function Hal_UART_RxBufLen
//  485 {
//  486   int16 length = uartRecord.rx.bufferTail;
        MOV.W   &uartRecord + 10, R12
//  487 
//  488   length -= uartRecord.rx.bufferHead;
        SUB.W   &uartRecord + 8, R12
//  489   if  (length < 0)
        CMP.W   #0x0, R12
        JGE     ??Hal_UART_RxBufLen_0
//  490     length += uartRecord.rx.maxBufSize;
        ADD.W   &uartRecord + 12, R12
//  491 
//  492   return (uint16)length;
??Hal_UART_RxBufLen_0:
        RETA
          CFI EndBlock cfiBlock12
//  493 }
//  494 
//  495 /*************************************************************************************************
//  496  * @fn      Hal_UART_TxBufLen()
//  497  *
//  498  * @brief   Calculate Tx Buffer length of a port
//  499  *
//  500  * @param   port - UART port (not used.)
//  501  *
//  502  * @return  length of current Tx buffer
//  503  *************************************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  504 uint16 Hal_UART_TxBufLen ( uint8 port )
Hal_UART_TxBufLen:
          CFI Block cfiBlock13 Using cfiCommon0
          CFI Function Hal_UART_TxBufLen
//  505 {
//  506   int16 length = uartRecord.tx.bufferTail;
        MOV.W   &uartRecord + 18, R12
//  507 
//  508   length -= uartRecord.tx.bufferHead;
        SUB.W   &uartRecord + 16, R12
//  509   if  (length < 0)
        CMP.W   #0x0, R12
        JGE     ??Hal_UART_TxBufLen_0
//  510     length += uartRecord.tx.maxBufSize;
        ADD.W   &uartRecord + 20, R12
//  511 
//  512   return (uint16)length;
??Hal_UART_TxBufLen_0:
        RETA
          CFI EndBlock cfiBlock13
//  513 }
//  514 
//  515 /*-------------------------------------------------------------------------------------------------
//  516                                            HELP FUNCTIONS
//  517 -------------------------------------------------------------------------------------------------*/
//  518 
//  519 /*************************************************************************************************
//  520  * @fn      HalUARTSendCallBack
//  521  *
//  522  * @brief   Send Callback back to the caller
//  523  *
//  524  * @param   port - UART port
//  525  *          event - event that causes the call back
//  526  *
//  527  * @return  None
//  528  *************************************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  529 static void Hal_UART_SendCallBack(uint8 port, uint8 event)
Hal_UART_SendCallBack:
          CFI Block cfiBlock14 Using cfiCommon0
          CFI Function Hal_UART_SendCallBack
//  530 {
//  531   if (uartRecord.callBackFunc)
        FUNCALL Hal_UART_SendCallBack
        LOCFRAME CSTACK, 4, STACK
        MOV.W   &uartRecord + 30, R15
        BIS.W   &uartRecord + 32, R15
        CMP.W   #0x0, R15
        JEQ     ??Hal_UART_SendCallBack_0
//  532   {
//  533     (uartRecord.callBackFunc)(port, event);
        CALLA   &uartRecord + 30
//  534   }
//  535 }
??Hal_UART_SendCallBack_0:
        RETA
          CFI EndBlock cfiBlock14
//  536 
//  537 /*************************************************************************************************
//  538  * @fn      Hal_UART_ProcessRxEvent
//  539  *
//  540  * @brief   Process the Rx data by putting them in Rx Buffer. Callback will happen if idle timeout
//  541  *          or Rx buffer is full
//  542  *
//  543  * @param   void
//  544  *
//  545  * @return  void
//  546  *************************************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  547 static void Hal_UART_RxProcessEvent(void)
Hal_UART_RxProcessEvent:
          CFI Block cfiBlock15 Using cfiCommon0
          CFI Function Hal_UART_RxProcessEvent
//  548 {
//  549   uint8 ch = HAL_UART_GETBYTE();
        FUNCALL Hal_UART_RxProcessEvent, osal_GetSystemClock
        LOCFRAME CSTACK, 4, STACK
        MOV.B   &0x60c, R14
//  550 
//  551   uartRecord.rx.pBuffer[uartRecord.rx.bufferTail++] = ch;
        MOV.W   &uartRecord + 10, R15
        MOV.W   R15, R13
        ADD.W   #0x1, R13
        MOV.W   R13, &uartRecord + 10
        MOV.W   &uartRecord + 14, R13
        ADD.W   R15, R13
        MOV.B   R14, 0(R13)
//  552   if (uartRecord.rx.bufferTail >= uartRecord.rx.maxBufSize)
        CMP.W   &uartRecord + 12, &uartRecord + 10
        JNC     ??Hal_UART_RxProcessEvent_0
//  553   {
//  554     uartRecord.rx.bufferTail = 0;
        MOV.W   #0x0, &uartRecord + 10
//  555   }
//  556 
//  557   uartRecord.rxChRvdTime = osal_GetSystemClock();
??Hal_UART_RxProcessEvent_0:
        CALLA   #osal_GetSystemClock
        MOV.W   R12, &uartRecord + 26
        MOV.W   R13, &uartRecord + 28
//  558 }
        RETA
          CFI EndBlock cfiBlock15
        REQUIRE UCA1RXBUF
//  559 
//  560 /*************************************************************************************************
//  561  * @fn      Hal_UART_ProcessTxEvent
//  562  *
//  563  * @brief   Process Tx buffer and events
//  564  *
//  565  * @param   void
//  566  *
//  567  * @return  void
//  568  *************************************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  569 static void Hal_UART_TxProcessEvent(void)
Hal_UART_TxProcessEvent:
          CFI Block cfiBlock16 Using cfiCommon0
          CFI Function Hal_UART_TxProcessEvent
//  570 {
//  571   uint16 tail = uartRecord.tx.bufferTail;
        MOV.W   &uartRecord + 18, R15
//  572 
//  573   if (++uartRecord.tx.bufferHead >= uartRecord.tx.maxBufSize)
        MOV.W   &uartRecord + 16, R14
        ADD.W   #0x1, R14
        MOV.W   R14, &uartRecord + 16
        CMP.W   &uartRecord + 20, R14
        JNC     ??Hal_UART_TxProcessEvent_0
//  574   {
//  575     uartRecord.tx.bufferHead = 0;
        MOV.W   #0x0, &uartRecord + 16
//  576   }
//  577 
//  578   if (uartRecord.tx.bufferHead != tail)
??Hal_UART_TxProcessEvent_0:
        CMP.W   R15, &uartRecord + 16
        JEQ     ??Hal_UART_TxProcessEvent_1
//  579   {
//  580     HAL_UART_PUTBYTE(uartRecord.tx.pBuffer[uartRecord.tx.bufferHead]);  // Send a char to UART.
        MOV.W   &uartRecord + 22, R15
        ADD.W   &uartRecord + 16, R15
        MOV.B   @R15, &0x60e
        RETA
//  581   }
//  582   else
//  583   {
//  584     HAL_UART_TX_INT_DISABLE();
??Hal_UART_TxProcessEvent_1:
        BIC.B   #0x2, &0x61c
//  585     HAL_UART_CLR_TX_STATUS();
        BIC.B   #0x2, &0x61d
//  586   }
//  587 }
        RETA
          CFI EndBlock cfiBlock16
        REQUIRE UCA1TXBUF
        REQUIRE _A_UCA1ICTL_L
//  588 
//  589 /*************************************************************************************************
//  590  * @fn      Hal_UART_SetFlowControl
//  591  *
//  592  * @brief   Set UART Rx flow control
//  593  *
//  594  * @param   port: serial port (not used.)
//  595  *          on:   0=OFF, !0=ON
//  596  *
//  597  * @return  none
//  598  *
//  599  *************************************************************************************************/

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  600 void Hal_UART_FlowControlSet( uint8 port, uint8 status )
Hal_UART_FlowControlSet:
          CFI Block cfiBlock17 Using cfiCommon0
          CFI Function Hal_UART_FlowControlSet
//  601 {
//  602 }
        RETA
          CFI EndBlock cfiBlock17
//  603 
//  604 /*-------------------------------------------------------------------------------------------------
//  605                                     Interrupt Service Routines
//  606 -------------------------------------------------------------------------------------------------*/
//  607 
//  608 /*************************************************************************************************
//  609  * @fn      UART Rx/Tx ISR
//  610  *
//  611  * @brief   Called when a serial byte is ready to read and/or write.
//  612  *  NOTE:   Assumes that uartRecord.configured is TRUE if this interrupt is enabled.
//  613  *
//  614  * @param   void
//  615  *
//  616  * @return  void
//  617 **************************************************************************************************/

        RSEG ISR_CODE:CODE:REORDER:NOROOT(1)
//  618 INTERRUPT_UART()
halBoardUart1Isr:
          CFI Block cfiBlock18 Using cfiCommon2
          CFI Function halBoardUart1Isr
//  619 {
        FUNCALL halBoardUart1Isr, Hal_UART_RxProcessEvent
        LOCFRAME CSTACK, 12, STACK
        FUNCALL halBoardUart1Isr, Hal_UART_TxProcessEvent
        LOCFRAME CSTACK, 12, STACK
        PUSHM.W #0x4, R15
          CFI R12L Frame(CFA, -12)
          CFI R13L Frame(CFA, -10)
          CFI R14L Frame(CFA, -8)
          CFI R15L Frame(CFA, -6)
          CFI CFA SP+12
//  620   do {
//  621     if (HAL_UART_GET_RX_STATUS())
??halBoardUart1Isr_0:
        BIT.B   #0x1, &0x61d
        JNC     ??halBoardUart1Isr_1
//  622     {
//  623       Hal_UART_RxProcessEvent();
        CALLA   #Hal_UART_RxProcessEvent
//  624     }
//  625 
//  626     if (HAL_UART_GET_TX_STATUS())
??halBoardUart1Isr_1:
        BIT.B   #0x2, &0x61d
        JNC     ??halBoardUart1Isr_2
//  627     {
//  628       Hal_UART_TxProcessEvent();
        CALLA   #Hal_UART_TxProcessEvent
//  629     }
//  630   } while (HAL_UART_GET_RXTX_STATUS());
??halBoardUart1Isr_2:
        BIT.B   #0x3, &0x61d
        JNE     ??halBoardUart1Isr_0
//  631 }
        POPM.W  #0x4, R15
          CFI R12L SameValue
          CFI R13L SameValue
          CFI R14L SameValue
          CFI R15L SameValue
          CFI CFA SP+4
        RETI
          CFI EndBlock cfiBlock18
        REQUIRE _A_UCA1ICTL_L

        COMMON INTVEC:CONST:ROOT(1)
        ORG 92
`??halBoardUart1Isr??INTVEC 92`:
        DC16    halBoardUart1Isr

        RSEG DATA16_ID:CONST:SORT:NOROOT(1)
`?<Initializer for UBRRTable>`:
        DC16 1250, 625, 312, 208, 104

        RSEG CODE:CODE:REORDER:NOROOT(1)
?setjmp_save_r4:
        REQUIRE ?setjmp_r4
        REQUIRE ?longjmp_r4

        RSEG CODE:CODE:REORDER:NOROOT(1)
?setjmp_save_r5:
        REQUIRE ?setjmp_r5
        REQUIRE ?longjmp_r5

        END
//  632 
// 
// 838 bytes in segment CODE
//  12 bytes in segment DATA16_AN
//  10 bytes in segment DATA16_I
//  10 bytes in segment DATA16_ID
//  34 bytes in segment DATA16_Z
//   2 bytes in segment INTVEC
//  34 bytes in segment ISR_CODE
// 
// 872 bytes of CODE  memory
//  10 bytes of CONST memory (+  2 bytes shared)
//  44 bytes of DATA  memory (+ 12 bytes shared)
//
//Errors: none
//Warnings: none
