###############################################################################
#                                                                             #
# IAR C/C++ Compiler V5.51.2.50607/W32 for MSP430       26/Apr/2013  13:59:22 #
# Copyright 1996-2012 IAR Systems AB.                                         #
#                                                                             #
#    __rt_version  =  3                                                       #
#    __double_size =  32                                                      #
#    __reg_r4      =  free                                                    #
#    __reg_r5      =  free                                                    #
#    __pic         =  no                                                      #
#    __core        =  430X                                                    #
#    __data_model  =  small                                                   #
#    Source file   =  C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\Source\tvsa.c                 #
#    Command line  =  -f C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2. #
#                     5.1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\Source\zap.c #
#                     fg (-DTVSA_DEVICE_ID=0x0016 -DTVSA_DONGLE=1             #
#                     -DHAL_UART=1 -DZAP_PHY_SPI=1                            #
#                     -DZAP_PHY_UART=!ZAP_PHY_SPI -DZAP_PHY_RESET_ZNP=TRUE    #
#                     -DZAP_ZNP_MT=FALSE -DZAP_APP_MSG=FALSE                  #
#                     -DZAP_SBL_PROXY=FALSE -DZAP_AUTO_CFG=TRUE               #
#                     -DZAP_AUTO_START=TRUE -DZAP_NV_RESTORE=FALSE            #
#                     -DLCD_SUPPORTED -DZAP_AF_DATA_REQ_FRAG=FALSE            #
#                     -DZAP_AF_DATA_REQ_AREQ=!ZAP_AF_DATA_REQ_FRAG            #
#                     -DZAP_ZDO_STARTUP_AREQ=TRUE -DZAP_AF_FUNC               #
#                     -DZAP_SAPI_FUNC -DZAP_SYS_FUNC -DZAP_UTIL_FUNC          #
#                     -DZAP_ZDO_FUNC -DSECURE=0 -DZG_SECURE_DYNAMIC=0         #
#                     "-DDEFAULT_CHANLIST=(uint32)0x00000800"                 #
#                     -DZDAPP_CONFIG_PAN_ID=0xFFFF -DPOLL_RATE=1000           #
#                     -DNWK_START_DELAY=100 -DMAX_BINDING_CLUSTER_IDS=4)      #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\Source\tvsa.c -D              #
#                     ZAP_DEVICETYPE=ZG_DEVICETYPE_COORDINATOR -D             #
#                     TVSA_DEVICE_ID=0x0016 -D TVSA_DONGLE=1 -D HAL_UART=1    #
#                     -lC "C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430- #
#                     2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\ZAP              #
#                     Coordinator\List\" -lA "C:\Users\student\Documents\GitH #
#                     ub\MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP54 #
#                     38\ZAP Coordinator\List\" --remarks --diag_suppress     #
#                     Pe001,Pe193,Pe236,Pe826 -o                              #
#                     "C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5. #
#                     1\Projects\zstack\ZAP\TVSA\EXP5438\ZAP                  #
#                     Coordinator\Obj\" --debug -D__MSP430F5438A__ -e         #
#                     --double=32 --clib -I C:\Users\student\Documents\GitHub #
#                     \MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438 #
#                     \ -I C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430- #
#                     2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\..\Source\ -I    #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\Source\ -I      #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\hal\target\MSP5438ZAP\ -I                          #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\hal\include\ -I C:\Users\student\Documents\GitHub\ #
#                     MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\ #
#                     ..\..\..\..\..\Components\mac\include\ -I               #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\mt\ -I C:\Users\student\Documents\GitHub\MHMS\ZAP- #
#                     MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\ #
#                     ..\..\Components\osal\include\ -I                       #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\osal\mcu\msp430\ -I C:\Users\student\Documents\Git #
#                     Hub\MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5 #
#                     438\..\..\..\..\..\Components\services\saddr\ -I        #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\services\sdata\ -I C:\Users\student\Documents\GitH #
#                     ub\MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP54 #
#                     38\..\..\..\..\..\Components\stack\af\ -I               #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\stack\nwk\ -I C:\Users\student\Documents\GitHub\MH #
#                     MS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\.. #
#                     \..\..\..\..\Components\stack\sapi\ -I                  #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\stack\sec\ -I C:\Users\student\Documents\GitHub\MH #
#                     MS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\.. #
#                     \..\..\..\..\Components\stack\sys\ -I                   #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\stack\zdo\ -I C:\Users\student\Documents\GitHub\MH #
#                     MS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\.. #
#                     \..\..\..\..\Components\zmac\ -I                        #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\zmac\f8w\ --core=430X --data_model=small -Ohz      #
#                     --multiplier=32 --multiplier_location=4C0               #
#                     --require_prototypes --hw_workaround=CPU40              #
#                     --hw_workaround=CPU42                                   #
#    List file     =  C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\ZAP                   #
#                     Coordinator\List\tvsa.lst                               #
#    Object file   =  C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\ZAP                   #
#                     Coordinator\Obj\tvsa.r43                                #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\Source\tvsa.c
      1          /**************************************************************************************************
      2              Filename:       tvsa.c
      3              Revised:        $Date: 2011-07-25 20:23:05 -0700 (Mon, 25 Jul 2011) $
      4              Revision:       $Revision: 26899 $
      5          
      6              Description:
      7          
      8              This file implements the Temperature/Voltage Sample Application.
      9          
     10          
     11          
     12          
     13              Copyright 2009 Texas Instruments Incorporated. All rights reserved.
     14          
     15              IMPORTANT: Your use of this Software is limited to those specific rights
     16              granted under the terms of a software license agreement between the user
     17              who downloaded the software, his/her employer (which must be your employer)
     18              and Texas Instruments Incorporated (the "License").  You may not use this
     19              Software unless you agree to abide by the terms of the License. The License
     20              limits your use, and you acknowledge, that the Software may not be modified,
     21              copied or distributed unless embedded on a Texas Instruments microcontroller
     22              or used solely and exclusively in conjunction with a Texas Instruments radio
     23              frequency transceiver, which is integrated into your product.  Other than for
     24              the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     25              works of, modify, distribute, perform, display or sell this Software and/or
     26              its documentation for any purpose.
     27          
     28              YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     29              PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     30              INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     31              NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     32              TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     33              NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     34              LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     35              INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     36              OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     37              OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     38              (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     39          
     40              Should you have any questions regarding your right to use this Software,
     41              contact Texas Instruments Incorporated at www.TI.com.
     42          **************************************************************************************************/
     43          
     44          /* ------------------------------------------------------------------------------------------------
     45           *                                          Includes
     46           * ------------------------------------------------------------------------------------------------
     47           */
     48          
     49          #include "af.h"
     50          #if defined LCD_SUPPORTED
     51          #include "hal_lcd.h"

   \                                 In  segment DATA16_AN, at 0x242
   \   union <unnamed> _A_PCOUT_L
   \                     _A_PCOUT_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x244
   \   union <unnamed> _A_PCDIR_L
   \                     _A_PCDIR_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x1b0
   \   union <unnamed> _A_REFCTL0_L
   \                     _A_REFCTL0_L:
   \   000000                DS8 2
     52          #endif
     53          #include "hal_uart.h"
     54          #include "OnBoard.h"
     55          #include "OSAL.h"
     56          #include "tvsa.h"
     57          #include "ZComDef.h"
     58          #include "ZDApp.h"
     59          #include "hal_led.h"  //MHMS for indicating if pulse is found
     60          #include "hal_adc.h"  //MHMS used for capturing signal from pulse sensor
     61          
     62          /* ------------------------------------------------------------------------------------------------
     63           *                                           Constants
     64           * ------------------------------------------------------------------------------------------------
     65           */
     66          
     67          // Constants for Pulse Sensor
     68          

   \                                 In  segment DATA16_C, align 2, align-sorted
     69          static const cId_t PULSE_ClusterList[PULSE_CLUSTER_CNT] =
   \                     PULSE_ClusterList:
   \   000000   0200         DC16 2
     70          {
     71            PULSE_CLUSTER_ID
     72          };
     73          

   \                                 In  segment DATA16_C, align 2, align-sorted
     74          static const SimpleDescriptionFormat_t PULSE_SimpleDesc =
   \                     PULSE_SimpleDesc:
   \   000000   0300         DC8 3, 0
   \   000002   100F0600     DC16 3856, 6
   \   000006   0001         DC8 0, 1
   \   000008   ....         DC16 PULSE_ClusterList
   \   00000A   0100         DC8 1, 0
   \   00000C   ....         DC16 PULSE_ClusterList
     75          {
     76            PULSE_ENDPOINT,
     77            PULSE_PROFILE_ID,
     78            PULSE_DEVICE_ID,
     79            PULSE_DEVICE_VERSION,
     80            PULSE_FLAGS,
     81            PULSE_CLUSTER_CNT,
     82            (cId_t *)PULSE_ClusterList,
     83            PULSE_CLUSTER_CNT,
     84            (cId_t *)PULSE_ClusterList
     85          };
     86          

   \                                 In  segment DATA16_C, align 2, align-sorted
     87          static const endPointDesc_t PULSE_epDesc=
   \                     PULSE_epDesc:
   \   000000   0300         DC8 3, 0
   \   000002   ........     DC16 pulseTaskId, PULSE_SimpleDesc
   \   000006   0000         DC8 0, 0
     88          {
     89            PULSE_ENDPOINT,
     90            &pulseTaskId,
     91            (SimpleDescriptionFormat_t *)&PULSE_SimpleDesc,
     92            noLatencyReqs,
     93          };
     94          /* ------------------------------------------------------------------------------------------------
     95           *                                           Typedefs
     96           * ------------------------------------------------------------------------------------------------
     97           */
     98          
     99          /* ------------------------------------------------------------------------------------------------
    100           *                                           Macros
    101           * ------------------------------------------------------------------------------------------------
    102           */
    103          
    104          /* ------------------------------------------------------------------------------------------------
    105           *                                           Global Variables
    106           * ------------------------------------------------------------------------------------------------
    107           */
    108          
    109          #if TVSA_DATA_CNF
    110          uint8 pulseCnfErrCnt;
    111          #endif
    112          
    113          //MHMS  Global Variables

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    114          uint8 pulseTaskId;
   \                     pulseTaskId:
   \   000000                DS8 1
    115          
    116          
    117          /* ------------------------------------------------------------------------------------------------
    118           *                                           Local Variables
    119           * ------------------------------------------------------------------------------------------------
    120           */
    121          
    122          // Network address of the TVSA Dongle.
    123          

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    124          static uint16 pulseAddr;
   \                     pulseAddr:
   \   000000                DS8 2
    125          // Report counter.

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    126          static uint16 pulseCnt;  //MHMS Question what is this for?
   \                     pulseCnt:
   \   000000                DS8 2
    127          // ZigBee-required packet transaction sequence number in calls to AF_DataRequest().
    128          

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    129          static uint8 pulseTSN;           //MHMS Question what is thi?
   \                     pulseTSN:
   \   000000                DS8 1
    130          
    131          //Data arrays for Over the air data tx and RX

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    132          static uint8 pulseBuf[PULSE_BUF_LEN];  //MHMS buffer used for recived over the air data
   \                     pulseBuf:
   \   000000                DS8 25

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    133          static uint8 pulseDat[PULSE_DAT_LEN];  //MHMS define data array length for Pulse sensor
   \                     pulseDat:
   \   000000                DS8 22

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    134          static uint8 TestDatTx[MHMS_TEST_PAYLOAD_LEN];
   \                     TestDatTx:
   \   000000                DS8 50
    135          
    136          //Syncronization Flags

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    137          static bool PulseEvtDat_sync = FALSE;  
   \                     PulseEvtDat_sync:
   \   000000                DS8 1

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    138          static bool PulseEvtReq_sync;
   \                     PulseEvtReq_sync:
   \   000000                DS8 1

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    139          static bool PulseEvtCheckin_sync;  
   \                     PulseEvtCheckin_sync:
   \   000000                DS8 1
    140             
    141          
    142          // these variables are volatile because they are used during the interrupt service routine!
    143          //MHMS From Arduino 1.1

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    144          volatile int BPM;                   // used to hold the pulse rate
   \                     BPM:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    145          volatile int Signal;                // holds the incoming raw data
   \                     Signal:
   \   000000                DS8 2

   \                                 In  segment DATA16_I, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
    146          volatile int IBI = 600;             // holds the time between beats, the Inter-Beat Interval
   \                     IBI:
   \   000000                DS8 2
   \   000002                REQUIRE `?<Initializer for IBI>`

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    147          volatile bool Pulse = FALSE;     // TRUE when pulse wave is high, FALSE when it's low
   \                     Pulse:
   \   000000                DS8 1

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    148          volatile bool QS = FALSE;        // becomes TRUE when Arduoino finds a beat.  
   \                     QS:
   \   000000                DS8 1
    149          
    150          
    151          
    152          /* ------------------------------------------------------------------------------------------------
    153           *                                           Local Functions
    154           * ------------------------------------------------------------------------------------------------
    155           */
    156          
    157          static void pulseAfMsgRx(afIncomingMSGPacket_t *msg);
    158          static void pulseSysEvtMsg(void);
    159          
    160          
    161          static void pulseBPM(uint8 *pulsedata);  //MHMS Pulse calculation function
    162          static void pulseDataCalc(void);
    163          static void pulseDataReq(void);
    164          static void pulseZdoStateChange(void);
    165          
    166          static void pulseNodeCheckIn(void);
    167          static void TestPayloadTx(void);
    168          
    169          static void pulseAnnce(void);
    170          static void pulseDataRx(afIncomingMSGPacket_t *msg);
    171          static void pulseTestingDataRx(afIncomingMSGPacket_t *msg);
    172          
    173          static void pulseUartRx(uint8 port, uint8 event);
    174          
    175          
    176          #ifndef TVSA_DEMO  //MHMS Question do we need this?
    177          static uint8 calcFCS(uint8 *pBuf, uint8 len);
    178          static void sysPingRsp(void);
    179          #endif
    180          
    181          /*  //MHMS Pulse Sensor Functions */ 
    182          
    183          /**************************************************************************************************
    184           * @fn          pulseAppInit
    185           *
    186           * @brief       This function is the application's task initialization.
    187           *
    188           * input parameters
    189           *
    190           * None.
    191           *
    192           * output parameters
    193           *
    194           * None.
    195           *
    196           * @return      None.
    197           **************************************************************************************************
    198           */

   \                                 In  segment CODE, align 2
    199          void pulseAppInit(uint8 id)
   \                     pulseAppInit:
    200          {
   \   000000   0A12         PUSH.W  R10
   \   000002   31802200     SUB.W   #0x22, SP
   \   000006   4A4C         MOV.B   R12, R10
    201          
    202            halUARTCfg_t uartConfig;
    203          
    204            uartConfig.configured           = TRUE;              // 2x30 don't care - see uart driver.
   \   000008   D1430000     MOV.B   #0x1, 0(SP)
    205            
    206          
    207            uartConfig.baudRate             = HAL_UART_BR_38400;        //MHMS This baud rate is required to communicate with Zigbee Sensor Monitor
   \   00000C   E1430100     MOV.B   #0x2, 0x1(SP)
    208            //uartConfig.baudRate             = HAL_UART_BR_115200;         //MHMS This baud rate is required to communicate with the Pulse processing program on PC
    209          
    210            
    211            uartConfig.flowControl          = FALSE;
   \   000010   C1430200     MOV.B   #0x0, 0x2(SP)
    212            uartConfig.flowControlThreshold = 16;                // 2x30 don't care - see uart driver.
   \   000014   B14010000400 MOV.W   #0x10, 0x4(SP)
    213            uartConfig.rx.maxBufSize        = 32;                // 2x30 don't care - see uart driver.
   \   00001A   B14020000C00 MOV.W   #0x20, 0xc(SP)
    214            uartConfig.tx.maxBufSize        = 254;               // 2x30 don't care - see uart driver.
   \   000020   B140FE001400 MOV.W   #0xfe, 0x14(SP)
    215            uartConfig.idleTimeout          = 6;                 // 2x30 don't care - see uart driver.
   \   000026   F14006000600 MOV.B   #0x6, 0x6(SP)
    216            uartConfig.intEnable            = TRUE;              // 2x30 don't care - see uart driver.
   \   00002C   D1431800     MOV.B   #0x1, 0x18(SP)
    217            uartConfig.callBackFunc         = pulseUartRx;
   \   000030   B140....1E00 MOV.W   #LWRD(pulseUartRx), 0x1e(SP)
   \   000036   B140....2000 MOV.W   #HWRD(pulseUartRx), 0x20(SP)
    218            HalUARTOpen(PULSE_PORT, &uartConfig);
   \   00003C   0D41         MOV.W   SP, R13
   \   00003E   0D53         ADD.W   #0x0, R13
   \   000040   4C43         MOV.B   #0x0, R12
   \   000042   ........     CALLA   #HalUARTOpen
    219          
    220              pulseDat[PULSE_TYP_IDX] = (uint8)PULSE_DEVICE_ID;
   \   000046   F2400600.... MOV.B   #0x6, &pulseDat + 19
    221              TestDatTx[MHMS_TEST_PAYLOAD_LEN - 3] = (uint8)PULSE_DEVICE_ID;
   \   00004C   F2400600.... MOV.B   #0x6, &TestDatTx + 47
    222          #if defined PULSE_SRC_RTG
    223          
    224              pulseDat[PULSE_OPT_IDX] = PULSE_OPT_SRC_RTG;
   \   000052   D243....     MOV.B   #0x1, &pulseDat + 20
    225          #endif
    226          
    227            pulseTaskId = id;                                    
   \   000056   C24A....     MOV.B   R10, &pulseTaskId
    228            pulseAddr = INVALID_NODE_ADDR;
   \   00005A   B240FEFF.... MOV.W   #0xfffe, &pulseAddr
    229            (void)afRegister((endPointDesc_t *)&PULSE_epDesc);  //MHMS registers endpoint object
   \   000060   3C40....     MOV.W   #PULSE_epDesc, R12
   \   000064   ........     CALLA   #afRegister
    230            
    231            //Initialize Px.y (5.0) to power Pulse sensor
    232            P5DIR = 0x1;  //Set IO direction as output
   \   000068   D2434402     MOV.B   #0x1, &0x244
    233            P5OUT = 0x1;  //Set output to high
   \   00006C   D2434202     MOV.B   #0x1, &0x242
    234           
    235            //Setup ADC reference 
    236            REFCTL0 = REFVSEL_2;  /* REF Reference Voltage Level Select 2.5V */
   \   000070   B2402000B001 MOV.W   #0x20, &0x1b0
    237          }
   \   000076   31502200     ADD.W   #0x22, SP
   \   00007A   3A41         POP.W   R10
   \   00007C   1001         RETA
   \   00007E                REQUIRE _A_PCDIR_L
   \   00007E                REQUIRE _A_PCOUT_L
   \   00007E                REQUIRE _A_REFCTL0_L
    238          
    239          /**************************************************************************************************
    240           * @fn          pulseAppEvt
    241           *
    242           * @brief       This function is called to process the OSAL events for the task.
    243           *
    244           * input parameters
    245           *
    246           * @param       id - OSAL task Id.
    247           * @param       evts - OSAL events bit mask of pending events.
    248           *
    249           * output parameters
    250           *
    251           * None.
    252           *
    253           * @return      evts - OSAL events bit mask of unprocessed events.
    254           **************************************************************************************************
    255           */

   \                                 In  segment CODE, align 2
    256          uint16 pulseAppEvt(uint8 id, uint16 evts)
   \                     pulseAppEvt:
    257          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   0A4D         MOV.W   R13, R10
    258            uint16 mask = 0;
    259            (void)id;  //MHMS casts a void to ignore warning for not using variable
    260            
    261            if (evts & SYS_EVENT_MSG)
   \   000004   0D93         CMP.W   #0x0, R13
   \   000006   1934         JGE     ??pulseAppEvt_3
    262            {
    263              mask = SYS_EVENT_MSG;
   \   000008   3B400080     MOV.W   #0x8000, R11
    264              pulseSysEvtMsg();
   \   00000C   053C         JMP     ??pulseAppEvt_4
   \                     ??pulseAppEvt_0:
   \   00000E   ........     CALLA   #pulseAfMsgRx
   \                     ??pulseAppEvt_1:
   \   000012   0C48         MOV.W   R8, R12
   \   000014   ........     CALLA   #osal_msg_deallocate
   \                     ??pulseAppEvt_4:
   \   000018   5C42....     MOV.B   &pulseTaskId, R12
   \   00001C   ........     CALLA   #osal_msg_receive
   \   000020   084C         MOV.W   R12, R8
   \   000022   0C93         CMP.W   #0x0, R12
   \   000024   3324         JEQ     ??pulseAppEvt_5
   \   000026   6E4C         MOV.B   @R12, R14
   \   000028   7E801A00     SUB.B   #0x1a, R14
   \   00002C   F027         JEQ     ??pulseAppEvt_0
   \   00002E   7E80B700     SUB.B   #0xb7, R14
   \   000032   EF23         JNE     ??pulseAppEvt_1
   \   000034   ........     CALLA   #pulseZdoStateChange
   \   000038   EC3F         JMP     ??pulseAppEvt_1
    265            }
    266          
    267            else if (evts & PULSE_EVT_ANN)
   \                     ??pulseAppEvt_3:
   \   00003A   3DB00040     BIT.W   #0x4000, R13
   \   00003E   0528         JNC     ??pulseAppEvt_6
    268            {
    269              mask = PULSE_EVT_ANN;
   \   000040   3B400040     MOV.W   #0x4000, R11
    270             pulseAnnce();
   \   000044   ........     CALLA   #pulseAnnce
   \   000048   213C         JMP     ??pulseAppEvt_5
    271            }
    272          
    273            else if (evts & PULSE_EVT_DAT)
   \                     ??pulseAppEvt_6:
   \   00004A   3DB00010     BIT.W   #0x1000, R13
   \   00004E   0528         JNC     ??pulseAppEvt_7
    274            {
    275              mask = PULSE_EVT_DAT;
   \   000050   3B400010     MOV.W   #0x1000, R11
    276              pulseDataCalc();
   \   000054   ........     CALLA   #pulseDataCalc
   \   000058   193C         JMP     ??pulseAppEvt_5
    277            }
    278            else if (evts & PULSE_EVT_REQ)
   \                     ??pulseAppEvt_7:
   \   00005A   3DB00020     BIT.W   #0x2000, R13
   \   00005E   0528         JNC     ??pulseAppEvt_8
    279            {
    280              mask = PULSE_EVT_REQ;
   \   000060   3B400020     MOV.W   #0x2000, R11
    281              pulseDataReq();
   \   000064   ........     CALLA   #pulseDataReq
   \   000068   113C         JMP     ??pulseAppEvt_5
    282            }
    283              else if (evts & PULSE_EVT_CHECKIN)
   \                     ??pulseAppEvt_8:
   \   00006A   3DB00008     BIT.W   #0x800, R13
   \   00006E   0528         JNC     ??pulseAppEvt_9
    284            {
    285              mask = PULSE_EVT_CHECKIN;
   \   000070   3B400008     MOV.W   #0x800, R11
    286              pulseNodeCheckIn();
   \   000074   ........     CALLA   #pulseNodeCheckIn
   \   000078   093C         JMP     ??pulseAppEvt_5
    287            }
    288          
    289          else if (evts & TEST_EVT_PAYLOAD_TX)
   \                     ??pulseAppEvt_9:
   \   00007A   3DB00004     BIT.W   #0x400, R13
   \   00007E   0528         JNC     ??pulseAppEvt_10
    290            {
    291              mask = TEST_EVT_PAYLOAD_TX;
   \   000080   3B400004     MOV.W   #0x400, R11
    292              TestPayloadTx();
   \   000084   ........     CALLA   #TestPayloadTx
   \   000088   013C         JMP     ??pulseAppEvt_5
    293            }
    294            else
    295            {
    296              mask = evts;  // Discard unknown events - should never happen.
   \                     ??pulseAppEvt_10:
   \   00008A   0B4D         MOV.W   R13, R11
    297            }
    298          
    299            return (evts ^ mask);  // Return unprocessed events.
   \                     ??pulseAppEvt_5:
   \   00008C   0AEB         XOR.W   R11, R10
   \   00008E   0C4A         MOV.W   R10, R12
   \   000090   3817         POPM.W  #0x4, R11
   \   000092   1001         RETA
    300          }
    301          
    302          
    303          //MHMS put coord stuff here, recieve func and sys
    304          
    305          
    306          
    307          /**************************************************************************************************
    308           * @fn          pulseSysEvtMsg
    309           *
    310           * @brief       This function is called by pulseAppEvt() to process all of the pending OSAL messages.
    311           *
    312           * input parameters
    313           *
    314           * None.
    315           *
    316           * output parameters
    317           *
    318           * None.
    319           *
    320           * @return      None.
    321           **************************************************************************************************
    322           */
    323          static void pulseSysEvtMsg(void)
    324          {
    325            uint8 *msg;
    326          
    327            while ((msg = osal_msg_receive(pulseTaskId)))
    328            {
    329              switch (*msg)
    330              {
    331          #if TVSA_DATA_CNF  //MHMS Question what is this for?
    332              case AF_DATA_CONFIRM_CMD:
    333                if (ZSuccess != ((afDataConfirm_t *)msg)->hdr.status)
    334                {
    335                  if (0 == ++pulseCnfErrCnt)
    336                  {
    337                    pulseCnfErrCnt = 255;
    338                  }
    339                }
    340                break;
    341          #endif
    342          
    343              case AF_INCOMING_MSG_CMD:  //MHMS this a router processing the incomming command from the coordinator
    344                pulseAfMsgRx((afIncomingMSGPacket_t *)msg);
    345                break;
    346          
    347              case ZDO_STATE_CHANGE:
    348                pulseZdoStateChange();
    349                break;
    350          
    351              default:
    352                break;
    353              }
    354          
    355              (void)osal_msg_deallocate(msg);  // Receiving task is responsible for releasing the memory.
    356            }
    357          }
    358          
    359          /**************************************************************************************************
    360           * @fn          pulseAfMsgRx
    361           *
    362           * @brief       This function is called by pulseSysEvtMsg() to process an incoming AF message.
    363           *
    364           * input parameters
    365           *
    366           * @param       msg - A pointer to the afIncomingMSGPacket_t packet.
    367           *
    368           * output parameters
    369           *
    370           * None.
    371           *
    372           * @return      None.
    373           **************************************************************************************************
    374           */

   \                                 In  segment CODE, align 2
   \                     ??Subroutine7_0:
   \   000000   5C42....     MOV.B   &pulseTaskId, R12
   \   000004   ........     BRA     #osal_set_event

   \                                 In  segment CODE, align 2
   \                     ?Subroutine10:
   \   000000   B290FEFF.... CMP.W   #0xfffe, &pulseAddr
   \   000006   1001         RETA

   \                                 In  segment CODE, align 2
    375          static void pulseAfMsgRx(afIncomingMSGPacket_t *msg)
   \                     pulseAfMsgRx:
    376          {
   \   000000   0A12         PUSH.W  R10
    377            uint8 *buf = msg->cmd.Data;
   \   000002   1A4C2400     MOV.W   0x24(R12), R10
    378          
    379            switch (buf[PULSE_CMD_IDX])
   \   000006   6E4A         MOV.B   @R10, R14
   \   000008   4E83         SUB.B   #0x0, R14
   \   00000A   0724         JEQ     ??pulseAfMsgRx_0
   \   00000C   5E83         SUB.B   #0x1, R14
   \   00000E   0824         JEQ     ??pulseAfMsgRx_1
   \   000010   5E83         SUB.B   #0x1, R14
   \   000012   1D24         JEQ     ??pulseAfMsgRx_2
   \   000014   5E83         SUB.B   #0x1, R14
   \   000016   2324         JEQ     ??pulseAfMsgRx_3
   \   000018   243C         JMP     ??pulseAfMsgRx_4
    380            {
    381          
    382            case PULSE_CMD_DAT:  //Nodes will send this by default
    383              pulseDataRx(msg);
   \                     ??pulseAfMsgRx_0:
   \   00001A   ........     CALLA   #pulseDataRx
    384              break;
   \   00001E   213C         JMP     ??pulseAfMsgRx_4
    385          
    386            case PULSE_CMD_BEG:
    387              if (INVALID_NODE_ADDR == pulseAddr)
   \                     ??pulseAfMsgRx_1:
   \   000020   ........     CALLA   #?Subroutine10
   \                     ??CrossCallReturnLabel_19:
   \   000024   0A20         JNE     ??pulseAfMsgRx_5
    388              {
    389                NLME_SetPollRate(0);
   \   000026   0C43         MOV.W   #0x0, R12
   \   000028   ........     CALLA   #NLME_SetPollRate
    390                if(PulseEvtDat_sync == FALSE){
   \   00002C   C293....     CMP.B   #0x0, &PulseEvtDat_sync
   \   000030   0420         JNE     ??pulseAfMsgRx_5
    391                (void)osal_set_event(pulseTaskId, PULSE_EVT_DAT);           //Sync Pulsedat event operation
   \   000032   3D400010     MOV.W   #0x1000, R13
   \   000036   ........     CALLA   #??Subroutine7_0
    392                //(void)osal_set_event(pulseTaskId, TEST_EVT_PAYLOAD_TX);   //For testing payload TX
    393                }
    394              }
    395              pulseAddr = BUILD_UINT16(buf[PULSE_ADR_LSB], buf[PULSE_ADR_MSB]);
   \                     ??pulseAfMsgRx_5:
   \   00003A   5E4A0100     MOV.B   0x1(R10), R14
   \   00003E   5F4A0200     MOV.B   0x2(R10), R15
   \   000042                RPT     #0x8
   \   000042   47180F5F     RLAX.W  R15
   \   000046   0E5F         ADD.W   R15, R14
   \   000048   824E....     MOV.W   R14, &pulseAddr
    396              break;
   \   00004C   0A3C         JMP     ??pulseAfMsgRx_4
    397          
    398            case PULSE_CMD_END:
    399              NLME_SetPollRate(POLL_RATE);
   \                     ??pulseAfMsgRx_2:
   \   00004E   3C40E803     MOV.W   #0x3e8, R12
   \   000052   ........     CALLA   #NLME_SetPollRate
    400              pulseAddr = INVALID_NODE_ADDR;
   \   000056   B240FEFF.... MOV.W   #0xfffe, &pulseAddr
    401              break;
   \   00005C   023C         JMP     ??pulseAfMsgRx_4
    402          
    403            case PULSE_CMD_DAT_TEST:  //This is used for testing different payload sizes. Not used in normal operation
    404              pulseTestingDataRx(msg);
   \                     ??pulseAfMsgRx_3:
   \   00005E   ........     CALLA   #pulseTestingDataRx
    405              break;
    406          
    407            default:
    408              break;
    409            }
    410          }
   \                     ??pulseAfMsgRx_4:
   \   000062   3A41         POP.W   R10
   \   000064   1001         RETA
    411          
    412          /**************************************************************************************************
    413           * @fn          pulseDataRx
    414           *
    415           * @brief       This function is called by pulseAfMsgRx() to process incoming PULSE data.
    416           *
    417           * input parameters
    418           *
    419           * @param       msg - A pointer to the afIncomingMSGPacket_t packet.
    420           *
    421           * output parameters
    422           *
    423           * None.
    424           *
    425           * @return      None.
    426           **************************************************************************************************
    427           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine0:
   \   000000   31501000     ADD.W   #0x10, SP
   \   000004   3817         POPM.W  #0x4, R11
   \   000006   1001         RETA

   \                                 In  segment CODE, align 2
    428          static void pulseDataRx(afIncomingMSGPacket_t *msg)
   \                     pulseDataRx:
    429          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   31801000     SUB.W   #0x10, SP
   \   000006   0B4C         MOV.W   R12, R11
    430            uint8 fcs = 0, idx;
   \   000008   4843         MOV.B   #0x0, R8
    431          
    432            // Last announce broadcast to stop must have expired before a parent could forward to a ZED.
    433            if (INVALID_NODE_ADDR == pulseAddr)
   \   00000A   ........     CALLA   #?Subroutine6
    434            {
    435              (void)osal_set_event(pulseTaskId, PULSE_EVT_ANN);
    436            }
    437          
    438            pulseBuf[PULSE_SOP_IDX] = PULSE_SOP_VAL;
   \                     ??CrossCallReturnLabel_8:
   \   00000E   F240FE00.... MOV.B   #0xfe, &pulseBuf
    439            pulseBuf[PULSE_ADR_LSB] = LO_UINT16(msg->srcAddr.addr.shortAddr);
   \   000014   0A4B         MOV.W   R11, R10
   \   000016   3A500600     ADD.W   #0x6, R10
   \   00001A   E24A....     MOV.B   @R10, &pulseBuf + 1
    440            pulseBuf[PULSE_ADR_MSB] = HI_UINT16(msg->srcAddr.addr.shortAddr);
   \   00001E   D24A0100.... MOV.B   0x1(R10), &pulseBuf + 2
    441          
    442            // 1st byte of message is skipped - CMD is always 0 for data.
    443            (void)osal_memcpy(pulseBuf+PULSE_DAT_OFF, msg->cmd.Data+1, PULSE_DAT_LEN-1);  //MHMS copies one buffer to another
   \   000024   3E401500     MOV.W   #0x15, R14
   \   000028   1D4B2400     MOV.W   0x24(R11), R13
   \   00002C   1D53         ADD.W   #0x1, R13
   \   00002E   3C40....     MOV.W   #pulseBuf + 3, R12
   \   000032   ........     CALLA   #osal_memcpy
    444          
    445            for (idx = PULSE_ADR_LSB; idx < PULSE_FCS_IDX; idx++)
   \   000036   5F43         MOV.B   #0x1, R15
    446            {
    447              fcs ^= pulseBuf[idx];
   \                     ??pulseDataRx_0:
   \   000038   58EF....     XOR.B   pulseBuf(R15), R8
    448            }
   \   00003C   5F53         ADD.B   #0x1, R15
   \   00003E   7F901800     CMP.B   #0x18, R15
   \   000042   FA2B         JNC     ??pulseDataRx_0
    449            pulseBuf[idx] = fcs;
   \   000044   CF48....     MOV.B   R8, pulseBuf(R15)
    450            
    451            uint8 deviceBPM;
    452            uint8 parentAddrLSB;
    453            uint8 parentAddrMSB;
    454            uint8 zsensorBuf[15];
    455            
    456            parentAddrLSB= pulseBuf[11];
   \   000048   5E42....     MOV.B   &pulseBuf + 11, R14
    457            parentAddrMSB= pulseBuf[12];  
   \   00004C   5F42....     MOV.B   &pulseBuf + 12, R15
    458            
    459            if(pulseBuf[13] == CHECK_IN_INACTIVE){
   \   000050   E293....     CMP.B   #0x2, &pulseBuf + 13
   \   000054   0320         JNE     ??pulseDataRx_2
    460            deviceBPM = pulseBuf[15];
   \   000056   5D42....     MOV.B   &pulseBuf + 15, R13
   \   00005A   023C         JMP     ??pulseDataRx_3
    461            }
    462            else{
    463            deviceBPM = 5;
   \                     ??pulseDataRx_2:
   \   00005C   7D400500     MOV.B   #0x5, R13
    464            }
    465            //deviceVolt = 0xFF;
    466            
    467            //Start of Frame Delimiter
    468            zsensorBuf[0]=0xFE;
   \                     ??pulseDataRx_3:
   \   000060   ........     CALLA   #?Subroutine5
    469            zsensorBuf[1]=10;
    470            zsensorBuf[2]=LO_UINT16(0x8746);
    471            zsensorBuf[3]=HI_UINT16(0x8746);
    472            
    473            //Source Address
    474            zsensorBuf[4] = LO_UINT16(msg->srcAddr.addr.shortAddr);
   \                     ??CrossCallReturnLabel_6:
   \   000064   E14A0400     MOV.B   @R10, 0x4(SP)
    475            zsensorBuf[5] = HI_UINT16(msg->srcAddr.addr.shortAddr);
   \   000068   D14A01000500 MOV.B   0x1(R10), 0x5(SP)
    476            
    477            zsensorBuf[6]=LO_UINT16(2);  //MHMS are 6 - 9 being used for anything?
   \   00006E   ........     CALLA   #?Subroutine2
    478            zsensorBuf[7]=HI_UINT16(2);
    479            zsensorBuf[8]=LO_UINT16(4);
    480            zsensorBuf[9]=HI_UINT16(4);
    481            
    482            //Temperature and Voltage Data
    483            zsensorBuf[10]= deviceBPM;
    484            zsensorBuf[11]= deviceBPM; //deviceVolt;
    485            
    486            //Parent Address
    487            zsensorBuf[12]=parentAddrLSB;
    488            zsensorBuf[13]=parentAddrMSB;
    489          
    490          
    491            //FCS Check on the middle 13 bytes
    492            zsensorBuf[14] = calcFCS(&zsensorBuf[1], 13 );
    493          
    494            HalUARTWrite(PULSE_PORT, zsensorBuf, 15);  //For communicating with the Zigbee sensor Monitor
    495            
    496          /*  //MHMS USB communication with Pulse sensor Processor application
    497          
    498            uint8 BPMBuf[7] = {'B',0,0,0,10,13};
    499            uint8 IBIBuf[7] = {'Q',0,0,0,10,13};
    500            uint8 SignalBuf[7] = {'S',0,0,0,10,13};
    501            
    502            //conversion Signal Dec to ASCII
    503            uint16 temp = (BUILD_UINT16(pulseBuf[16], pulseBuf[17])) - 400;
    504            if(temp > 999){
    505              SignalBuf[1] = '9';
    506              SignalBuf[2] = '9';
    507              SignalBuf[3] = '9';
    508            }
    509            else { 
    510              SignalBuf[1] = (uint8)((temp/100)+ 48);
    511              SignalBuf[2] = (uint8)((((temp%100) - (temp % 100)%10)/10) + 48);
    512              SignalBuf[3] = (uint8)(((temp % 100)%10)+ 48);
    513            }
    514            
    515            //conversion BPM Dec to ASCII
    516            temp = (uint16)pulseBuf[14];
    517            BPMBuf[1] = (uint8)((temp/100)+ 48);
    518            BPMBuf[2] = (uint8)((((temp%100) - (temp % 100)%10)/10) + 48);
    519            BPMBuf[3] = (uint8)(((temp % 100)%10)+ 48);
    520            
    521            //conversion IBI Dec to ASCII
    522            temp = (uint16)pulseBuf[19];
    523            IBIBuf[1] = (uint8)((temp/100)+ 48);
    524            IBIBuf[2] = (uint8)((((temp%100) - (temp % 100)%10)/10) + 48);
    525            IBIBuf[3] = (uint8)(((temp % 100)%10)+ 48);
    526             
    527          
    528            //HalUARTWrite(PULSE_PORT, SignalBuf, 6);
    529           // HalUARTWrite(PULSE_PORT, BPMBuf, 6);
    530           // HalUARTWrite(PULSE_PORT, IBIBuf, 6);
    531          */
    532          
    533          }
   \                     ??CrossCallReturnLabel_0:
   \   000072   ....         JMP     ?Subroutine0
   \   000074   0343         NOP

   \                                 In  segment CODE, align 2
   \                     ?Subroutine6:
   \   000000   B290FEFF.... CMP.W   #0xfffe, &pulseAddr
   \   000006   0620         JNE     ??pulseTestingDataRx_1
   \   000008   3D400040     MOV.W   #0x4000, R13
   \   00000C   5C42....     MOV.B   &pulseTaskId, R12
   \   000010   ........     CALLA   #osal_set_event
   \                     ??pulseTestingDataRx_1:
   \   000014   1001         RETA

   \                                 In  segment CODE, align 2
   \                     ?Subroutine5:
   \   000000   F140FE000400 MOV.B   #0xfe, 0x4(SP)
   \   000006   F1400A000500 MOV.B   #0xa, 0x5(SP)
   \   00000C   F14046000600 MOV.B   #0x46, 0x6(SP)
   \   000012   F14087000700 MOV.B   #0x87, 0x7(SP)
   \   000018   1001         RETA

   \                                 In  segment CODE, align 2
   \                     ?Subroutine2:
   \   000000   E1430A00     MOV.B   #0x2, 0xa(SP)
   \   000004   C1430B00     MOV.B   #0x0, 0xb(SP)
   \   000008   E1420C00     MOV.B   #0x4, 0xc(SP)
   \   00000C   C1430D00     MOV.B   #0x0, 0xd(SP)
   \   000010   C14D0E00     MOV.B   R13, 0xe(SP)
   \   000014   C14D0F00     MOV.B   R13, 0xf(SP)
   \   000018   C14E1000     MOV.B   R14, 0x10(SP)
   \   00001C   C14F1100     MOV.B   R15, 0x11(SP)
   \   000020   7D400D00     MOV.B   #0xd, R13
   \   000024   0C41         MOV.W   SP, R12
   \   000026   3C500500     ADD.W   #0x5, R12
   \   00002A   ........     CALLA   #calcFCS
   \   00002E   C14C1200     MOV.B   R12, 0x12(SP)
   \   000032   3E400F00     MOV.W   #0xf, R14
   \   000036   0D41         MOV.W   SP, R13
   \   000038   2D52         ADD.W   #0x4, R13
   \   00003A   4C43         MOV.B   #0x0, R12
   \   00003C   ........     BRA     #HalUARTWrite
    534          
    535          /**************************************************************************************************
    536           * @fn          pulseTestingDataRx
    537           *
    538           * @brief       This function is called by pulseAfMsgRx() to process incoming data  This is not used in 
    539           *              normal operation.  This is used for testing system with differnt payload sizes.
    540           * input parameters
    541           *
    542           * @param       msg - A pointer to the afIncomingMSGPacket_t packet.
    543           *
    544           * output parameters
    545           *
    546           * None.
    547           *
    548           * @return      None.
    549           **************************************************************************************************
    550           */

   \                                 In  segment CODE, align 2, keep-with-next
    551          static void pulseTestingDataRx(afIncomingMSGPacket_t *msg)
   \                     pulseTestingDataRx:
    552          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   31801000     SUB.W   #0x10, SP
   \   000006   094C         MOV.W   R12, R9
    553             uint8 fcs = 0, idx;
   \   000008   4B43         MOV.B   #0x0, R11
    554            
    555             uint8 *TestRxBuffer;
    556             
    557             TestRxBuffer = (uint8*)osal_mem_alloc(MHMS_TEST_PAYLOAD_LEN);
   \   00000A   3C403200     MOV.W   #0x32, R12
   \   00000E   ........     CALLA   #osal_mem_alloc
   \   000012   0A4C         MOV.W   R12, R10
    558              
    559          
    560            // Last announce broadcast to stop must have expired before a parent could forward to a ZED.
    561            if (INVALID_NODE_ADDR == pulseAddr)
   \   000014   ........     CALLA   #?Subroutine6
    562            {
    563              (void)osal_set_event(pulseTaskId, PULSE_EVT_ANN);
    564            }
    565          
    566            TestRxBuffer[PULSE_SOP_IDX] = PULSE_SOP_VAL;
   \                     ??CrossCallReturnLabel_7:
   \   000018   FA40FE000000 MOV.B   #0xfe, 0(R10)
    567            TestRxBuffer[PULSE_ADR_LSB] = LO_UINT16(msg->srcAddr.addr.shortAddr);
   \   00001E   0849         MOV.W   R9, R8
   \   000020   38500600     ADD.W   #0x6, R8
   \   000024   EA480100     MOV.B   @R8, 0x1(R10)
    568            TestRxBuffer[PULSE_ADR_MSB] = HI_UINT16(msg->srcAddr.addr.shortAddr);
   \   000028   DA4801000200 MOV.B   0x1(R8), 0x2(R10)
    569          
    570            // 1st byte of message is skipped - CMD is always 0 for data.
    571            (void)osal_memcpy(TestRxBuffer+PULSE_DAT_OFF, msg->cmd.Data+1, MHMS_TEST_PAYLOAD_LEN-1);  //MHMS copies one buffer to another
   \   00002E   3E403100     MOV.W   #0x31, R14
   \   000032   1D492400     MOV.W   0x24(R9), R13
   \   000036   1D53         ADD.W   #0x1, R13
   \   000038   0C4A         MOV.W   R10, R12
   \   00003A   3C500300     ADD.W   #0x3, R12
   \   00003E   ........     CALLA   #osal_memcpy
    572          
    573            for (idx = PULSE_ADR_LSB; idx < MHMS_FCS_IDX; idx++)
   \   000042   5E43         MOV.B   #0x1, R14
    574            {
    575              fcs ^= TestRxBuffer[idx];
   \                     ??pulseTestingDataRx_0:
   \   000044   0F4A         MOV.W   R10, R15
   \   000046   0F5E         ADD.W   R14, R15
   \   000048   6BEF         XOR.B   @R15, R11
    576            }
   \   00004A   5E53         ADD.B   #0x1, R14
   \   00004C   7E903400     CMP.B   #0x34, R14
   \   000050   F92B         JNC     ??pulseTestingDataRx_0
    577            TestRxBuffer[idx] = fcs;
   \   000052   0F4A         MOV.W   R10, R15
   \   000054   0F5E         ADD.W   R14, R15
   \   000056   CF4B0000     MOV.B   R11, 0(R15)
    578            
    579            uint8 PktSeqNum; 
    580            
    581            uint8 parentAddrLSB;
    582            uint8 parentAddrMSB;
    583            uint8 zsensorBuf[15];
    584            
    585            parentAddrLSB= TestRxBuffer[11];
   \   00005A   5E4A0B00     MOV.B   0xb(R10), R14
    586            parentAddrMSB= TestRxBuffer[12];  
   \   00005E   5F4A0C00     MOV.B   0xc(R10), R15
    587            
    588            PktSeqNum = TestRxBuffer[13];
   \   000062   5D4A0D00     MOV.B   0xd(R10), R13
    589            
    590            //Start of Frame Delimiter
    591            zsensorBuf[0]=0xFE;
   \   000066   ........     CALLA   #?Subroutine5
    592            zsensorBuf[1]=10;
    593            zsensorBuf[2]=LO_UINT16(0x8746);
    594            zsensorBuf[3]=HI_UINT16(0x8746);
    595            
    596            //Source Address
    597            zsensorBuf[4] = LO_UINT16(msg->srcAddr.addr.shortAddr);
   \                     ??CrossCallReturnLabel_5:
   \   00006A   E1480400     MOV.B   @R8, 0x4(SP)
    598            zsensorBuf[5] = HI_UINT16(msg->srcAddr.addr.shortAddr);
   \   00006E   D14801000500 MOV.B   0x1(R8), 0x5(SP)
    599            
    600            zsensorBuf[6]=LO_UINT16(2);  //MHMS are 6 - 9 being used for anything?
   \   000074   ........     CALLA   #?Subroutine2
    601            zsensorBuf[7]=HI_UINT16(2);
    602            zsensorBuf[8]=LO_UINT16(4);
    603            zsensorBuf[9]=HI_UINT16(4);
    604            
    605            //Temperature and Voltage Data
    606            zsensorBuf[10]= PktSeqNum;
    607            zsensorBuf[11]= PktSeqNum; //deviceVolt;
    608            
    609            //Parent Address
    610            zsensorBuf[12]= parentAddrLSB;
    611            zsensorBuf[13]= parentAddrMSB;
    612          
    613          
    614            //FCS Check on the middle 13 bytes
    615            zsensorBuf[14] = calcFCS(&zsensorBuf[1], 13 );
    616          
    617            HalUARTWrite(PULSE_PORT, zsensorBuf, 15);  //For communicating with the Zigbee sensor Monitor
    618            
    619            osal_mem_free(TestRxBuffer);
   \                     ??CrossCallReturnLabel_1:
   \   000078   0C4A         MOV.W   R10, R12
   \   00007A   ........     CALLA   #osal_mem_free
    620          }
   \   00007E                REQUIRE ?Subroutine0
   \   00007E                // Fall through to label ?Subroutine0
    621          
    622          
    623          /**************************************************************************************************
    624           * @fn          pulseZdoStateChange 
    625           *
    626           * @brief       This function is called by pulseSysEvtMsg() for a ZDO_STATE_CHANGE message.
    627           *
    628           * input parameters
    629           *
    630           * None.
    631           *
    632           * output parameters
    633           *
    634           * None.
    635           *
    636           * @return      None.
    637           **************************************************************************************************
    638           */

   \                                 In  segment CODE, align 2
    639          static void pulseZdoStateChange(void)
   \                     pulseZdoStateChange:
    640          {
   \   000000   3B15         PUSHM.W #0x4, R11
    641            if(DEV_ZB_COORD == devState) 
   \   000002   5E42....     MOV.B   &devState, R14
   \   000006   7A400700     MOV.B   #0x7, R10
   \   00000A   3B40....     MOV.W   #pulseTaskId, R11
   \   00000E   7E900900     CMP.B   #0x9, R14
   \   000012   2320         JNE     ??pulseZdoStateChange_0
    642            {
    643              (void)osal_stop_timerEx(pulseTaskId, PULSE_EVT_ANN);
   \   000014   3D400040     MOV.W   #0x4000, R13
   \   000018   6C4B         MOV.B   @R11, R12
   \   00001A   ........     CALLA   #osal_stop_timerEx
    644          
    645              if ((DEV_ZB_COORD == devState) || (DEV_ROUTER == devState) || (DEV_END_DEVICE == devState))
   \   00001E   5E42....     MOV.B   &devState, R14
   \   000022   7E900900     CMP.B   #0x9, R14
   \   000026   0524         JEQ     ??pulseZdoStateChange_1
   \   000028   4E9A         CMP.B   R10, R14
   \   00002A   0324         JEQ     ??pulseZdoStateChange_1
   \   00002C   7E900600     CMP.B   #0x6, R14
   \   000030   6F20         JNE     ??pulseZdoStateChange_2
    646              {
    647          
    648                if (INVALID_NODE_ADDR == pulseAddr)
   \                     ??pulseZdoStateChange_1:
   \   000032   ........     CALLA   #?Subroutine10
   \                     ??CrossCallReturnLabel_17:
   \   000036   0220         JNE     ??pulseZdoStateChange_3
    649                {
    650                pulseAddr = NWK_PAN_COORD_ADDR;
   \   000038   8243....     MOV.W   #0x0, &pulseAddr
    651                }
    652          
    653          
    654                if (INVALID_NODE_ADDR != pulseAddr)
    655                {
    656                  if (ZSuccess != osal_start_timerEx(pulseTaskId, PULSE_EVT_ANN, PULSE_DLY_ANN))
   \                     ??pulseZdoStateChange_3:
   \   00003C   3E408813     MOV.W   #0x1388, R14
   \   000040   3D400040     MOV.W   #0x4000, R13
   \   000044   6C4B         MOV.B   @R11, R12
   \   000046   ........     CALLA   #osal_start_timerEx
   \   00004A   4C93         CMP.B   #0x0, R12
   \   00004C   6124         JEQ     ??pulseZdoStateChange_2
    657                  {
    658                    (void)osal_set_event(pulseTaskId, PULSE_EVT_ANN);
   \   00004E   3D400040     MOV.W   #0x4000, R13
   \   000052   6C4B         MOV.B   @R11, R12
   \   000054   ........     CALLA   #osal_set_event
   \   000058   5B3C         JMP     ??pulseZdoStateChange_2
    659                  }
    660                }
    661              }
    662            }
    663            else if ((DEV_ROUTER == devState) || (DEV_END_DEVICE == devState))
   \                     ??pulseZdoStateChange_0:
   \   00005A   4E9A         CMP.B   R10, R14
   \   00005C   0324         JEQ     ??pulseZdoStateChange_4
   \   00005E   7E900600     CMP.B   #0x6, R14
   \   000062   5620         JNE     ??pulseZdoStateChange_2
    664            {
    665              (void)osal_stop_timerEx(pulseTaskId, PULSE_EVT_DAT);
   \                     ??pulseZdoStateChange_4:
   \   000064   3D400010     MOV.W   #0x1000, R13
   \   000068   6C4B         MOV.B   @R11, R12
   \   00006A   ........     CALLA   #osal_stop_timerEx
    666              PulseEvtDat_sync = FALSE; //allow node to respond to Anounce commands to begin pulse collection
   \   00006E   C243....     MOV.B   #0x0, &PulseEvtDat_sync
    667          
    668                  if ((DEV_ROUTER == devState) || (DEV_END_DEVICE == devState)) //
   \   000072   C29A....     CMP.B   R10, &devState
   \   000076   0424         JEQ     ??pulseZdoStateChange_5
   \   000078   F2900600.... CMP.B   #0x6, &devState
   \   00007E   4820         JNE     ??pulseZdoStateChange_2
    669                  {
    670                    uint16 tmp = NLME_GetCoordShortAddr();
   \                     ??pulseZdoStateChange_5:
   \   000080   ........     CALLA   #NLME_GetCoordShortAddr
   \   000084   084C         MOV.W   R12, R8
    671                    uint8 dly = PULSE_STG_DAT;
   \   000086   ........     CALLA   #Onboard_rand
   \   00008A   0D43         MOV.W   #0x0, R13
   \   00008C   3E40E803     MOV.W   #0x3e8, R14
   \   000090   0F43         MOV.W   #0x0, R15
   \   000092   ........     CALLA   #?Mul32
   \   000096   4E4D         MOV.B   R13, R14
    672          
    673                    pulseDat[PULSE_PAR_LSB] = LO_UINT16(tmp);
   \   000098   C248....     MOV.B   R8, &pulseDat + 9
   \   00009C   0F48         MOV.W   R8, R15
   \   00009E                RPT     #0x8
   \   00009E   47190F10     RRUX.W  R15
   \   0000A2   C24F....     MOV.B   R15, &pulseDat + 10
    674                    pulseDat[PULSE_PAR_MSB] = HI_UINT16(tmp);
    675                    
    676                    TestDatTx[PULSE_PAR_LSB] = LO_UINT16(tmp);
   \   0000A6   C248....     MOV.B   R8, &TestDatTx + 9
    677                    TestDatTx[PULSE_PAR_MSB] = HI_UINT16(tmp);
   \   0000AA   C24F....     MOV.B   R15, &TestDatTx + 10
    678                    if ((DEV_ROUTER == devState) || (DEV_ZB_COORD == devState))
   \   0000AE   C29A....     CMP.B   R10, &devState
   \   0000B2   0424         JEQ     ??pulseZdoStateChange_6
   \   0000B4   F2900900.... CMP.B   #0x9, &devState
   \   0000BA   0720         JNE     ??pulseZdoStateChange_7
    679                    {
    680                      pulseDat[PULSE_TYP_IDX] |= 0x80;
   \                     ??pulseZdoStateChange_6:
   \   0000BC   F2D08000.... BIS.B   #0x80, &pulseDat + 19
    681                      TestDatTx[MHMS_TEST_PAYLOAD_LEN-3] |= 0x80;
   \   0000C2   F2D08000.... BIS.B   #0x80, &TestDatTx + 47
   \   0000C8   063C         JMP     ??pulseZdoStateChange_8
    682          
    683                    }
    684                    else
    685                    {
    686                      pulseDat[PULSE_TYP_IDX] &= (0xFF ^ 0x80);
   \                     ??pulseZdoStateChange_7:
   \   0000CA   F2C08000.... BIC.B   #0x80, &pulseDat + 19
    687                      TestDatTx[MHMS_TEST_PAYLOAD_LEN-3] &= (0xFF ^ 0x80);
   \   0000D0   F2C08000.... BIC.B   #0x80, &TestDatTx + 47
    688          
    689                    }
    690          
    691                #if TVSA_DONGLE_IS_ZC  //MHMS do we need this?
    692                    if (INVALID_NODE_ADDR == pulseAddr)
    693                    {
    694                      // Assume ZC is the TVSA Dongle until a TVSA_CMD_BEG gives a different address.
    695                      pulseAddr = NWK_PAN_COORD_ADDR;
    696                    }
    697                #endif
    698          
    699                    if (INVALID_NODE_ADDR != pulseAddr)
   \                     ??pulseZdoStateChange_8:
   \   0000D6   ........     CALLA   #?Subroutine10
   \                     ??CrossCallReturnLabel_18:
   \   0000DA   0E24         JEQ     ??pulseZdoStateChange_9
    700                    {
    701                      if (ZSuccess != osal_start_timerEx(pulseTaskId, PULSE_EVT_DAT, (dly + PULSE_DLY_MIN)))
   \   0000DC   3E508813     ADD.W   #0x1388, R14
   \   0000E0   3D400010     MOV.W   #0x1000, R13
   \   0000E4   6C4B         MOV.B   @R11, R12
   \   0000E6   ........     CALLA   #osal_start_timerEx
   \   0000EA   4C93         CMP.B   #0x0, R12
   \   0000EC   0524         JEQ     ??pulseZdoStateChange_9
    702                      {
    703                        (void)osal_set_event(pulseTaskId, PULSE_EVT_DAT);
   \   0000EE   3D400010     MOV.W   #0x1000, R13
   \   0000F2   6C4B         MOV.B   @R11, R12
   \   0000F4   ........     CALLA   #osal_set_event
    704                      }
    705                    }
    706          
    707          
    708                    if (0 == 0)
    709                    {
    710                      (void)osal_cpyExtAddr(pulseDat+PULSE_IEE_IDX, &aExtendedAddress);
   \                     ??pulseZdoStateChange_9:
   \   0000F8   3D40....     MOV.W   #znpIEEE, R13
   \   0000FC   3C40....     MOV.W   #pulseDat + 1, R12
   \   000100   ........     CALLA   #sAddrExtCpy
    711                      (void)osal_cpyExtAddr(TestDatTx+PULSE_IEE_IDX, &aExtendedAddress);
   \   000104   3D40....     MOV.W   #znpIEEE, R13
   \   000108   3C40....     MOV.W   #TestDatTx + 1, R12
   \   00010C   ........     CALLA   #sAddrExtCpy
    712                    }
    713                  }
    714            }
    715               
    716              
    717          
    718          #if defined LCD_SUPPORTED
    719            HalLcdWriteValue(devState, 10, HAL_LCD_LINE_4);
   \                     ??pulseZdoStateChange_2:
   \   000110   6F42         MOV.B   #0x4, R15
   \   000112   7E400A00     MOV.B   #0xa, R14
   \   000116   5C42....     MOV.B   &devState, R12
   \   00011A   0D43         MOV.W   #0x0, R13
   \   00011C   ........     CALLA   #HalLcdWriteValue
    720          #endif
    721          }
   \   000120   3817         POPM.W  #0x4, R11
   \   000122   1001         RETA
    722          
    723          
    724          /**************************************************************************************************
    725           * @fn          pulseAnnce
    726           *
    727           * @brief       This function is called by pulseAppEvt() to send a TVSA announce to start or stop.
    728           *
    729           * input parameters
    730           *
    731           * None.
    732           *
    733           * output parameters
    734           *
    735           * None.
    736           *
    737           * @return      None.
    738           **************************************************************************************************
    739           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine7:
   \   000000   3D400040     MOV.W   #0x4000, R13
   \   000004                REQUIRE ??Subroutine7_0
   \   000004                // Fall through to label ??Subroutine7_0

   \                                 In  segment CODE, align 2
   \                     ?Subroutine9:
   \   000000   5C42....     MOV.B   &pulseTaskId, R12
   \   000004   ........     BRA     #osal_start_timerEx

   \                                 In  segment CODE, align 2
    740          static void pulseAnnce(void)
   \                     pulseAnnce:
    741          {
   \   000000   31801000     SUB.W   #0x10, SP
    742            uint8 msg[3];
    743            afAddrType_t addr;
    744            
    745            addr.addr.shortAddr = NWK_BROADCAST_SHORTADDR_DEVALL;
   \   000004   B1430400     MOV.W   #0xffff, 0x4(SP)
    746            addr.addrMode = afAddrBroadcast;
   \   000008   F1400F000C00 MOV.B   #0xf, 0xc(SP)
    747            addr.endPoint = PULSE_ENDPOINT;
   \   00000E   F14003000D00 MOV.B   #0x3, 0xd(SP)
    748          
    749            if (INVALID_NODE_ADDR != pulseAddr)
   \   000014   ........     CALLA   #?Subroutine10
   \                     ??CrossCallReturnLabel_16:
   \   000018   0D24         JEQ     ??pulseAnnce_0
    750            {
    751              msg[PULSE_CMD_IDX] = PULSE_CMD_BEG;
   \   00001A   D1430000     MOV.B   #0x1, 0(SP)
    752              if (ZSuccess != osal_start_timerEx(pulseTaskId, PULSE_EVT_ANN, PULSE_DLY_ANN))
   \   00001E   3E408813     MOV.W   #0x1388, R14
   \   000022   3D400040     MOV.W   #0x4000, R13
   \   000026   ........     CALLA   #?Subroutine9
   \                     ??CrossCallReturnLabel_11:
   \   00002A   4C93         CMP.B   #0x0, R12
   \   00002C   0524         JEQ     ??pulseAnnce_1
    753              {
    754                (void)osal_set_event(pulseTaskId, PULSE_EVT_ANN);
   \   00002E   ........     CALLA   #?Subroutine7
    755              }
    756            }
   \                     ??CrossCallReturnLabel_29:
   \   000032   023C         JMP     ??pulseAnnce_1
    757            else
    758            {
    759              msg[PULSE_CMD_IDX] = PULSE_CMD_END;
   \                     ??pulseAnnce_0:
   \   000034   E1430000     MOV.B   #0x2, 0(SP)
    760            }
    761          
    762            msg[PULSE_ADR_LSB] = LO_UINT16(pulseAddr);
   \                     ??pulseAnnce_1:
   \   000038   D142....0100 MOV.B   &pulseAddr, 0x1(SP)
    763            msg[PULSE_ADR_MSB] = HI_UINT16(pulseAddr);
   \   00003E   D142....0200 MOV.B   &pulseAddr + 1, 0x2(SP)
    764          
    765            if (afStatus_SUCCESS != AF_DataRequest(&addr, (endPointDesc_t *)&PULSE_epDesc, PULSE_CLUSTER_ID,
    766                                                    3, msg, &pulseTSN, AF_TX_OPTIONS_NONE, AF_DEFAULT_RADIUS))
   \   000044   70121E00     PUSH.B  #0x1e
   \   000048   4312         PUSH.B  #0x0
   \   00004A   3012....     PUSH.W  #pulseTSN
   \   00004E   0F41         MOV.W   SP, R15
   \   000050   3F500600     ADD.W   #0x6, R15
   \   000054   0F12         PUSH.W  R15
   \   000056   3F400300     MOV.W   #0x3, R15
   \   00005A   ........     CALLA   #?Subroutine11
   \                     ??CrossCallReturnLabel_23:
   \   00005E   ........     CALLA   #AF_DataRequest
   \   000062   3152         ADD.W   #0x8, SP
   \   000064   4C93         CMP.B   #0x0, R12
   \   000066   0324         JEQ     ??pulseAnnce_2
    767            {
    768              osal_set_event(pulseTaskId, PULSE_EVT_ANN);
   \   000068   ........     CALLA   #?Subroutine7
    769            }
   \                     ??CrossCallReturnLabel_28:
   \   00006C   023C         JMP     ??pulseAnnce_3
    770            else
    771            {
    772              pulseCnt++;
   \                     ??pulseAnnce_2:
   \   00006E   9253....     ADD.W   #0x1, &pulseCnt
    773            }
    774          }
   \                     ??pulseAnnce_3:
   \   000072   31501000     ADD.W   #0x10, SP
   \   000076   1001         RETA

   \                                 In  segment CODE, align 2
   \                     ?Subroutine11:
   \   000000   2E43         MOV.W   #0x2, R14
   \   000002   3D40....     MOV.W   #PULSE_epDesc, R13
   \   000006   0C41         MOV.W   SP, R12
   \   000008   3C501000     ADD.W   #0x10, R12
   \   00000C   1001         RETA
    775          
    776          
    777          /**************************************************************************************************
    778           * @fn          pulseDataCalc
    779           *
    780           * @brief       This function is called by pulseAppEvt() to calculate the data for a PULSE report.
    781           *              The function will called on a 2ms interval and detect whether a pulse is being measured.
    782           *              If a pulse is determined it will invoke the PulsedataReq interrupt timer (20ms intervals)
    783           *
    784           * input parameters
    785           *
    786           * None.
    787           *
    788           * output parameters
    789           *
    790           * None.
    791           *
    792           * @return      None.
    793           **************************************************************************************************
    794           */

   \                                 In  segment CODE, align 2
    795          static void pulseDataCalc(void)
   \                     pulseDataCalc:
    796          {
   \   000000   0A12         PUSH.W  R10
    797            PulseEvtDat_sync = TRUE;      //Pulse Data collection has been synced, no need to respond to annc commands to set EVT
   \   000002   D243....     MOV.B   #0x1, &PulseEvtDat_sync
    798            
    799            if (INVALID_NODE_ADDR == pulseAddr)
   \   000006   ........     CALLA   #?Subroutine10
   \                     ??CrossCallReturnLabel_15:
   \   00000A   2C24         JEQ     ??pulseDataCalc_0
    800            {
    801              return;
    802            }
    803            
    804            if (ZSuccess != osal_start_timerEx(pulseTaskId, PULSE_EVT_DAT, PULSE_DLY_DAT))  //If the timer can't be started set event flag again for it to be service again
   \   00000C   3A40....     MOV.W   #pulseTaskId, R10
   \   000010   3E40E803     MOV.W   #0x3e8, R14
   \   000014   3D400010     MOV.W   #0x1000, R13
   \   000018   6C4A         MOV.B   @R10, R12
   \   00001A   ........     CALLA   #osal_start_timerEx
   \   00001E   4C93         CMP.B   #0x0, R12
   \   000020   0524         JEQ     ??pulseDataCalc_1
    805            {
    806              (void)osal_set_event(pulseTaskId, PULSE_EVT_DAT);
   \   000022   3D400010     MOV.W   #0x1000, R13
   \   000026   6C4A         MOV.B   @R10, R12
   \   000028   ........     CALLA   #osal_set_event
    807            }
    808            pulseBPM(pulseDat);  //Function to collect/calculate Pulse
   \                     ??pulseDataCalc_1:
   \   00002C   3C40....     MOV.W   #pulseDat, R12
   \   000030   ........     CALLA   #pulseBPM
    809          
    810          #if TVSA_DATA_CNF
    811            pulseDat[PULSE_RTG_IDX] = pulseCnfErrCnt;
    812          #else
    813            pulseDat[PULSE_RTG_IDX] = 0;
   \   000034   C243....     MOV.B   #0x0, &pulseDat + 21
    814          #endif
    815          
    816            if(QS == TRUE && PulseEvtReq_sync == FALSE){//If pulse is being measured synchronize pulsedatareq event
   \   000038   D293....     CMP.B   #0x1, &QS
   \   00003C   0920         JNE     ??pulseDataCalc_2
   \   00003E   C293....     CMP.B   #0x0, &PulseEvtReq_sync
   \   000042   0620         JNE     ??pulseDataCalc_2
    817            osal_set_event(pulseTaskId, PULSE_EVT_REQ);
   \   000044   3D400020     MOV.W   #0x2000, R13
   \   000048   6C4A         MOV.B   @R10, R12
   \   00004A   ........     CALLA   #osal_set_event
   \   00004E   0A3C         JMP     ??pulseDataCalc_0
    818              }  
    819            else if(PulseEvtCheckin_sync == FALSE)
   \                     ??pulseDataCalc_2:
   \   000050   C293....     CMP.B   #0x0, &PulseEvtCheckin_sync
   \   000054   0720         JNE     ??pulseDataCalc_0
    820            {
    821            osal_set_event(pulseTaskId, PULSE_EVT_CHECKIN);  //Since no pulse data is being collect, just send check in data to coordinator
   \   000056   3D400008     MOV.W   #0x800, R13
   \   00005A   6C4A         MOV.B   @R10, R12
   \   00005C   ........     CALLA   #osal_set_event
    822            PulseEvtCheckin_sync = TRUE;
   \   000060   D243....     MOV.B   #0x1, &PulseEvtCheckin_sync
   \                     ??pulseDataCalc_0:
   \   000064   3A41         POP.W   R10
   \   000066   1001         RETA
    823            }
    824           
    825          }
    826          
    827          /**************************************************************************************************
    828           * @fn          pulseBPM
    829           *
    830           * @brief       This function is called by pulseDataCalc().  This function contains the main algorithm for pulse calculation.
    831           *
    832           *
    833           * input parameters
    834           *
    835           * Pointer to the pulsedata array that will be sent over the air.
    836           *
    837           * output parameters
    838           *
    839           * None.
    840           *
    841           * @return      None.
    842           **************************************************************************************************/

   \                                 In  segment CODE, align 2
    843          static void pulseBPM(uint8 *pulsedata)
   \                     pulseBPM:
    844          {
   \   000000   7B15         PUSHM.W #0x8, R11
   \   000002   0A4C         MOV.W   R12, R10
    845          
    846          //MHMS 
    847          //MHMS From arduino interrupt
    848          static volatile int rate[10];                    // used to hold last ten IBI values
    849          static volatile uint32 sampleCounter = 0;          // used to determine pulse timing
    850          static volatile uint32 lastBeatTime = 0;           // used to find the inter beat interval
    851          static volatile int P = 512;                      // used to find peak in pulse wave
    852          static volatile int T = 512;                     // used to find trough in pulse wave
    853          static volatile int thresh = 512;                // used to find instant moment of heart beat
    854          static volatile int amp = 100;                   // used to hold amplitude of pulse waveform
    855          static volatile bool firstBeat = TRUE;        // used to seed rate array so we startup with reasonable BPM
    856          static volatile bool secondBeat = TRUE;       // used to seed rate array so we startup with reasonable BPM
    857            
    858          int BPM = pulsedata[PULSE_BPM];                         // used to hold the pulse rate
   \   000004   574C0D00     MOV.B   0xd(R12), R7
    859          int Signal;                                             // holds the incoming raw data
    860          int IBI = pulsedata[PULSE_IBI];                         // holds the time between beats, the Inter-Beat Interval
   \   000008   584C1200     MOV.B   0x12(R12), R8
    861          
    862          //    cli();                                            // disable interrupts while we do this
    863          //    Signal = analogRead(pulsePin);                    // read the Pulse Sensor  //MHMS orginal arduino code
    864          
    865          //MHMS using HAL layer API to set channel to read and 10 Bit resolution
    866            Signal = HalAdcRead(HAL_ADC_CHANNEL_7, HAL_ADC_RESOLUTION_10);
   \   00000C   6D43         MOV.B   #0x2, R13
   \   00000E   7C400700     MOV.B   #0x7, R12
   \   000012   ........     CALLA   #HalAdcRead
   \   000016   0B4C         MOV.W   R12, R11
    867            
    868            sampleCounter += 2;                                   // keep track of the time in mS with this variable
   \   000018   A253....     ADD.W   #0x2, &??sampleCounter
   \   00001C   8263....     ADDC.W  #0x0, &??sampleCounter + 2
    869            int Number = (sampleCounter - lastBeatTime);          // monitor the time since the last beat to avoid noise
                       ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is
          undefined in this statement
   \   000020   3440....     MOV.W   #??sampleCounter, R4
   \   000024   2644         MOV.W   @R4, R6
   \   000026   1682....     SUB.W   &??lastBeatTime, R6
    870          
    871          //  find the peak and trough of the pulse wave
    872              if(Signal < thresh && Number > (IBI/5)*3){          // avoid dichrotic noise by waiting 3/5 of last IBI
   \   00002A   3940....     MOV.W   #??thresh, R9
   \   00002E   2C99         CMP.W   @R9, R12
   \   000030   0834         JGE     ??pulseBPM_2
   \   000032   ........     CALLA   #?Subroutine8
   \                     ??CrossCallReturnLabel_9:
   \   000036   0534         JGE     ??pulseBPM_2
    873                  if (Signal < T){                                // T is the trough
   \   000038   1B92....     CMP.W   &??T, R11
   \   00003C   0234         JGE     ??pulseBPM_2
    874                      T = Signal;                                 // keep track of lowest point in pulse wave 
   \   00003E   824B....     MOV.W   R11, &??T
    875                   }
    876                 }
    877                
    878              if(Signal > thresh && Signal > P){          // thresh condition helps avoid noise
   \                     ??pulseBPM_2:
   \   000042   829B....     CMP.W   R11, &??thresh
   \   000046   0534         JGE     ??pulseBPM_3
   \   000048   829B....     CMP.W   R11, &??P
   \   00004C   0234         JGE     ??pulseBPM_3
    879                  P = Signal;                             // P is the peak
   \   00004E   824B....     MOV.W   R11, &??P
    880                 }                                        // keep track of highest point in pulse wave
    881              
    882            //  NOW IT'S TIME TO LOOK FOR THE HEART BEAT
    883            // signal surges up in value every time there is a pulse
    884          if (Number > 250){                                   // avoid high frequency noise //MHMS increased from 250 to 500 to reduce high freq noise
   \                     ??pulseBPM_3:
   \   000052   3690FB00     CMP.W   #0xfb, R6
   \   000056   5E38         JL      ??pulseBPM_4
    885            if ((Signal > thresh) && (Pulse == FALSE) && (Number > (int)(IBI/5)*3) ){        
   \   000058   829B....     CMP.W   R11, &??thresh
   \   00005C   5B34         JGE     ??pulseBPM_4
   \   00005E   C293....     CMP.B   #0x0, &Pulse
   \   000062   5820         JNE     ??pulseBPM_4
   \   000064   ........     CALLA   #?Subroutine8
   \                     ??CrossCallReturnLabel_10:
   \   000068   5534         JGE     ??pulseBPM_4
    886              Pulse = TRUE;                               // set the Pulse flag when we think there is a pulse
   \   00006A   D243....     MOV.B   #0x1, &Pulse
    887              
    888              //MHMS  could define some external LED or just write to LCD screen "Pulse found"
    889              HalLedSet (HAL_LED_2, HAL_LED_MODE_OFF);    //MHMS beat found
   \   00006E   4D43         MOV.B   #0x0, R13
   \   000070   6C43         MOV.B   #0x2, R12
   \   000072   ........     CALLA   #HalLedSet
    890              HalLedSet (HAL_LED_1, HAL_LED_MODE_ON);     //MHMS LED on during upbeat
   \   000076   5D43         MOV.B   #0x1, R13
   \   000078   5C43         MOV.B   #0x1, R12
   \   00007A   ........     CALLA   #HalLedSet
    891              
    892              IBI = sampleCounter - lastBeatTime;         // measure time between beats in mS
                     ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is
          undefined in this statement
   \   00007E   2844         MOV.W   @R4, R8
   \   000080   1882....     SUB.W   &??lastBeatTime, R8
    893              lastBeatTime = sampleCounter;               // keep track of time for next pulse
   \   000084   A244....     MOV.W   @R4, &??lastBeatTime
   \   000088   92440200.... MOV.W   0x2(R4), &??lastBeatTime + 2
    894                   
    895                   if(firstBeat){                         // if it's the first time we found a beat, if firstBeat == TRUE
   \   00008E   C293....     CMP.B   #0x0, &??firstBeat
   \   000092   0324         JEQ     ??pulseBPM_5
    896                       firstBeat = FALSE;                 // clear firstBeat flag
   \   000094   C243....     MOV.B   #0x0, &??firstBeat
    897                       return;                            // IBI value is unreliable so discard it
   \   000098   8B3C         JMP     ??pulseBPM_6
    898                      }   
    899                   if(secondBeat){                        // if this is the second beat, if secondBeat == TRUE
   \                     ??pulseBPM_5:
   \   00009A   C293....     CMP.B   #0x0, &??secondBeat
   \   00009E   0B24         JEQ     ??pulseBPM_7
    900                      secondBeat = FALSE;                 // clear secondBeat flag
   \   0000A0   C243....     MOV.B   #0x0, &??secondBeat
    901                         for(int i=0; i<=9; i++){         // seed the running total to get a realisitic BPM at startup
   \   0000A4   0743         MOV.W   #0x0, R7
    902                              rate[i] = IBI;                      
   \                     ??pulseBPM_0:
   \   0000A6   0F47         MOV.W   R7, R15
   \   0000A8   0F5F         RLA.W   R15
   \   0000AA   8F48....     MOV.W   R8, ??rate(R15)
    903                              }
   \   0000AE   1753         ADD.W   #0x1, R7
   \   0000B0   37900A00     CMP.W   #0xa, R7
   \   0000B4   F83B         JL      ??pulseBPM_0
    904                      }
    905                    
    906              // keep a running total of the last 10 IBI values
    907              int16 runningTotal = 0; //word runningTotal = 0;                   // clear the runningTotal variable    
   \                     ??pulseBPM_7:
   \   0000B6   0F43         MOV.W   #0x0, R15
    908          
    909              for(int i=0; i<=8; i++){                // shift data in the rate array
   \   0000B8   0743         MOV.W   #0x0, R7
    910                    rate[i] = rate[i+1];              // and drop the oldest IBI value 
   \                     ??pulseBPM_1:
   \   0000BA   0E47         MOV.W   R7, R14
   \   0000BC   0E5E         RLA.W   R14
   \   0000BE   9E4E........ MOV.W   ??rate + 2(R14), ??rate(R14)
    911                    runningTotal += rate[i];          // add up the 9 oldest IBI values
   \   0000C4   1F5E....     ADD.W   ??rate(R14), R15
    912                  }
   \   0000C8   1753         ADD.W   #0x1, R7
   \   0000CA   37900900     CMP.W   #0x9, R7
   \   0000CE   F53B         JL      ??pulseBPM_1
    913                  
    914              rate[9] = IBI;                          // add the latest IBI to the rate array
   \   0000D0   8248....     MOV.W   R8, &??rate + 18
    915              runningTotal += rate[9];                // add the latest IBI to runningTotal
    916              runningTotal /= 10;                     // average the last 10 IBI values 
    917              BPM = 60000/runningTotal;               // how many beats can fit into a minute? that's BPM!
   \   0000D4   3C4060EA     MOV.W   #0xea60, R12
   \   0000D8   0312         PUSH.W  #0x0
   \   0000DA   0C12         PUSH.W  R12
   \   0000DC   1F52....     ADD.W   &??rate + 18, R15
   \   0000E0   0C4F         MOV.W   R15, R12
   \   0000E2   3E400A00     MOV.W   #0xa, R14
   \   0000E6   ........     CALLA   #?DivMod16s
   \   0000EA   0E4C         MOV.W   R12, R14
   \   0000EC   0F4C         MOV.W   R12, R15
   \   0000EE   3FE3         XOR.W   #0xffff, R15
   \   0000F0   0F5F         RLA.W   R15
   \   0000F2   0F7F         SUBC.W  R15, R15
   \   0000F4   3C41         POP.W   R12
   \   0000F6   3D41         POP.W   R13
   \   0000F8   ........     CALLA   #?DivMod32s
   \   0000FC   474C         MOV.B   R12, R7
    918              QS = TRUE;                              // set Quantified Self flag //MHMS we will use this to flag other event to transmit data over network
   \   0000FE   D243....     MOV.B   #0x1, &QS
    919              
    920          
    921              HalLcdWriteStringValue("BPM:",BPM, 10, HAL_LCD_LINE_5); //MHMS display BPM on LCD screen
   \   000102   7F400500     MOV.B   #0x5, R15
   \   000106   7E400A00     MOV.B   #0xa, R14
   \   00010A   0D4C         MOV.W   R12, R13
   \   00010C   3C40....     MOV.W   #`?<Constant "BPM:">`, R12
   \   000110   ........     CALLA   #HalLcdWriteStringValue
    922              }                       
    923          }
    924          
    925            if (Signal < thresh && Pulse == TRUE){     // when the values are going down, the beat is over
   \                     ??pulseBPM_4:
   \   000114   2B99         CMP.W   @R9, R11
   \   000116   1E34         JGE     ??pulseBPM_8
   \   000118   D293....     CMP.B   #0x1, &Pulse
   \   00011C   1B20         JNE     ??pulseBPM_8
    926                //digitalWrite(blinkPin,LOW);            // turn off pin 13 LED
    927               //MHMS  could define some external LED or just write to LCD screen "Pulse Not found"
    928                HalLedSet (HAL_LED_1, HAL_LED_MODE_OFF);
   \   00011E   4D43         MOV.B   #0x0, R13
   \   000120   5C43         MOV.B   #0x1, R12
   \   000122   ........     CALLA   #HalLedSet
    929                
    930                Pulse = FALSE;                         // reset the Pulse flag so we can do it again
   \   000126   C243....     MOV.B   #0x0, &Pulse
    931                amp = P - T;                           // get amplitude of the pulse wave
                       ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is
          undefined in this statement
   \   00012A   1F42....     MOV.W   &??P, R15
   \   00012E   1F82....     SUB.W   &??T, R15
   \   000132   824F....     MOV.W   R15, &??amp
    932                thresh = amp/2 + T + 100;              // set thresh at 50% of the amplitude  //MHMS offset up by 100 to ignore small flucuations due to noise
                       ^
Warning[Pa082]: undefined behavior: the order of volatile accesses is
          undefined in this statement
   \   000136   1C42....     MOV.W   &??amp, R12
   \   00013A   2E43         MOV.W   #0x2, R14
   \   00013C   ........     CALLA   #?DivMod16s
   \   000140   1C52....     ADD.W   &??T, R12
   \   000144   3C506400     ADD.W   #0x64, R12
   \   000148   824C....     MOV.W   R12, &??thresh
    933                P = thresh;                            // reset these for next time
   \   00014C   A249....     MOV.W   @R9, &??P
    934                T = thresh;
   \   000150   A249....     MOV.W   @R9, &??T
    935               }
    936            
    937            if (Number > 2500){                        // if 2.5 seconds go by without a beat
   \                     ??pulseBPM_8:
   \   000154   3690C509     CMP.W   #0x9c5, R6
   \   000158   1738         JL      ??pulseBPM_9
    938                HalLedSet (HAL_LED_2, HAL_LED_MODE_ON);// MHMS Indicate that no beat found
   \   00015A   5D43         MOV.B   #0x1, R13
   \   00015C   6C43         MOV.B   #0x2, R12
   \   00015E   ........     CALLA   #HalLedSet
    939                thresh = 512 + 100;                    // set thresh default //MHMS offset up by 100 to ignore small flucuations due to noise
   \   000162   B2406402.... MOV.W   #0x264, &??thresh
    940                P = 512;                               // set P default
   \   000168   B2400002.... MOV.W   #0x200, &??P
    941                T = 512;                               // set T default
   \   00016E   B2400002.... MOV.W   #0x200, &??T
    942                lastBeatTime = sampleCounter;          // bring the lastBeatTime up to date        
   \   000174   B244....     MOV.W   @R4+, &??lastBeatTime
   \   000178   B244....     MOV.W   @R4+, &??lastBeatTime + 2
    943                firstBeat = TRUE;                      // set these to avoid noise
   \   00017C   D243....     MOV.B   #0x1, &??firstBeat
    944                secondBeat = TRUE;                     // when we get the heartbeat back
   \   000180   D243....     MOV.B   #0x1, &??secondBeat
    945                QS = FALSE;                            // Clears Pulse measurement quantifier flag so no data  is sent over the air
   \   000184   C243....     MOV.B   #0x0, &QS
    946               }
    947          
    948          //MHMS Loading 16 bit results into 8 bit blocks for pulsedata array              
    949          pulsedata[PULSE_BPM] = (uint8)((BPM & 0x00FF));
   \                     ??pulseBPM_9:
   \   000188   CA470D00     MOV.B   R7, 0xd(R10)
    950          pulsedata[PULSE_RAW_MSB] = (uint8)((Signal >> 8));
   \   00018C   0F4B         MOV.W   R11, R15
   \   00018E                RPT     #0x8
   \   00018E   47180F11     RRAX.W  R15
   \   000192   CA4F1000     MOV.B   R15, 0x10(R10)
    951          pulsedata[PULSE_RAW_LSB] = (uint8)((Signal & 0x00FF));
   \   000196   CA4B0F00     MOV.B   R11, 0xf(R10)
    952          pulsedata[PULSE_IBI] = (uint8)((IBI & 0x00FF));
   \   00019A   CA481200     MOV.B   R8, 0x12(R10)
    953          
    954          pulsedata[PULSE_BPM_CHAR] = 'B';
   \   00019E   FA4042000C00 MOV.B   #0x42, 0xc(R10)
    955          pulsedata[PULSE_RAW_CHAR] = 'S';
   \   0001A4   FA4053000E00 MOV.B   #0x53, 0xe(R10)
    956          pulsedata[PULSE_IBI_CHAR] = 'Q';
   \   0001AA   FA4051001100 MOV.B   #0x51, 0x11(R10)
    957          
    958          //HalLcdWriteStringValue("Signal:",Signal, 10, 7); //MHMS  for testing ADC values
    959          
    960          
    961            //sei();                                     // enable interrupts when youre done!
    962          }// end isr
   \                     ??pulseBPM_6:
   \   0001B0   7417         POPM.W  #0x8, R11
   \   0001B2   1001         RETA

   \                                 In  segment CODE, align 2
   \                     ?Subroutine8:
   \   000000   4C48         MOV.B   R8, R12
   \   000002   7E400500     MOV.B   #0x5, R14
   \   000006   ........     CALLA   #?DivMod8u
   \   00000A   4C4C         MOV.B   R12, R12
   \   00000C   0F4C         MOV.W   R12, R15
   \   00000E                RPT     #0x2
   \   00000E   41180F5C     ADDX.W  R12, R15
   \   000012   0F96         CMP.W   R6, R15
   \   000014   1001         RETA

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     ??rate:
   \   000000                DS8 20

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     ??sampleCounter:
   \   000000                DS8 4

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     ??lastBeatTime:
   \   000000                DS8 4

   \                                 In  segment DATA16_I, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
   \                     ??P:
   \   000000                DS8 2
   \   000002                REQUIRE `?<Initializer for P>`

   \                                 In  segment DATA16_I, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
   \                     ??T:
   \   000000                DS8 2
   \   000002                REQUIRE `?<Initializer for T>`

   \                                 In  segment DATA16_I, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
   \                     ??thresh:
   \   000000                DS8 2
   \   000002                REQUIRE `?<Initializer for thresh>`

   \                                 In  segment DATA16_I, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
   \                     ??amp:
   \   000000                DS8 2
   \   000002                REQUIRE `?<Initializer for amp>`

   \                                 In  segment DATA16_I, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
   \                     ??firstBeat:
   \   000000                DS8 1
   \   000001                REQUIRE `?<Initializer for firstBeat>`

   \                                 In  segment DATA16_I, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
   \                     ??secondBeat:
   \   000000                DS8 1
   \   000001                REQUIRE `?<Initializer for secondBeat>`
    963          
    964          /**************************************************************************************************
    965           * @fn          pulseDataReq
    966           *
    967           * @brief       This function is called by pulseAppEvt() to send a PULSE data report. When it is detected that
    968           *              a pulse is found (QS flag is set) this function will start to transfer BPM, IBI, and raw Signal
    969           *              data over the air to the coordinator at 20ms intervals. When there is no BPM detected
    970           *              this function will stop sending information over the air to the coordinator.
    971           *
    972           * input parameters
    973           *
    974           * None.
    975           *
    976           * output parameters
    977           *
    978           * None.
    979           *
    980           * @return      None.
    981           **************************************************************************************************
    982           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine1:
   \   000000   31500C00     ADD.W   #0xc, SP
   \   000004   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine4:
   \   000000   3F401600     MOV.W   #0x16, R15
   \   000004                REQUIRE ??Subroutine12_0
   \   000004                // Fall through to label ??Subroutine12_0

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ??Subroutine12_0:
   \   000000   ........     CALLA   #?Subroutine11
   \                     ??CrossCallReturnLabel_24:
   \   000004   ........     BRA     #AF_DataRequest

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine3:
   \   000000   9142....0400 MOV.W   &pulseAddr, 0x4(SP)
   \   000006   E1430C00     MOV.B   #0x2, 0xc(SP)
   \   00000A   F14003000D00 MOV.B   #0x3, 0xd(SP)
   \   000010   1001         RETA

   \                                 In  segment CODE, align 2
    983          static void pulseDataReq(void)
   \                     pulseDataReq:
    984          {
   \   000000   31800C00     SUB.W   #0xc, SP
    985            static bool pulseDataReqFlag;
    986            pulseDataReqFlag = FALSE;
   \   000004   C243....     MOV.B   #0x0, &??pulseDataReqFlag
    987            afAddrType_t addr;                    //AF address stucture defined for info on the destination Endpoint object that data will be sent to
    988            
    989            osal_stop_timerEx(pulseTaskId, PULSE_EVT_CHECKIN);  //Node is collecting data and sending it to coordinator so turn off check in event
   \   000008   3D400008     MOV.W   #0x800, R13
   \   00000C   5C42....     MOV.B   &pulseTaskId, R12
   \   000010   ........     CALLA   #osal_stop_timerEx
    990            PulseEvtCheckin_sync = FALSE;  
   \   000014   C243....     MOV.B   #0x0, &PulseEvtCheckin_sync
    991            
    992            pulseDat[PULSE_CHECK_IN] = CHECK_IN_INACTIVE;   //Flag is off and will notify coordinator that node is not sending check in data
   \   000018   E243....     MOV.B   #0x2, &pulseDat + 11
    993           
    994            addr.addr.shortAddr = pulseAddr;      //loading short address (16-bit) with pulse address
   \   00001C   ........     CALLA   #?Subroutine3
    995            addr.addrMode = afAddr16Bit;          //Set to directly sent to a node
    996            addr.endPoint = PULSE_ENDPOINT;       //Sets the endpoint of the final destination (coordinator?)
    997          
    998            if (afStatus_SUCCESS != AF_DataRequest(&addr, (endPointDesc_t *)&PULSE_epDesc, PULSE_CLUSTER_ID,
    999                                                    PULSE_DAT_LEN, pulseDat, &pulseTSN,
   1000                                                    AF_DISCV_ROUTE
   1001          #if TVSA_DATA_CNF
   1002                                                  | AF_ACK_REQUEST
   1003          #endif
   1004                                                   ,AF_DEFAULT_RADIUS))  //MHMS
   \                     ??CrossCallReturnLabel_4:
   \   000020   70121E00     PUSH.B  #0x1e
   \   000024   70122000     PUSH.B  #0x20
   \   000028   3012....     PUSH.W  #pulseTSN
   \   00002C   3012....     PUSH.W  #pulseDat
   \   000030   ........     CALLA   #?Subroutine4
   \                     ??CrossCallReturnLabel_21:
   \   000034   3152         ADD.W   #0x8, SP
   \   000036   4C93         CMP.B   #0x0, R12
   \   000038   0524         JEQ     ??pulseDataReq_0
   1005            { //if data transfer is unsuccessful place event immediately back into queue to attempt to send again
   1006                  osal_set_event(pulseTaskId, PULSE_EVT_REQ);
   \   00003A   3D400020     MOV.W   #0x2000, R13
   \   00003E   ........     CALLA   #??Subroutine7_0
   1007            }
   \                     ??CrossCallReturnLabel_25:
   \   000042   023C         JMP     ??pulseDataReq_1
   1008            else
   1009            {
   1010              pulseCnt++;
   \                     ??pulseDataReq_0:
   \   000044   9253....     ADD.W   #0x1, &pulseCnt
   1011            }
   1012            if((QS == TRUE) && (pulseDataReqFlag == FALSE)){
   \                     ??pulseDataReq_1:
   \   000048   D293....     CMP.B   #0x1, &QS
   \   00004C   0B20         JNE     ??pulseDataReq_2
   \   00004E   C293....     CMP.B   #0x0, &??pulseDataReqFlag
   \   000052   0820         JNE     ??pulseDataReq_2
   1013              osal_start_timerEx(pulseTaskId, PULSE_EVT_REQ, PULSE_DLY_DATAREQ);  //send next Pulse data report in 20ms
   \   000054   3E401400     MOV.W   #0x14, R14
   \   000058   3D400020     MOV.W   #0x2000, R13
   \   00005C   ........     CALLA   #?Subroutine9
   1014              pulseDataReqFlag = TRUE;  //to prevent restarting of timer if existing already running
   \                     ??CrossCallReturnLabel_12:
   \   000060   D243....     MOV.B   #0x1, &??pulseDataReqFlag
   1015               
   1016            }
   1017            /*
   1018          
   1019            //MHMS USB communication with Pulse sensor Processor application
   1020          
   1021            uint8 BPMBuf[7] = {'B',0,0,0,10,13};
   1022            uint8 IBIBuf[7] = {'Q',0,0,0,10,13};
   1023            uint8 SignalBuf[7] = {'S',0,0,0,10,13};
   1024            
   1025            //conversion Signal Dec to ASCII
   1026            uint16 temp = (BUILD_UINT16(pulseDat[15], pulseDat[16])) - 400;
   1027            if(temp > 999){
   1028              SignalBuf[1] = '9';
   1029              SignalBuf[2] = '9';
   1030              SignalBuf[3] = '9';
   1031            }
   1032            else { 
   1033              SignalBuf[1] = (uint8)((temp/100)+ 48);
   1034              SignalBuf[2] = (uint8)((((temp%100) - (temp % 100)%10)/10) + 48);
   1035              SignalBuf[3] = (uint8)(((temp % 100)%10)+ 48);
   1036            }
   1037            
   1038            //conversion BPM Dec to ASCII
   1039            temp = (uint16)pulseDat[13];
   1040            BPMBuf[1] = (uint8)((temp/100)+ 48);
   1041            BPMBuf[2] = (uint8)((((temp%100) - (temp % 100)%10)/10) + 48);
   1042            BPMBuf[3] = (uint8)(((temp % 100)%10)+ 48);
   1043            
   1044            //conversion IBI Dec to ASCII
   1045            temp = (uint16)pulseDat[18];
   1046            IBIBuf[1] = (uint8)((temp/100)+ 48);
   1047            IBIBuf[2] = (uint8)((((temp%100) - (temp % 100)%10)/10) + 48);
   1048            IBIBuf[3] = (uint8)(((temp % 100)%10)+ 48);
   1049             
   1050            
   1051            HalUARTWrite(0, SignalBuf, 6);
   1052            HalUARTWrite(0, BPMBuf, 6);
   1053            HalUARTWrite(0, IBIBuf, 6);
   1054            */
   1055          }
   \                     ??pulseDataReq_2:
   \   000064   ....         JMP     ?Subroutine1
   \   000066   0343         NOP

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     ??pulseDataReqFlag:
   \   000000                DS8 1
   1056          
   1057          
   1058          /**************************************************************************************************
   1059           * @fn          pulseNodeCheckIn
   1060           *
   1061           * @brief       This function is called by the pulseAppEvt() function.  
   1062           *
   1063           * input parameters
   1064           *
   1065           *
   1066           * output parameters
   1067           *
   1068           * None.
   1069           *
   1070           * @return      None.
   1071           **************************************************************************************************
   1072           */
   1073          

   \                                 In  segment CODE, align 2, keep-with-next
   1074          static void pulseNodeCheckIn(void)
   \                     pulseNodeCheckIn:
   1075          {
   \   000000   31800C00     SUB.W   #0xc, SP
   1076          
   1077            static bool Flag;
   1078            afAddrType_t addr;                    //AF address stucture defined for info on the destination Endpoint object that data will be sent to
   1079            
   1080            osal_stop_timerEx(pulseTaskId, PULSE_EVT_REQ); //Stop pulseDataReq() task since no pulse data is being measured
   \   000004   3D400020     MOV.W   #0x2000, R13
   \   000008   5C42....     MOV.B   &pulseTaskId, R12
   \   00000C   ........     CALLA   #osal_stop_timerEx
   1081            PulseEvtReq_sync = FALSE;
   \   000010   C243....     MOV.B   #0x0, &PulseEvtReq_sync
   1082            Flag = FALSE;
   \   000014   C243....     MOV.B   #0x0, &??Flag
   1083            addr.addr.shortAddr = pulseAddr;      //loading short address (16-bit) with pulse address
   \   000018   ........     CALLA   #?Subroutine3
   1084            addr.addrMode = afAddr16Bit;          //Set to directly sent to a node
   1085            addr.endPoint = PULSE_ENDPOINT;       //Sets the endpoint of the final destination (coordinator?)
   1086          
   1087            pulseDat[PULSE_CHECK_IN] = CHECK_IN_ACTIVE;   //Flag is set and will notify coordinator that node is currently sending check in data
   \                     ??CrossCallReturnLabel_3:
   \   00001C   D243....     MOV.B   #0x1, &pulseDat + 11
   1088            HalLcdWriteString("BPMsensor Inacti",HAL_LCD_LINE_5);
   \   000020   7D400500     MOV.B   #0x5, R13
   \   000024   3C40....     MOV.W   #`?<Constant "BPMsensor Inacti">`, R12
   \   000028   ........     CALLA   #HalLcdWriteString
   1089          
   1090            if (afStatus_SUCCESS != AF_DataRequest(&addr, (endPointDesc_t *)&PULSE_epDesc, PULSE_CLUSTER_ID,
   1091                                                    PULSE_DAT_LEN, pulseDat, &pulseTSN, AF_DISCV_ROUTE,AF_DEFAULT_RADIUS))
   \   00002C   70121E00     PUSH.B  #0x1e
   \   000030   70122000     PUSH.B  #0x20
   \   000034   3012....     PUSH.W  #pulseTSN
   \   000038   3012....     PUSH.W  #pulseDat
   \   00003C   ........     CALLA   #?Subroutine4
   \                     ??CrossCallReturnLabel_22:
   \   000040   3152         ADD.W   #0x8, SP
   \   000042   4C93         CMP.B   #0x0, R12
   \   000044   0524         JEQ     ??pulseNodeCheckIn_0
   1092              { //if data transfer is unsuccessful place event immediately back into queue to attempt to send again
   1093                  osal_set_event(pulseTaskId, PULSE_EVT_CHECKIN);
   \   000046   3D400008     MOV.W   #0x800, R13
   \   00004A   ........     CALLA   #??Subroutine7_0
   1094            }
   \                     ??CrossCallReturnLabel_26:
   \   00004E   023C         JMP     ??pulseNodeCheckIn_1
   1095            else
   1096            {
   1097              pulseCnt++;
   \                     ??pulseNodeCheckIn_0:
   \   000050   9253....     ADD.W   #0x1, &pulseCnt
   1098            }
   1099            if((QS == FALSE) && (Flag == FALSE)){
   \                     ??pulseNodeCheckIn_1:
   \   000054   C293....     CMP.B   #0x0, &QS
   \   000058   0B20         JNE     ??pulseNodeCheckIn_2
   \   00005A   C293....     CMP.B   #0x0, &??Flag
   \   00005E   0820         JNE     ??pulseNodeCheckIn_2
   1100              osal_start_timerEx(pulseTaskId, PULSE_EVT_CHECKIN, PULSE_DLY_CHECKIN);  //send check in dummy packet every 10 seconds
   \   000060   3E401027     MOV.W   #0x2710, R14
   \   000064   3D400008     MOV.W   #0x800, R13
   \   000068   ........     CALLA   #?Subroutine9
   1101              Flag = TRUE;  //to prevent restarting of timer if existing already running
   \                     ??CrossCallReturnLabel_13:
   \   00006C   D243....     MOV.B   #0x1, &??Flag
   1102               
   1103            }
   1104            
   1105          }
   \                     ??pulseNodeCheckIn_2:
   \   000070   ....         JMP     ?Subroutine1
   \   000072   0343         NOP

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     ??Flag:
   \   000000                DS8 1
   1106          
   1107          /**************************************************************************************************
   1108           * @fn          TestPayloadTx
   1109           *
   1110           * @brief       This function is called by the pulseAppEvt() function. This function is used to test 
   1111           *              network loading by sending test payloads that have a packet size and Tx frequency that
   1112           *              are user defined.  This is operated on a timer and is initiated by SW1.
   1113           * input parameters
   1114           *
   1115           *
   1116           * output parameters
   1117           *
   1118           * None.
   1119           *
   1120           * @return      None.
   1121           **************************************************************************************************
   1122           */

   \                                 In  segment CODE, align 2, keep-with-next
   1123          static void TestPayloadTx(void){
   \                     TestPayloadTx:
   \   000000   31800C00     SUB.W   #0xc, SP
   1124            static uint8 SeqNum =0;
   1125            static bool flag = FALSE;
   1126            afAddrType_t addr;                    //AF address stucture defined for info on the destination Endpoint object that data will be sent to
   1127            
   1128            TestDatTx[11] = SeqNum;
   \   000004   D242........ MOV.B   &??SeqNum, &TestDatTx + 11
   1129            TestDatTx[0] = PULSE_CMD_DAT_TEST;
   \   00000A   F2400300.... MOV.B   #0x3, &TestDatTx
   1130            if( flag == FALSE){
   \   000010   C293....     CMP.B   #0x0, &??flag
   \   000014   0220         JNE     ??TestPayloadTx_0
   1131            SeqNum++;
   \   000016   D253....     ADD.B   #0x1, &??SeqNum
   1132            }
   1133            flag = FALSE;
   \                     ??TestPayloadTx_0:
   \   00001A   C243....     MOV.B   #0x0, &??flag
   1134            addr.addr.shortAddr = pulseAddr;      //loading short address (16-bit) with pulse address
   \   00001E   ........     CALLA   #?Subroutine3
   1135            addr.addrMode = afAddr16Bit;          //Set to directly sent to a node
   1136            addr.endPoint = PULSE_ENDPOINT;       //Sets the endpoint of the final destination (coordinator?)
   1137          
   1138            
   1139            HalLcdWriteString("TestPayload TX",HAL_LCD_LINE_5);
   \                     ??CrossCallReturnLabel_2:
   \   000022   7D400500     MOV.B   #0x5, R13
   \   000026   3C40....     MOV.W   #`?<Constant "TestPayload TX">`, R12
   \   00002A   ........     CALLA   #HalLcdWriteString
   1140          
   1141            if (afStatus_SUCCESS != AF_DataRequest(&addr, (endPointDesc_t *)&PULSE_epDesc, PULSE_CLUSTER_ID,
   1142                                                    MHMS_TEST_PAYLOAD_LEN, TestDatTx, &pulseTSN, AF_DISCV_ROUTE,AF_DEFAULT_RADIUS))
   \   00002E   70121E00     PUSH.B  #0x1e
   \   000032   70122000     PUSH.B  #0x20
   \   000036   3012....     PUSH.W  #pulseTSN
   \   00003A   3012....     PUSH.W  #TestDatTx
   \   00003E   3F403200     MOV.W   #0x32, R15
   \   000042   ........     CALLA   #??Subroutine12_0
   \                     ??CrossCallReturnLabel_20:
   \   000046   3152         ADD.W   #0x8, SP
   \   000048   4C93         CMP.B   #0x0, R12
   \   00004A   0624         JEQ     ??TestPayloadTx_1
   1143              { //if data transfer is unsuccessful place event immediately back into queue to attempt to send again
   1144                  osal_set_event(pulseTaskId, TEST_EVT_PAYLOAD_TX);
   \   00004C   3D400004     MOV.W   #0x400, R13
   \   000050   ........     CALLA   #??Subroutine7_0
   1145                  flag = TRUE;
   \                     ??CrossCallReturnLabel_27:
   \   000054   D243....     MOV.B   #0x1, &??flag
   1146            }
   1147               osal_start_timerEx(pulseTaskId, TEST_EVT_PAYLOAD_TX, TEST_DLY_PAYLOAD_TX);  //send check in dummy packet every 10 seconds
   \                     ??TestPayloadTx_1:
   \   000058   3E401027     MOV.W   #0x2710, R14
   \   00005C   3D400004     MOV.W   #0x400, R13
   \   000060   ........     CALLA   #?Subroutine9
   1148            
   1149          }
   \                     ??CrossCallReturnLabel_14:
   \   000064                REQUIRE ?Subroutine1
   \   000064                // Fall through to label ?Subroutine1

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     ??SeqNum:
   \   000000                DS8 1

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     ??flag:
   \   000000                DS8 1
   1150          
   1151          //MHMS Question do we need this ? tvsaUartRx  this is for recieving command messages from UART
   1152          /**************************************************************************************************
   1153           * @fn          pulseUartRx
   1154           *
   1155           * @brief       This function is the Uart callback for Rx data.
   1156           *
   1157           * input parameters
   1158           *
   1159           * @param       port - Don't care.
   1160           * @param       event - Don't care.
   1161           *
   1162           * output parameters
   1163           *
   1164           * None.
   1165           *
   1166           * @return      None.
   1167           **************************************************************************************************
   1168           */
   1169          

   \                                 In  segment CODE, align 2
   1170          static void pulseUartRx(uint8 port, uint8 event)
   \                     pulseUartRx:
   1171          {
   \   000000   31800600     SUB.W   #0x6, SP
   1172          #ifdef TVSA_DEMO
   1173            uint8 ch;
   1174          
   1175            while (HalUARTRead(PULSE_PORT, &ch, 1))
   1176            {
   1177              switch (pulseState)
   1178              {
   1179              case SOP_STATE:
   1180                if (PULSE_SOP_VAL == ch)
   1181                {
   1182                  pulseState = CMD_STATE;
   1183                }
   1184                break;
   1185          
   1186              case CMD_STATE:
   1187                pulseCmd = ch;
   1188                pulseState = FCS_STATE;
   1189                break;
   1190          
   1191              case FCS_STATE:
   1192                if (pulseCmd == ch)
   1193                {
   1194                  if (pulseCmd == PULSE_CMD_BEG)
   1195                  {
   1196                    pulseAddr = NLME_GetShortAddr();
   1197                  }
   1198                  else if (pulseCmd == PULSE_CMD_END)
   1199                  {
   1200                    pulseAddr = INVALID_NODE_ADDR;
   1201                  }
   1202                  (void)osal_set_event(pulseTaskId, PULSE_EVT_ANN);
   1203                }
   1204          
   1205                pulseState = SOP_STATE;
   1206                break;
   1207          
   1208              default:
   1209               break;
   1210              }
   1211            }
   1212          #else
   1213            uint8 ch[5];
   1214            
   1215            HalUARTRead(PULSE_PORT, ch, 5);
   \   000004   3E400500     MOV.W   #0x5, R14
   \   000008   0D41         MOV.W   SP, R13
   \   00000A   0D53         ADD.W   #0x0, R13
   \   00000C   4C43         MOV.B   #0x0, R12
   \   00000E   ........     CALLA   #HalUARTRead
   1216            if (ch[2]==0x21)   //if statement to check for command from Z-Sensor Monitor
   \   000012   F19021000200 CMP.B   #0x21, 0x2(SP)
   \   000018   0220         JNE     ??pulseUartRx_0
   1217            {
   1218              sysPingRsp();
   \   00001A   ........     CALLA   #sysPingRsp
   1219            }
   1220          #endif
   1221          }
   \                     ??pulseUartRx_0:
   \   00001E   31500600     ADD.W   #0x6, SP
   \   000022   1001         RETA
   1222          
   1223          #ifndef TVSA_DEMO
   1224          /******************************************************************************
   1225           * @fn          calcFCS
   1226           *
   1227           * @brief       This function calculates the FCS checksum for the serial message 
   1228           *
   1229           * @param       pBuf - Pointer to the end of a buffer to calculate the FCS.
   1230           *              len - Length of the pBuf.
   1231           *
   1232           * @return      The calculated FCS.
   1233           ******************************************************************************
   1234           */

   \                                 In  segment CODE, align 2
   1235          static uint8 calcFCS(uint8 *pBuf, uint8 len)
   \                     calcFCS:
   1236          {
   1237            uint8 rtrn = 0;
   \   000000   4F43         MOV.B   #0x0, R15
   \   000002   013C         JMP     ??calcFCS_1
   1238          
   1239            while (len--)
   1240            {
   1241              rtrn ^= *pBuf++;
   \                     ??calcFCS_0:
   \   000004   7FEC         XOR.B   @R12+, R15
   1242            }
   \                     ??calcFCS_1:
   \   000006   4E4D         MOV.B   R13, R14
   \   000008   7D53         ADD.B   #0xff, R13
   \   00000A   4E93         CMP.B   #0x0, R14
   \   00000C   FB23         JNE     ??calcFCS_0
   1243          
   1244            return rtrn;
   \   00000E   4C4F         MOV.B   R15, R12
   \   000010   1001         RETA
   1245          }
   1246          
   1247          /*************************************************************************************************
   1248           * @fn          sysPingRsp
   1249           *
   1250           * @brief       Build and send Ping response
   1251           *
   1252           * @param       none
   1253           *              
   1254           * @return      none
   1255          **************************************************************************************************
   1256           */

   \                                 In  segment CODE, align 2
   1257          static void sysPingRsp(void)
   \                     sysPingRsp:
   1258          {
   \   000000   3182         SUB.W   #0x8, SP
   1259            uint8 pingBuff[7];
   1260            
   1261            // Start of Frame Delimiter
   1262            pingBuff[0] = 0xFE;
   \   000002   F140FE000000 MOV.B   #0xfe, 0(SP)
   1263            
   1264            // Length
   1265            pingBuff[1] = 0x02; 
   \   000008   E1430100     MOV.B   #0x2, 0x1(SP)
   1266            
   1267            // Command type
   1268            pingBuff[2] = LO_UINT16(0x0161); 
   \   00000C   F14061000200 MOV.B   #0x61, 0x2(SP)
   1269            pingBuff[3] = HI_UINT16(0x0161);
   \   000012   D1430300     MOV.B   #0x1, 0x3(SP)
   1270            
   1271            // Stack profile
   1272            pingBuff[4] = LO_UINT16(0x0041);
   \   000016   F14041000400 MOV.B   #0x41, 0x4(SP)
   1273            pingBuff[5] = HI_UINT16(0x0041);
   \   00001C   C1430500     MOV.B   #0x0, 0x5(SP)
   1274            
   1275            // Frame Check Sequence
   1276            pingBuff[6] = calcFCS(&pingBuff[1], 5);
   \   000020   7D400500     MOV.B   #0x5, R13
   \   000024   0C41         MOV.W   SP, R12
   \   000026   1C53         ADD.W   #0x1, R12
   \   000028   ........     CALLA   #calcFCS
   \   00002C   C14C0600     MOV.B   R12, 0x6(SP)
   1277            
   1278            
   1279            HalUARTWrite(PULSE_PORT,pingBuff, 7);
   \   000030   3E400700     MOV.W   #0x7, R14
   \   000034   0D41         MOV.W   SP, R13
   \   000036   0D53         ADD.W   #0x0, R13
   \   000038   4C43         MOV.B   #0x0, R12
   \   00003A   ........     CALLA   #HalUARTWrite
   1280          
   1281          }
   \   00003E   3152         ADD.W   #0x8, SP
   \   000040   1001         RETA

   \                                 In  segment DATA16_ID, align 2, align-sorted
   \                     `?<Initializer for IBI>`:
   \   000000   5802         DC16 600

   \                                 In  segment DATA16_ID, align 2, align-sorted
   \                     `?<Initializer for P>`:
   \   000000   0002         DC16 512

   \                                 In  segment DATA16_ID, align 2, align-sorted
   \                     `?<Initializer for T>`:
   \   000000   0002         DC16 512

   \                                 In  segment DATA16_ID, align 2, align-sorted
   \                     `?<Initializer for thresh>`:
   \   000000   0002         DC16 512

   \                                 In  segment DATA16_ID, align 2, align-sorted
   \                     `?<Initializer for amp>`:
   \   000000   6400         DC16 100

   \                                 In  segment DATA16_ID, align 1, align-sorted
   \                     `?<Initializer for firstBeat>`:
   \   000000   01           DC8 1

   \                                 In  segment DATA16_ID, align 1, align-sorted
   \                     `?<Initializer for secondBeat>`:
   \   000000   01           DC8 1

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "BPM:">`:
   \   000000   42504D3A00   DC8 "BPM:"

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "BPMsensor Inacti">`:
   \   000000   42504D73656E DC8 "BPMsensor Inacti"
   \            736F7220496E
   \            6163746900  

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "TestPayload TX">`:
   \   000000   546573745061 DC8 "TestPayload TX"
   \            796C6F616420
   \            545800      
   1282          #endif
   1283          /**************************************************************************************************
   1284          */
   1285          

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      24  TestPayloadTx
            24 -> AF_DataRequest
            16 -> HalLcdWriteString
            16 -> osal_set_event
            16 -> osal_start_timerEx
       4  calcFCS
       6  pulseAfMsgRx
             6 -> NLME_SetPollRate
             6 -> osal_set_event
             6 -> pulseDataRx
             6 -> pulseTestingDataRx
      28  pulseAnnce
            28 -> AF_DataRequest
            20 -> osal_set_event
            20 -> osal_start_timerEx
      12  pulseAppEvt
            12 -> TestPayloadTx
            12 -> osal_msg_deallocate
            12 -> osal_msg_receive
            12 -> pulseAfMsgRx
            12 -> pulseAnnce
            12 -> pulseDataCalc
            12 -> pulseDataReq
            12 -> pulseNodeCheckIn
            12 -> pulseZdoStateChange
      40  pulseAppInit
            40 -> HalUARTOpen
            40 -> afRegister
      24  pulseBPM
            20 -> HalAdcRead
            20 -> HalLcdWriteStringValue
            20 -> HalLedSet
       6  pulseDataCalc
             6 -> osal_set_event
             6 -> osal_start_timerEx
             6 -> pulseBPM
      24  pulseDataReq
            24 -> AF_DataRequest
            16 -> osal_set_event
            16 -> osal_start_timerEx
            16 -> osal_stop_timerEx
      28  pulseDataRx
            28 -> HalUARTWrite
            28 -> calcFCS
            28 -> osal_memcpy
            28 -> osal_set_event
      24  pulseNodeCheckIn
            24 -> AF_DataRequest
            16 -> HalLcdWriteString
            16 -> osal_set_event
            16 -> osal_start_timerEx
            16 -> osal_stop_timerEx
      28  pulseTestingDataRx
            28 -> HalUARTWrite
            28 -> calcFCS
            28 -> osal_mem_alloc
            28 -> osal_mem_free
            28 -> osal_memcpy
            28 -> osal_set_event
      10  pulseUartRx
            10 -> HalUARTRead
            10 -> sysPingRsp
      12  pulseZdoStateChange
            12 -> HalLcdWriteValue
            12 -> NLME_GetCoordShortAddr
            12 -> Onboard_rand
            12 -> osal_set_event
            12 -> osal_start_timerEx
            12 -> osal_stop_timerEx
            12 -> sAddrExtCpy
      12  sysPingRsp
            12 -> HalUARTWrite
            12 -> calcFCS


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       5  ?<Constant "BPM:">
      17  ?<Constant "BPMsensor Inacti">
      15  ?<Constant "TestPayload TX">
       2  ?<Initializer for IBI>
       2  ?<Initializer for P>
       2  ?<Initializer for T>
       2  ?<Initializer for amp>
       1  ?<Initializer for firstBeat>
       1  ?<Initializer for secondBeat>
       2  ?<Initializer for thresh>
       8  ??Subroutine12_0
       8  ??Subroutine7_0
       8  ?Subroutine0
       6  ?Subroutine1
       8  ?Subroutine10
      14  ?Subroutine11
      64  ?Subroutine2
      18  ?Subroutine3
       4  ?Subroutine4
      26  ?Subroutine5
      22  ?Subroutine6
       4  ?Subroutine7
      22  ?Subroutine8
       8  ?Subroutine9
       2  BPM
       1  Flag
       2  IBI
       2  P
       2  PULSE_ClusterList
      14  PULSE_SimpleDesc
       8  PULSE_epDesc
       1  Pulse
       1  PulseEvtCheckin_sync
       1  PulseEvtDat_sync
       1  PulseEvtReq_sync
       1  QS
       1  SeqNum
       2  Signal
       2  T
      50  TestDatTx
     100  TestPayloadTx
       2  _A_PCDIR_L
       2  _A_PCOUT_L
       2  _A_REFCTL0_L
       2  amp
      18  calcFCS
       1  firstBeat
       1  flag
       4  lastBeatTime
       2  pulseAddr
     102  pulseAfMsgRx
     120  pulseAnnce
     148  pulseAppEvt
     126  pulseAppInit
     436  pulseBPM
      25  pulseBuf
       2  pulseCnt
      22  pulseDat
     104  pulseDataCalc
     104  pulseDataReq
       1  pulseDataReqFlag
     118  pulseDataRx
     116  pulseNodeCheckIn
       1  pulseTSN
       1  pulseTaskId
     126  pulseTestingDataRx
      36  pulseUartRx
     292  pulseZdoStateChange
      20  rate
       4  sampleCounter
       1  secondBeat
      66  sysPingRsp
       2  thresh

 
 2 232 bytes in segment CODE
     6 bytes in segment DATA16_AN
    61 bytes in segment DATA16_C
    12 bytes in segment DATA16_I
    12 bytes in segment DATA16_ID
   144 bytes in segment DATA16_Z
 
 2 232 bytes of CODE  memory
    73 bytes of CONST memory
   156 bytes of DATA  memory (+ 6 bytes shared)

Errors: none
Warnings: 4
