###############################################################################
#                                                                             #
# IAR C/C++ Compiler V5.51.2.50607/W32 for MSP430       04/Apr/2013  15:23:19 #
# Copyright 1996-2012 IAR Systems AB.                                         #
#                                                                             #
#    __rt_version  =  3                                                       #
#    __double_size =  32                                                      #
#    __reg_r4      =  free                                                    #
#    __reg_r5      =  free                                                    #
#    __pic         =  no                                                      #
#    __core        =  430X                                                    #
#    __data_model  =  small                                                   #
#    Source file   =  C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\Source\tvsa.c                 #
#    Command line  =  -f C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2. #
#                     5.1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\Source\zap.c #
#                     fg (-DZAP_PHY_SPI=1 -DZAP_PHY_UART=!ZAP_PHY_SPI         #
#                     -DZAP_PHY_RESET_ZNP=TRUE -DZAP_ZNP_MT=FALSE             #
#                     -DZAP_APP_MSG=FALSE -DZAP_SBL_PROXY=FALSE               #
#                     -DZAP_AUTO_CFG=TRUE -DZAP_AUTO_START=TRUE               #
#                     -DZAP_NV_RESTORE=FALSE -DLCD_SUPPORTED                  #
#                     -DZAP_AF_DATA_REQ_FRAG=FALSE                            #
#                     -DZAP_AF_DATA_REQ_AREQ=!ZAP_AF_DATA_REQ_FRAG            #
#                     -DZAP_ZDO_STARTUP_AREQ=TRUE -DZAP_AF_FUNC               #
#                     -DZAP_SAPI_FUNC -DZAP_SYS_FUNC -DZAP_UTIL_FUNC          #
#                     -DZAP_ZDO_FUNC -DSECURE=0 -DZG_SECURE_DYNAMIC=0         #
#                     "-DDEFAULT_CHANLIST=(uint32)0x00000800"                 #
#                     -DZDAPP_CONFIG_PAN_ID=0xFFFF -DPOLL_RATE=1000           #
#                     -DNWK_START_DELAY=100 -DMAX_BINDING_CLUSTER_IDS=4)      #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\Source\tvsa.c -D              #
#                     ZAP_DEVICETYPE=ZG_DEVICETYPE_COORDINATOR -D             #
#                     TVSA_DEVICE_ID=0x0016 -D TVSA_DONGLE=1 -D HAL_UART=1    #
#                     -lC "C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430- #
#                     2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\ZAP              #
#                     Coordinator\List\" -lA "C:\Users\student\Documents\GitH #
#                     ub\MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP54 #
#                     38\ZAP Coordinator\List\" --remarks --diag_suppress     #
#                     Pe001,Pe193,Pe236,Pe826 -o                              #
#                     "C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5. #
#                     1\Projects\zstack\ZAP\TVSA\EXP5438\ZAP                  #
#                     Coordinator\Obj\" --debug -D__MSP430F5438__ -e          #
#                     --double=32 --clib -I C:\Users\student\Documents\GitHub #
#                     \MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438 #
#                     \ -I C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430- #
#                     2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\..\Source\ -I    #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\Source\ -I      #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\hal\target\MSP5438ZAP\ -I                          #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\hal\include\ -I C:\Users\student\Documents\GitHub\ #
#                     MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\ #
#                     ..\..\..\..\..\Components\mac\include\ -I               #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\mt\ -I C:\Users\student\Documents\GitHub\MHMS\ZAP- #
#                     MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\ #
#                     ..\..\Components\osal\include\ -I                       #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\osal\mcu\msp430\ -I C:\Users\student\Documents\Git #
#                     Hub\MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5 #
#                     438\..\..\..\..\..\Components\services\saddr\ -I        #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\services\sdata\ -I C:\Users\student\Documents\GitH #
#                     ub\MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP54 #
#                     38\..\..\..\..\..\Components\stack\af\ -I               #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\stack\nwk\ -I C:\Users\student\Documents\GitHub\MH #
#                     MS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\.. #
#                     \..\..\..\..\Components\stack\sapi\ -I                  #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\stack\sec\ -I C:\Users\student\Documents\GitHub\MH #
#                     MS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\.. #
#                     \..\..\..\..\Components\stack\sys\ -I                   #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\stack\zdo\ -I C:\Users\student\Documents\GitHub\MH #
#                     MS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\.. #
#                     \..\..\..\..\Components\zmac\ -I                        #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\zmac\f8w\ --core=430X --data_model=small -Ohz      #
#                     --multiplier=32 --multiplier_location=4C0               #
#                     --require_prototypes --hw_workaround=CPU40              #
#                     --hw_workaround=CPU42                                   #
#    List file     =  C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\ZAP                   #
#                     Coordinator\List\tvsa.lst                               #
#    Object file   =  C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\ZAP                   #
#                     Coordinator\Obj\tvsa.r43                                #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\Source\tvsa.c
      1          /**************************************************************************************************
      2              Filename:       tvsa.c
      3              Revised:        $Date: 2011-07-25 20:23:05 -0700 (Mon, 25 Jul 2011) $
      4              Revision:       $Revision: 26899 $
      5          
      6              Description:
      7          
      8              This file implements the Temperature/Voltage Sample Application.
      9          
     10          
     11          
     12          
     13              Copyright 2009 Texas Instruments Incorporated. All rights reserved.
     14          
     15              IMPORTANT: Your use of this Software is limited to those specific rights
     16              granted under the terms of a software license agreement between the user
     17              who downloaded the software, his/her employer (which must be your employer)
     18              and Texas Instruments Incorporated (the "License").  You may not use this
     19              Software unless you agree to abide by the terms of the License. The License
     20              limits your use, and you acknowledge, that the Software may not be modified,
     21              copied or distributed unless embedded on a Texas Instruments microcontroller
     22              or used solely and exclusively in conjunction with a Texas Instruments radio
     23              frequency transceiver, which is integrated into your product.  Other than for
     24              the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     25              works of, modify, distribute, perform, display or sell this Software and/or
     26              its documentation for any purpose.
     27          
     28              YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     29              PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     30              INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     31              NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     32              TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     33              NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     34              LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     35              INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     36              OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     37              OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     38              (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     39          
     40              Should you have any questions regarding your right to use this Software,
     41              contact Texas Instruments Incorporated at www.TI.com.
     42          **************************************************************************************************/
     43          
     44          /* ------------------------------------------------------------------------------------------------
     45           *                                          Includes
     46           * ------------------------------------------------------------------------------------------------
     47           */
     48          
     49          #include "af.h"
     50          #if defined LCD_SUPPORTED
     51          #include "hal_lcd.h"
     52          #endif
     53          #include "hal_uart.h"
     54          #include "OnBoard.h"
     55          #include "OSAL.h"
     56          #include "tvsa.h"
     57          #include "ZComDef.h"
     58          #include "ZDApp.h"
     59          
     60          #if !TVSA_DONGLE
     61          #include "tvsa_cc2530znp.c"
     62          #endif
     63          
     64          /* ------------------------------------------------------------------------------------------------
     65           *                                           Constants
     66           * ------------------------------------------------------------------------------------------------
     67           */
     68          
     69          //#define TVSA_DEMO  // TODO - define this constant for "Web Demo" TVSA behavior.
     70          

   \                                 In  segment DATA16_C, align 2, align-sorted
     71          static const cId_t TVSA_ClusterList[TVSA_CLUSTER_CNT] =
   \                     TVSA_ClusterList:
   \   000000   0200         DC16 2
     72          {
     73            TVSA_CLUSTER_ID
     74          };
     75          

   \                                 In  segment DATA16_C, align 2, align-sorted
     76          static const SimpleDescriptionFormat_t TVSA_SimpleDesc =
   \                     TVSA_SimpleDesc:
   \   000000   0300         DC8 3, 0
   \   000002   100F1600     DC16 3856, 22
   \   000006   0001         DC8 0, 1
   \   000008   ....         DC16 TVSA_ClusterList
   \   00000A   0100         DC8 1, 0
   \   00000C   ....         DC16 TVSA_ClusterList
     77          {
     78            TVSA_ENDPOINT,
     79            TVSA_PROFILE_ID,
     80            TVSA_DEVICE_ID,
     81            TVSA_DEVICE_VERSION,
     82            TVSA_FLAGS,
     83            TVSA_CLUSTER_CNT,
     84            (cId_t *)TVSA_ClusterList,
     85            TVSA_CLUSTER_CNT,
     86            (cId_t *)TVSA_ClusterList
     87          };
     88          

   \                                 In  segment DATA16_C, align 2, align-sorted
     89          static const endPointDesc_t TVSA_epDesc=
   \                     TVSA_epDesc:
   \   000000   0300         DC8 3, 0
   \   000002   ........     DC16 tvsaTaskId, TVSA_SimpleDesc
   \   000006   0000         DC8 0, 0
     90          {
     91            TVSA_ENDPOINT,
     92            &tvsaTaskId,
     93            (SimpleDescriptionFormat_t *)&TVSA_SimpleDesc,
     94            noLatencyReqs,
     95          };
     96          
     97          /* ------------------------------------------------------------------------------------------------
     98           *                                           Typedefs
     99           * ------------------------------------------------------------------------------------------------
    100           */
    101          
    102          /* ------------------------------------------------------------------------------------------------
    103           *                                           Macros
    104           * ------------------------------------------------------------------------------------------------
    105           */
    106          
    107          /* ------------------------------------------------------------------------------------------------
    108           *                                           Global Variables
    109           * ------------------------------------------------------------------------------------------------
    110           */
    111          
    112          #if TVSA_DATA_CNF

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    113          uint8 tvsaCnfErrCnt;
   \                     tvsaCnfErrCnt:
   \   000000                DS8 1
    114          #endif

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    115          uint8 tvsaTaskId;
   \                     tvsaTaskId:
   \   000000                DS8 1
    116          
    117          /* ------------------------------------------------------------------------------------------------
    118           *                                           Local Variables
    119           * ------------------------------------------------------------------------------------------------
    120           */
    121          
    122          // Network address of the TVSA Dongle.

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    123          static uint16 tvsaAddr;
   \                     tvsaAddr:
   \   000000                DS8 2
    124          // Report counter.

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    125          static uint16 tvsaCnt;
   \                     tvsaCnt:
   \   000000                DS8 2
    126          // ZigBee-required packet transaction sequence number in calls to AF_DataRequest().

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    127          static uint8 tvsaTSN;
   \                     tvsaTSN:
   \   000000                DS8 1
    128          
    129          #if TVSA_DONGLE

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    130          static uint8 tvsaBuf[TVSA_BUF_LEN];
   \                     tvsaBuf:
   \   000000                DS8 19
    131          #if defined TVSA_DEMO
    132          static uint8 tvsaCmd, tvsaState;
    133          #endif
    134          #else
    135          static uint8 tvsaDat[TVSA_DAT_LEN];
    136          #endif
    137          
    138          /* ------------------------------------------------------------------------------------------------
    139           *                                           Local Functions
    140           * ------------------------------------------------------------------------------------------------
    141           */
    142          
    143          static void tvsaAfMsgRx(afIncomingMSGPacket_t *msg);
    144          static void tvsaSysEvtMsg(void);
    145          #if !TVSA_DONGLE
    146          static void tvsaDataCalc(void);
    147          static void tvsaDataReq(void);
    148          static void tvsaZdoStateChange(void);
    149          #else //if TVSA_DONGLE
    150          static void tvsaAnnce(void);
    151          static void tvsaDataRx(afIncomingMSGPacket_t *msg);
    152          static void tvsaUartRx(uint8 port, uint8 event);
    153          static void tvsaZdoStateChange(void);
    154          #ifndef TVSA_DEMO
    155          static uint8 calcFCS(uint8 *pBuf, uint8 len);
    156          static void sysPingRsp(void);
    157          #endif
    158          
    159          #endif
    160          
    161          /**************************************************************************************************
    162           * @fn          tvsaAppInit
    163           *
    164           * @brief       This function is the application's task initialization.
    165           *
    166           * input parameters
    167           *
    168           * None.
    169           *
    170           * output parameters
    171           *
    172           * None.
    173           *
    174           * @return      None.
    175           **************************************************************************************************
    176           */

   \                                 In  segment CODE, align 2
    177          void tvsaAppInit(uint8 id)
   \                     tvsaAppInit:
    178          {
   \   000000   0A12         PUSH.W  R10
   \   000002   31802200     SUB.W   #0x22, SP
   \   000006   4A4C         MOV.B   R12, R10
    179          #if TVSA_DONGLE
    180            halUARTCfg_t uartConfig;
    181          
    182            uartConfig.configured           = TRUE;              // 2x30 don't care - see uart driver.
   \   000008   D1430000     MOV.B   #0x1, 0(SP)
    183            
    184          #ifdef TVSA_DEMO
    185            uartConfig.baudRate             = HAL_UART_BR_115200;
    186          #else
    187            uartConfig.baudRate             = HAL_UART_BR_38400;
   \   00000C   E1430100     MOV.B   #0x2, 0x1(SP)
    188          #endif
    189            
    190            uartConfig.flowControl          = FALSE;
   \   000010   C1430200     MOV.B   #0x0, 0x2(SP)
    191            uartConfig.flowControlThreshold = 16;                // 2x30 don't care - see uart driver.
   \   000014   B14010000400 MOV.W   #0x10, 0x4(SP)
    192            uartConfig.rx.maxBufSize        = 32;                // 2x30 don't care - see uart driver.
   \   00001A   B14020000C00 MOV.W   #0x20, 0xc(SP)
    193            uartConfig.tx.maxBufSize        = 254;               // 2x30 don't care - see uart driver.
   \   000020   B140FE001400 MOV.W   #0xfe, 0x14(SP)
    194            uartConfig.idleTimeout          = 6;                 // 2x30 don't care - see uart driver.
   \   000026   F14006000600 MOV.B   #0x6, 0x6(SP)
    195            uartConfig.intEnable            = TRUE;              // 2x30 don't care - see uart driver.
   \   00002C   D1431800     MOV.B   #0x1, 0x18(SP)
    196            uartConfig.callBackFunc         = tvsaUartRx;
   \   000030   B140....1E00 MOV.W   #LWRD(tvsaUartRx), 0x1e(SP)
   \   000036   B140....2000 MOV.W   #HWRD(tvsaUartRx), 0x20(SP)
    197            HalUARTOpen(TVSA_PORT, &uartConfig);
   \   00003C   0D41         MOV.W   SP, R13
   \   00003E   0D53         ADD.W   #0x0, R13
   \   000040   4C43         MOV.B   #0x0, R12
   \   000042   ........     CALLA   #HalUARTOpen
    198          #else
    199            tvsaDat[TVSA_TYP_IDX] = (uint8)TVSA_DEVICE_ID;
    200          #if defined TVSA_SRC_RTG
    201            tvsaDat[TVSA_OPT_IDX] = TVSA_OPT_SRC_RTG;
    202          #endif
    203          #endif
    204          
    205            tvsaTaskId = id;
   \   000046   C24A....     MOV.B   R10, &tvsaTaskId
    206            tvsaAddr = INVALID_NODE_ADDR;
   \   00004A   B240FEFF.... MOV.W   #0xfffe, &tvsaAddr
    207            (void)afRegister((endPointDesc_t *)&TVSA_epDesc);
   \   000050   3C40....     MOV.W   #TVSA_epDesc, R12
   \   000054   ........     CALLA   #afRegister
    208          }
   \   000058   31502200     ADD.W   #0x22, SP
   \   00005C   3A41         POP.W   R10
   \   00005E   1001         RETA
    209          
    210          /**************************************************************************************************
    211           * @fn          tvsaAppEvt
    212           *
    213           * @brief       This function is called to process the OSAL events for the task.
    214           *
    215           * input parameters
    216           *
    217           * @param       id - OSAL task Id.
    218           * @param       evts - OSAL events bit mask of pending events.
    219           *
    220           * output parameters
    221           *
    222           * None.
    223           *
    224           * @return      evts - OSAL events bit mask of unprocessed events.
    225           **************************************************************************************************
    226           */

   \                                 In  segment CODE, align 2
    227          uint16 tvsaAppEvt(uint8 id, uint16 evts)
   \                     tvsaAppEvt:
    228          {
   \   000000   1B15         PUSHM.W #0x2, R11
   \   000002   0A4D         MOV.W   R13, R10
    229            uint16 mask = 0;
    230            (void)id;
    231            
    232            if (evts & SYS_EVENT_MSG)
   \   000004   0D93         CMP.W   #0x0, R13
   \   000006   0534         JGE     ??tvsaAppEvt_0
    233            {
    234              mask = SYS_EVENT_MSG;
   \   000008   3B400080     MOV.W   #0x8000, R11
    235              tvsaSysEvtMsg();
   \   00000C   ........     CALLA   #tvsaSysEvtMsg
   \   000010   093C         JMP     ??tvsaAppEvt_1
    236            }
    237          #if TVSA_DONGLE
    238            else if (evts & TVSA_EVT_ANN)
   \                     ??tvsaAppEvt_0:
   \   000012   3DB00040     BIT.W   #0x4000, R13
   \   000016   0528         JNC     ??tvsaAppEvt_2
    239            {
    240              mask = TVSA_EVT_ANN;
   \   000018   3B400040     MOV.W   #0x4000, R11
    241              tvsaAnnce();
   \   00001C   ........     CALLA   #tvsaAnnce
   \   000020   013C         JMP     ??tvsaAppEvt_1
    242            }
    243          #else
    244            else if (evts & TVSA_EVT_DAT)
    245            {
    246              mask = TVSA_EVT_DAT;
    247              tvsaDataCalc();
    248            }
    249            else if (evts & TVSA_EVT_REQ)
    250            {
    251              mask = TVSA_EVT_REQ;
    252              tvsaDataReq();
    253            }
    254          #endif
    255            else
    256            {
    257              mask = evts;  // Discard unknown events - should never happen.
   \                     ??tvsaAppEvt_2:
   \   000022   0B4D         MOV.W   R13, R11
    258            }
    259          
    260            return (evts ^ mask);  // Return unprocessed events.
   \                     ??tvsaAppEvt_1:
   \   000024   0AEB         XOR.W   R11, R10
   \   000026   0C4A         MOV.W   R10, R12
   \   000028   1A17         POPM.W  #0x2, R11
   \   00002A   1001         RETA
    261          }
    262          
    263          /**************************************************************************************************
    264           * @fn          tvsaAfMsgRx
    265           *
    266           * @brief       This function is called by tvsaSysEvtMsg() to process an incoming AF message.
    267           *
    268           * input parameters
    269           *
    270           * @param       msg - A pointer to the afIncomingMSGPacket_t packet.
    271           *
    272           * output parameters
    273           *
    274           * None.
    275           *
    276           * @return      None.
    277           **************************************************************************************************
    278           */
    279          static void tvsaAfMsgRx(afIncomingMSGPacket_t *msg)
    280          {
    281            uint8 *buf = msg->cmd.Data;
    282          
    283            switch (buf[TVSA_CMD_IDX])
    284            {
    285          #if TVSA_DONGLE
    286            case TVSA_CMD_DAT:
    287              tvsaDataRx(msg);
    288              break;
    289          #else
    290          
    291            case TVSA_CMD_BEG:
    292              if (INVALID_NODE_ADDR == tvsaAddr)
    293              {
    294                NLME_SetPollRate(0);
    295                (void)osal_set_event(tvsaTaskId, TVSA_EVT_DAT);
    296              }
    297              tvsaAddr = BUILD_UINT16(buf[TVSA_ADR_LSB], buf[TVSA_ADR_MSB]);
    298              break;
    299          
    300            case TVSA_CMD_END:
    301              NLME_SetPollRate(POLL_RATE);
    302              tvsaAddr = INVALID_NODE_ADDR;
    303              break;
    304          #endif
    305          
    306            default:
    307              break;
    308            }
    309          }
    310          
    311          /**************************************************************************************************
    312           * @fn          tvsaSysEvtMsg
    313           *
    314           * @brief       This function is called by tvsaAppEvt() to process all of the pending OSAL messages.
    315           *
    316           * input parameters
    317           *
    318           * None.
    319           *
    320           * output parameters
    321           *
    322           * None.
    323           *
    324           * @return      None.
    325           **************************************************************************************************
    326           */

   \                                 In  segment CODE, align 2
    327          static void tvsaSysEvtMsg(void)
   \                     tvsaSysEvtMsg:
    328          {
   \   000000   0A12         PUSH.W  R10
   \   000002   053C         JMP     ??tvsaSysEvtMsg_3
    329            uint8 *msg;
    330          
    331            while ((msg = osal_msg_receive(tvsaTaskId)))
    332            {
    333              switch (*msg)
    334              {
    335          #if TVSA_DATA_CNF
    336              case AF_DATA_CONFIRM_CMD:
    337                if (ZSuccess != ((afDataConfirm_t *)msg)->hdr.status)
    338                {
    339                  if (0 == ++tvsaCnfErrCnt)
    340                  {
    341                    tvsaCnfErrCnt = 255;
    342                  }
    343                }
    344                break;
    345          #endif
    346          
    347              case AF_INCOMING_MSG_CMD:
    348                tvsaAfMsgRx((afIncomingMSGPacket_t *)msg);
    349                break;
    350          
    351              case ZDO_STATE_CHANGE:
    352                tvsaZdoStateChange();
   \                     ??tvsaSysEvtMsg_0:
   \   000004   ........     CALLA   #tvsaZdoStateChange
    353                break;
    354          
    355              default:
    356                break;
    357              }
    358          
    359              (void)osal_msg_deallocate(msg);  // Receiving task is responsible for releasing the memory.
   \                     ??tvsaSysEvtMsg_1:
   \   000008   0C4A         MOV.W   R10, R12
   \   00000A   ........     CALLA   #osal_msg_deallocate
   \                     ??tvsaSysEvtMsg_3:
   \   00000E   5C42....     MOV.B   &tvsaTaskId, R12
   \   000012   ........     CALLA   #osal_msg_receive
   \   000016   0A4C         MOV.W   R12, R10
   \   000018   0C93         CMP.W   #0x0, R12
   \   00001A   1B24         JEQ     ??tvsaSysEvtMsg_4
   \   00001C   6E4C         MOV.B   @R12, R14
   \   00001E   7E801A00     SUB.B   #0x1a, R14
   \   000022   0F24         JEQ     ??tvsaSysEvtMsg_5
   \   000024   7E80B700     SUB.B   #0xb7, R14
   \   000028   ED27         JEQ     ??tvsaSysEvtMsg_0
   \   00002A   7E802C00     SUB.B   #0x2c, R14
   \   00002E   EC23         JNE     ??tvsaSysEvtMsg_1
   \   000030   CC930100     CMP.B   #0x0, 0x1(R12)
   \   000034   E927         JEQ     ??tvsaSysEvtMsg_1
   \   000036   D253....     ADD.B   #0x1, &tvsaCnfErrCnt
   \   00003A   E623         JNE     ??tvsaSysEvtMsg_1
   \   00003C   F243....     MOV.B   #0xff, &tvsaCnfErrCnt
   \   000040   E33F         JMP     ??tvsaSysEvtMsg_1
   \                     ??tvsaSysEvtMsg_5:
   \   000042   1F4C2400     MOV.W   0x24(R12), R15
   \   000046   CF930000     CMP.B   #0x0, 0(R15)
   \   00004A   DE23         JNE     ??tvsaSysEvtMsg_1
   \   00004C   ........     CALLA   #tvsaDataRx
   \   000050   DB3F         JMP     ??tvsaSysEvtMsg_1
    360            }
    361          }
   \                     ??tvsaSysEvtMsg_4:
   \   000052   3A41         POP.W   R10
   \   000054   1001         RETA
    362          
    363          #if !TVSA_DONGLE
    364          /**************************************************************************************************
    365           * @fn          tvsaDataCalc
    366           *
    367           * @brief       This function is called by tvsaAppEvt() to calculate the data for a TVSA report.
    368           *
    369           * input parameters
    370           *
    371           * None.
    372           *
    373           * output parameters
    374           *
    375           * None.
    376           *
    377           * @return      None.
    378           **************************************************************************************************
    379           */
    380          static void tvsaDataCalc(void)
    381          {
    382            if (INVALID_NODE_ADDR == tvsaAddr)
    383            {
    384              return;
    385            }
    386          
    387            if (ZSuccess != osal_start_timerEx(tvsaTaskId, TVSA_EVT_DAT, TVSA_DLY_DAT))
    388            {
    389              (void)osal_set_event(tvsaTaskId, TVSA_EVT_DAT);
    390            }
    391          
    392            HalCalcTV(tvsaDat);
    393          #if TVSA_DATA_CNF
    394            tvsaDat[TVSA_RTG_IDX] = tvsaCnfErrCnt;
    395          #else
    396            tvsaDat[TVSA_RTG_IDX] = 0;
    397          #endif
    398            osal_set_event(tvsaTaskId, TVSA_EVT_REQ);
    399          }
    400          
    401          /**************************************************************************************************
    402           * @fn          tvsaDataReq
    403           *
    404           * @brief       This function is called by tvsaAppEvt() to send a TVSA data report.
    405           *
    406           * input parameters
    407           *
    408           * None.
    409           *
    410           * output parameters
    411           *
    412           * None.
    413           *
    414           * @return      None.
    415           **************************************************************************************************
    416           */
    417          static void tvsaDataReq(void)
    418          {
    419            afAddrType_t addr;
    420            
    421            addr.addr.shortAddr = tvsaAddr;
    422            addr.addrMode = afAddr16Bit;
    423            addr.endPoint = TVSA_ENDPOINT;
    424          
    425            if (afStatus_SUCCESS != AF_DataRequest(&addr, (endPointDesc_t *)&TVSA_epDesc, TVSA_CLUSTER_ID,
    426                                                    TVSA_DAT_LEN, tvsaDat, &tvsaTSN,
    427                                                    AF_DISCV_ROUTE
    428          #if TVSA_DATA_CNF
    429                                                  | AF_ACK_REQUEST
    430          #endif
    431                                                   ,AF_DEFAULT_RADIUS))
    432            {
    433              osal_set_event(tvsaTaskId, TVSA_EVT_REQ);
    434            }
    435            else
    436            {
    437              tvsaCnt++;
    438            }
    439          }
    440          
    441          /**************************************************************************************************
    442           * @fn          tvsaZdoStateChange
    443           *
    444           * @brief       This function is called by tvsaSysEvtMsg() for a ZDO_STATE_CHANGE message.
    445           *
    446           * input parameters
    447           *
    448           * None.
    449           *
    450           * output parameters
    451           *
    452           * None.
    453           *
    454           * @return      None.
    455           **************************************************************************************************
    456           */
    457          static void tvsaZdoStateChange(void)
    458          {
    459            (void)osal_stop_timerEx(tvsaTaskId, TVSA_EVT_DAT);
    460          
    461            if ((DEV_ZB_COORD == devState) || (DEV_ROUTER == devState) || (DEV_END_DEVICE == devState))
    462            {
    463              uint16 tmp = NLME_GetCoordShortAddr();
    464              uint8 dly = TVSA_STG_DAT;
    465          
    466              tvsaDat[TVSA_PAR_LSB] = LO_UINT16(tmp);
    467              tvsaDat[TVSA_PAR_MSB] = HI_UINT16(tmp);
    468              if ((DEV_ROUTER == devState) || (DEV_ZB_COORD == devState))
    469              {
    470                tvsaDat[TVSA_TYP_IDX] |= 0x80;
    471              }
    472              else
    473              {
    474                tvsaDat[TVSA_TYP_IDX] &= (0xFF ^ 0x80);
    475              }
    476          
    477          #if TVSA_DONGLE_IS_ZC
    478              if (INVALID_NODE_ADDR == tvsaAddr)
    479              {
    480                // Assume ZC is the TVSA Dongle until a TVSA_CMD_BEG gives a different address.
    481                tvsaAddr = NWK_PAN_COORD_ADDR;
    482              }
    483          #endif
    484          
    485              if (INVALID_NODE_ADDR != tvsaAddr)
    486              {
    487                if (ZSuccess != osal_start_timerEx(tvsaTaskId, TVSA_EVT_DAT, (dly + TVSA_DLY_MIN)))
    488                {
    489                  (void)osal_set_event(tvsaTaskId, TVSA_EVT_DAT);
    490                }
    491              }
    492          
    493          #if !TVSA_DONGLE
    494              if (0 == voltageAtTemp22)
    495              {
    496                HalInitTV();
    497                (void)osal_cpyExtAddr(tvsaDat+TVSA_IEE_IDX, &aExtendedAddress);
    498              }
    499          #endif
    500            }
    501          #if defined LCD_SUPPORTED
    502            HalLcdWriteValue(devState, 10, HAL_LCD_LINE_3);
    503          #endif
    504          }
    505          
    506          #else // if TVSA_DONGLE
    507          /**************************************************************************************************
    508           * @fn          tvsaAnnce
    509           *
    510           * @brief       This function is called by tvsaAppEvt() to send a TVSA announce to start or stop.
    511           *
    512           * input parameters
    513           *
    514           * None.
    515           *
    516           * output parameters
    517           *
    518           * None.
    519           *
    520           * @return      None.
    521           **************************************************************************************************
    522           */

   \                                 In  segment CODE, align 2
   \                     ?Subroutine0:
   \   000000   ........     CALLA   #?Subroutine3
   \                     ??CrossCallReturnLabel_6:
   \   000004   ........     BRA     #osal_set_event

   \                                 In  segment CODE, align 2
   \                     ?Subroutine3:
   \   000000   3D400040     MOV.W   #0x4000, R13
   \   000004   5C42....     MOV.B   &tvsaTaskId, R12
   \   000008   1001         RETA

   \                                 In  segment CODE, align 2
    523          static void tvsaAnnce(void)
   \                     tvsaAnnce:
    524          {
   \   000000   31801000     SUB.W   #0x10, SP
    525            uint8 msg[3];
    526            afAddrType_t addr;
    527            
    528            addr.addr.shortAddr = NWK_BROADCAST_SHORTADDR_DEVALL;
   \   000004   B1430400     MOV.W   #0xffff, 0x4(SP)
    529            addr.addrMode = afAddrBroadcast;
   \   000008   F1400F000C00 MOV.B   #0xf, 0xc(SP)
    530            addr.endPoint = TVSA_ENDPOINT;
   \   00000E   F14003000D00 MOV.B   #0x3, 0xd(SP)
    531          
    532            if (INVALID_NODE_ADDR != tvsaAddr)
   \   000014   B290FEFF.... CMP.W   #0xfffe, &tvsaAddr
   \   00001A   0824         JEQ     ??tvsaAnnce_0
    533            {
    534              msg[TVSA_CMD_IDX] = TVSA_CMD_BEG;
   \   00001C   D1430000     MOV.B   #0x1, 0(SP)
    535              if (ZSuccess != osal_start_timerEx(tvsaTaskId, TVSA_EVT_ANN, TVSA_DLY_ANN))
   \   000020   ........     CALLA   #?Subroutine1
   \                     ??CrossCallReturnLabel_2:
   \   000024   0524         JEQ     ??tvsaAnnce_1
    536              {
    537                (void)osal_set_event(tvsaTaskId, TVSA_EVT_ANN);
   \   000026   ........     CALLA   #?Subroutine0
    538              }
    539            }
   \                     ??CrossCallReturnLabel_0:
   \   00002A   023C         JMP     ??tvsaAnnce_1
    540            else
    541            {
    542              msg[TVSA_CMD_IDX] = TVSA_CMD_END;
   \                     ??tvsaAnnce_0:
   \   00002C   E1430000     MOV.B   #0x2, 0(SP)
    543            }
    544          
    545            msg[TVSA_ADR_LSB] = LO_UINT16(tvsaAddr);
   \                     ??tvsaAnnce_1:
   \   000030   D142....0100 MOV.B   &tvsaAddr, 0x1(SP)
    546            msg[TVSA_ADR_MSB] = HI_UINT16(tvsaAddr);
   \   000036   D142....0200 MOV.B   &tvsaAddr + 1, 0x2(SP)
    547          
    548            if (afStatus_SUCCESS != AF_DataRequest(&addr, (endPointDesc_t *)&TVSA_epDesc, TVSA_CLUSTER_ID,
    549                                                    3, msg, &tvsaTSN, AF_TX_OPTIONS_NONE, AF_DEFAULT_RADIUS))
   \   00003C   70121E00     PUSH.B  #0x1e
   \   000040   4312         PUSH.B  #0x0
   \   000042   3012....     PUSH.W  #tvsaTSN
   \   000046   0F41         MOV.W   SP, R15
   \   000048   3F500600     ADD.W   #0x6, R15
   \   00004C   0F12         PUSH.W  R15
   \   00004E   3F400300     MOV.W   #0x3, R15
   \   000052   2E43         MOV.W   #0x2, R14
   \   000054   3D40....     MOV.W   #TVSA_epDesc, R13
   \   000058   0C41         MOV.W   SP, R12
   \   00005A   3C500C00     ADD.W   #0xc, R12
   \   00005E   ........     CALLA   #AF_DataRequest
   \   000062   3152         ADD.W   #0x8, SP
   \   000064   4C93         CMP.B   #0x0, R12
   \   000066   0724         JEQ     ??tvsaAnnce_2
    550            {
    551              osal_set_event(tvsaTaskId, TVSA_EVT_REQ);
   \   000068   3D400020     MOV.W   #0x2000, R13
   \   00006C   5C42....     MOV.B   &tvsaTaskId, R12
   \   000070   ........     CALLA   #osal_set_event
   \   000074   023C         JMP     ??tvsaAnnce_3
    552            }
    553            else
    554            {
    555              tvsaCnt++;
   \                     ??tvsaAnnce_2:
   \   000076   9253....     ADD.W   #0x1, &tvsaCnt
    556            }
    557          }
   \                     ??tvsaAnnce_3:
   \   00007A   31501000     ADD.W   #0x10, SP
   \   00007E   1001         RETA

   \                                 In  segment CODE, align 2
   \                     ?Subroutine1:
   \   000000   3E4060EA     MOV.W   #0xea60, R14
   \   000004   ........     CALLA   #?Subroutine3
   \                     ??CrossCallReturnLabel_7:
   \   000008   ........     CALLA   #osal_start_timerEx
   \   00000C   4C93         CMP.B   #0x0, R12
   \   00000E   1001         RETA
    558          
    559          /**************************************************************************************************
    560           * @fn          tvsaDataRx
    561           *
    562           * @brief       This function is called by tvsaAfMsgRx() to process incoming TVSA data.
    563           *
    564           * input parameters
    565           *
    566           * @param       msg - A pointer to the afIncomingMSGPacket_t packet.
    567           *
    568           * output parameters
    569           *
    570           * None.
    571           *
    572           * @return      None.
    573           **************************************************************************************************
    574           */

   \                                 In  segment CODE, align 2
    575          static void tvsaDataRx(afIncomingMSGPacket_t *msg)
   \                     tvsaDataRx:
    576          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   31801000     SUB.W   #0x10, SP
   \   000006   0B4C         MOV.W   R12, R11
    577            uint8 fcs = 0, idx;
   \   000008   4843         MOV.B   #0x0, R8
    578          
    579            // Last announce broadcast to stop must have expired before a parent could forward to a ZED.
    580            if (INVALID_NODE_ADDR == tvsaAddr)
   \   00000A   B290FEFF.... CMP.W   #0xfffe, &tvsaAddr
   \   000010   0220         JNE     ??tvsaDataRx_1
    581            {
    582              (void)osal_set_event(tvsaTaskId, TVSA_EVT_ANN);
   \   000012   ........     CALLA   #?Subroutine0
    583            }
    584          
    585            tvsaBuf[TVSA_SOP_IDX] = TVSA_SOP_VAL;
   \                     ??tvsaDataRx_1:
   \   000016   F240FE00.... MOV.B   #0xfe, &tvsaBuf
    586            tvsaBuf[TVSA_ADR_LSB] = LO_UINT16(msg->srcAddr.addr.shortAddr);
   \   00001C   0A4B         MOV.W   R11, R10
   \   00001E   3A500600     ADD.W   #0x6, R10
   \   000022   E24A....     MOV.B   @R10, &tvsaBuf + 1
    587            tvsaBuf[TVSA_ADR_MSB] = HI_UINT16(msg->srcAddr.addr.shortAddr);
   \   000026   D24A0100.... MOV.B   0x1(R10), &tvsaBuf + 2
    588          
    589            // 1st byte of message is skipped - CMD is always 0 for data.
    590            (void)osal_memcpy(tvsaBuf+TVSA_DAT_OFF, msg->cmd.Data+1, TVSA_DAT_LEN-1);
   \   00002C   3E400F00     MOV.W   #0xf, R14
   \   000030   1D4B2400     MOV.W   0x24(R11), R13
   \   000034   1D53         ADD.W   #0x1, R13
   \   000036   3C40....     MOV.W   #tvsaBuf + 3, R12
   \   00003A   ........     CALLA   #osal_memcpy
    591          
    592            for (idx = TVSA_ADR_LSB; idx < TVSA_FCS_IDX; idx++)
   \   00003E   5F43         MOV.B   #0x1, R15
    593            {
    594              fcs ^= tvsaBuf[idx];
   \                     ??tvsaDataRx_0:
   \   000040   58EF....     XOR.B   tvsaBuf(R15), R8
    595            }
   \   000044   5F53         ADD.B   #0x1, R15
   \   000046   7F901200     CMP.B   #0x12, R15
   \   00004A   FA2B         JNC     ??tvsaDataRx_0
    596            tvsaBuf[idx] = fcs;
   \   00004C   CF48....     MOV.B   R8, tvsaBuf(R15)
    597            
    598          #ifdef TVSA_DEMO
    599          
    600            HalUARTWrite(TVSA_PORT, tvsaBuf, TVSA_BUF_LEN);
    601          
    602          #else
    603            
    604            
    605            uint8 deviceTemp;
    606            uint8 deviceVolt;
    607            uint8 parentAddrLSB;
    608            uint8 parentAddrMSB;
    609            uint8 zsensorBuf[15];
    610            
    611            parentAddrLSB= tvsaBuf[11];
   \   000050   5E42....     MOV.B   &tvsaBuf + 11, R14
    612            parentAddrMSB= tvsaBuf[12];  
   \   000054   5F42....     MOV.B   &tvsaBuf + 12, R15
    613            deviceTemp = tvsaBuf[13];
   \   000058   5D42....     MOV.B   &tvsaBuf + 13, R13
    614            deviceVolt = tvsaBuf[14];
   \   00005C   5B42....     MOV.B   &tvsaBuf + 14, R11
    615            
    616            //Start of Frame Delimiter
    617            zsensorBuf[0]=0xFE;
   \   000060   F140FE000000 MOV.B   #0xfe, 0(SP)
    618            
    619            
    620            zsensorBuf[1]=10;
   \   000066   F1400A000100 MOV.B   #0xa, 0x1(SP)
    621            zsensorBuf[2]=LO_UINT16(0x8746);
   \   00006C   F14046000200 MOV.B   #0x46, 0x2(SP)
    622            zsensorBuf[3]=HI_UINT16(0x8746);
   \   000072   F14087000300 MOV.B   #0x87, 0x3(SP)
    623            
    624            //Source Address
    625            zsensorBuf[4] = LO_UINT16(msg->srcAddr.addr.shortAddr);
   \   000078   E14A0400     MOV.B   @R10, 0x4(SP)
    626            zsensorBuf[5] = HI_UINT16(msg->srcAddr.addr.shortAddr);
   \   00007C   D14A01000500 MOV.B   0x1(R10), 0x5(SP)
    627            
    628            zsensorBuf[6]=LO_UINT16(2);
   \   000082   E1430600     MOV.B   #0x2, 0x6(SP)
    629            zsensorBuf[7]=HI_UINT16(2);
   \   000086   C1430700     MOV.B   #0x0, 0x7(SP)
    630            zsensorBuf[8]=LO_UINT16(4);
   \   00008A   E1420800     MOV.B   #0x4, 0x8(SP)
    631            zsensorBuf[9]=HI_UINT16(4);
   \   00008E   C1430900     MOV.B   #0x0, 0x9(SP)
    632            
    633            //Temperature and Voltage Data
    634            zsensorBuf[10]= deviceTemp;
   \   000092   C14D0A00     MOV.B   R13, 0xa(SP)
    635            zsensorBuf[11]=deviceVolt;
   \   000096   C14B0B00     MOV.B   R11, 0xb(SP)
    636            
    637            //Parent Address
    638            zsensorBuf[12]=parentAddrLSB;
   \   00009A   C14E0C00     MOV.B   R14, 0xc(SP)
    639            zsensorBuf[13]=parentAddrMSB;
   \   00009E   C14F0D00     MOV.B   R15, 0xd(SP)
    640          
    641          
    642            //FCS Check on the middle 13 bytes
    643            zsensorBuf[14] = calcFCS(&zsensorBuf[1], 13 );
   \   0000A2   7D400D00     MOV.B   #0xd, R13
   \   0000A6   0C41         MOV.W   SP, R12
   \   0000A8   1C53         ADD.W   #0x1, R12
   \   0000AA   ........     CALLA   #calcFCS
   \   0000AE   C14C0E00     MOV.B   R12, 0xe(SP)
    644          
    645          
    646            HalUARTWrite(TVSA_PORT, zsensorBuf, 15);
   \   0000B2   3E400F00     MOV.W   #0xf, R14
   \   0000B6   ........     CALLA   #?Subroutine2
    647            
    648            
    649          #endif  
    650            
    651          }
   \                     ??CrossCallReturnLabel_3:
   \   0000BA   31501000     ADD.W   #0x10, SP
   \   0000BE   3817         POPM.W  #0x4, R11
   \   0000C0   1001         RETA

   \                                 In  segment CODE, align 2
   \                     ?Subroutine2:
   \   000000   0D41         MOV.W   SP, R13
   \   000002   2D52         ADD.W   #0x4, R13
   \   000004   4C43         MOV.B   #0x0, R12
   \   000006   ........     BRA     #HalUARTWrite
    652          
    653          /**************************************************************************************************
    654           * @fn          tvsaUartRx
    655           *
    656           * @brief       This function is the Uart callback for Rx data.
    657           *
    658           * input parameters
    659           *
    660           * @param       port - Don't care.
    661           * @param       event - Don't care.
    662           *
    663           * output parameters
    664           *
    665           * None.
    666           *
    667           * @return      None.
    668           **************************************************************************************************
    669           */

   \                                 In  segment CODE, align 2
    670          static void tvsaUartRx(uint8 port, uint8 event)
   \                     tvsaUartRx:
    671          {
   \   000000   31800600     SUB.W   #0x6, SP
    672          #ifdef TVSA_DEMO
    673            uint8 ch;
    674          
    675            while (HalUARTRead(TVSA_PORT, &ch, 1))
    676            {
    677              switch (tvsaState)
    678              {
    679              case SOP_STATE:
    680                if (TVSA_SOP_VAL == ch)
    681                {
    682                  tvsaState = CMD_STATE;
    683                }
    684                break;
    685          
    686              case CMD_STATE:
    687                tvsaCmd = ch;
    688                tvsaState = FCS_STATE;
    689                break;
    690          
    691              case FCS_STATE:
    692                if (tvsaCmd == ch)
    693                {
    694                  if (tvsaCmd == TVSA_CMD_BEG)
    695                  {
    696                    tvsaAddr = NLME_GetShortAddr();
    697                  }
    698                  else if (tvsaCmd == TVSA_CMD_END)
    699                  {
    700                    tvsaAddr = INVALID_NODE_ADDR;
    701                  }
    702                  (void)osal_set_event(tvsaTaskId, TVSA_EVT_ANN);
    703                }
    704          
    705                tvsaState = SOP_STATE;
    706                break;
    707          
    708              default:
    709               break;
    710              }
    711            }
    712          #else
    713            uint8 ch[5];
    714            
    715            HalUARTRead(TVSA_PORT, ch, 5);
   \   000004   3E400500     MOV.W   #0x5, R14
   \   000008   0D41         MOV.W   SP, R13
   \   00000A   0D53         ADD.W   #0x0, R13
   \   00000C   4C43         MOV.B   #0x0, R12
   \   00000E   ........     CALLA   #HalUARTRead
    716            if (ch[2]==0x21)   //if statement to check for command from Z-Sensor Monitor
   \   000012   F19021000200 CMP.B   #0x21, 0x2(SP)
   \   000018   0220         JNE     ??tvsaUartRx_0
    717            {
    718              sysPingRsp();
   \   00001A   ........     CALLA   #sysPingRsp
    719            }
    720          #endif
    721          }
   \                     ??tvsaUartRx_0:
   \   00001E   31500600     ADD.W   #0x6, SP
   \   000022   1001         RETA
    722          
    723          /**************************************************************************************************
    724           * @fn          tvsaZdoStateChange
    725           *
    726           * @brief       This function is called by tvsaSysEvtMsg() for a ZDO_STATE_CHANGE message.
    727           *
    728           * input parameters
    729           *
    730           * None.
    731           *
    732           * output parameters
    733           *
    734           * None.
    735           *
    736           * @return      None.
    737           **************************************************************************************************
    738           */

   \                                 In  segment CODE, align 2
    739          static void tvsaZdoStateChange(void)
   \                     tvsaZdoStateChange:
    740          {
    741            (void)osal_stop_timerEx(tvsaTaskId, TVSA_EVT_ANN);
   \   000000   ........     CALLA   #?Subroutine3
   \                     ??CrossCallReturnLabel_5:
   \   000004   ........     CALLA   #osal_stop_timerEx
    742          
    743            if ((DEV_ZB_COORD == devState) || (DEV_ROUTER == devState) || (DEV_END_DEVICE == devState))
   \   000008   5E42....     MOV.B   &devState, R14
   \   00000C   7E900900     CMP.B   #0x9, R14
   \   000010   0624         JEQ     ??tvsaZdoStateChange_0
   \   000012   7E900700     CMP.B   #0x7, R14
   \   000016   0324         JEQ     ??tvsaZdoStateChange_0
   \   000018   7E900600     CMP.B   #0x6, R14
   \   00001C   0B20         JNE     ??tvsaZdoStateChange_1
    744            {
    745          #if TVSA_DONGLE_IS_ZC
    746              if (INVALID_NODE_ADDR == tvsaAddr)
   \                     ??tvsaZdoStateChange_0:
   \   00001E   B290FEFF.... CMP.W   #0xfffe, &tvsaAddr
   \   000024   0220         JNE     ??tvsaZdoStateChange_2
    747              {
    748                // Assume ZC is the TVSA Dongle until a TVSA_CMD_BEG gives a different address.
    749                tvsaAddr = NWK_PAN_COORD_ADDR;
   \   000026   8243....     MOV.W   #0x0, &tvsaAddr
    750              }
    751          #endif
    752          
    753              if (INVALID_NODE_ADDR != tvsaAddr)
    754              {
    755                if (ZSuccess != osal_start_timerEx(tvsaTaskId, TVSA_EVT_ANN, TVSA_DLY_ANN))
   \                     ??tvsaZdoStateChange_2:
   \   00002A   ........     CALLA   #?Subroutine1
   \                     ??CrossCallReturnLabel_1:
   \   00002E   0224         JEQ     ??tvsaZdoStateChange_1
    756                {
    757                  (void)osal_set_event(tvsaTaskId, TVSA_EVT_ANN);
   \   000030   ........     CALLA   #?Subroutine0
    758                }
    759              }
    760            }
    761          }
   \                     ??tvsaZdoStateChange_1:
   \   000034   1001         RETA
    762          
    763          #ifndef TVSA_DEMO
    764          /******************************************************************************
    765           * @fn          calcFCS
    766           *
    767           * @brief       This function calculates the FCS checksum for the serial message 
    768           *
    769           * @param       pBuf - Pointer to the end of a buffer to calculate the FCS.
    770           *              len - Length of the pBuf.
    771           *
    772           * @return      The calculated FCS.
    773           ******************************************************************************
    774           */

   \                                 In  segment CODE, align 2
    775          static uint8 calcFCS(uint8 *pBuf, uint8 len)
   \                     calcFCS:
    776          {
    777            uint8 rtrn = 0;
   \   000000   4F43         MOV.B   #0x0, R15
   \   000002   013C         JMP     ??calcFCS_1
    778          
    779            while (len--)
    780            {
    781              rtrn ^= *pBuf++;
   \                     ??calcFCS_0:
   \   000004   7FEC         XOR.B   @R12+, R15
    782            }
   \                     ??calcFCS_1:
   \   000006   4E4D         MOV.B   R13, R14
   \   000008   7D53         ADD.B   #0xff, R13
   \   00000A   4E93         CMP.B   #0x0, R14
   \   00000C   FB23         JNE     ??calcFCS_0
    783          
    784            return rtrn;
   \   00000E   4C4F         MOV.B   R15, R12
   \   000010   1001         RETA
    785          }
    786          
    787          /*************************************************************************************************
    788           * @fn          sysPingRsp
    789           *
    790           * @brief       Build and send Ping response
    791           *
    792           * @param       none
    793           *              
    794           * @return      none
    795          **************************************************************************************************
    796           */

   \                                 In  segment CODE, align 2
    797          static void sysPingRsp(void)
   \                     sysPingRsp:
    798          {
   \   000000   3182         SUB.W   #0x8, SP
    799            uint8 pingBuff[7];
    800            
    801            // Start of Frame Delimiter
    802            pingBuff[0] = 0xFE;
   \   000002   F140FE000000 MOV.B   #0xfe, 0(SP)
    803            
    804            // Length
    805            pingBuff[1] = 0x02; 
   \   000008   E1430100     MOV.B   #0x2, 0x1(SP)
    806            
    807            // Command type
    808            pingBuff[2] = LO_UINT16(0x0161); 
   \   00000C   F14061000200 MOV.B   #0x61, 0x2(SP)
    809            pingBuff[3] = HI_UINT16(0x0161);
   \   000012   D1430300     MOV.B   #0x1, 0x3(SP)
    810            
    811            // Stack profile
    812            pingBuff[4] = LO_UINT16(0x0041);
   \   000016   F14041000400 MOV.B   #0x41, 0x4(SP)
    813            pingBuff[5] = HI_UINT16(0x0041);
   \   00001C   C1430500     MOV.B   #0x0, 0x5(SP)
    814            
    815            // Frame Check Sequence
    816            pingBuff[6] = calcFCS(&pingBuff[1], 5);
   \   000020   7D400500     MOV.B   #0x5, R13
   \   000024   0C41         MOV.W   SP, R12
   \   000026   1C53         ADD.W   #0x1, R12
   \   000028   ........     CALLA   #calcFCS
   \   00002C   C14C0600     MOV.B   R12, 0x6(SP)
    817            
    818            
    819            HalUARTWrite(TVSA_PORT,pingBuff, 7);
   \   000030   3E400700     MOV.W   #0x7, R14
   \   000034   ........     CALLA   #?Subroutine2
    820          
    821          }
   \                     ??CrossCallReturnLabel_4:
   \   000038   3152         ADD.W   #0x8, SP
   \   00003A   1001         RETA
    822          
    823          
    824          #endif
    825          
    826          
    827          
    828          
    829          
    830          #endif
    831          
    832          /**************************************************************************************************
    833          */

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
       4  calcFCS
      12  sysPingRsp
            12 -> HalUARTWrite
            12 -> calcFCS
      28  tvsaAnnce
            28 -> AF_DataRequest
            20 -> osal_set_event
            20 -> osal_start_timerEx
       8  tvsaAppEvt
             8 -> tvsaAnnce
             8 -> tvsaSysEvtMsg
      40  tvsaAppInit
            40 -> HalUARTOpen
            40 -> afRegister
      28  tvsaDataRx
            28 -> HalUARTWrite
            28 -> calcFCS
            28 -> osal_memcpy
            28 -> osal_set_event
       6  tvsaSysEvtMsg
             6 -> osal_msg_deallocate
             6 -> osal_msg_receive
             6 -> tvsaDataRx
             6 -> tvsaZdoStateChange
      10  tvsaUartRx
            10 -> HalUARTRead
            10 -> sysPingRsp
       4  tvsaZdoStateChange
             4 -> osal_set_event
             4 -> osal_start_timerEx
             4 -> osal_stop_timerEx


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       8  ?Subroutine0
      16  ?Subroutine1
      10  ?Subroutine2
      10  ?Subroutine3
       2  TVSA_ClusterList
      14  TVSA_SimpleDesc
       8  TVSA_epDesc
      18  calcFCS
      60  sysPingRsp
       2  tvsaAddr
     128  tvsaAnnce
      44  tvsaAppEvt
      96  tvsaAppInit
      19  tvsaBuf
       1  tvsaCnfErrCnt
       2  tvsaCnt
     194  tvsaDataRx
      86  tvsaSysEvtMsg
       1  tvsaTSN
       1  tvsaTaskId
      36  tvsaUartRx
      54  tvsaZdoStateChange

 
 760 bytes in segment CODE
  24 bytes in segment DATA16_C
  26 bytes in segment DATA16_Z
 
 760 bytes of CODE  memory
  24 bytes of CONST memory
  26 bytes of DATA  memory

Errors: none
Warnings: none
