###############################################################################
#                                                                             #
# IAR C/C++ Compiler V5.51.2.50607/W32 for MSP430       04/Apr/2013  15:23:20 #
# Copyright 1996-2012 IAR Systems AB.                                         #
#                                                                             #
#    __rt_version  =  3                                                       #
#    __double_size =  32                                                      #
#    __reg_r4      =  free                                                    #
#    __reg_r5      =  free                                                    #
#    __pic         =  no                                                      #
#    __core        =  430X                                                    #
#    __data_model  =  small                                                   #
#    Source file   =  C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\Source\zap_app.c                   #
#    Command line  =  -f C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2. #
#                     5.1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\Source\zap.c #
#                     fg (-DZAP_PHY_SPI=1 -DZAP_PHY_UART=!ZAP_PHY_SPI         #
#                     -DZAP_PHY_RESET_ZNP=TRUE -DZAP_ZNP_MT=FALSE             #
#                     -DZAP_APP_MSG=FALSE -DZAP_SBL_PROXY=FALSE               #
#                     -DZAP_AUTO_CFG=TRUE -DZAP_AUTO_START=TRUE               #
#                     -DZAP_NV_RESTORE=FALSE -DLCD_SUPPORTED                  #
#                     -DZAP_AF_DATA_REQ_FRAG=FALSE                            #
#                     -DZAP_AF_DATA_REQ_AREQ=!ZAP_AF_DATA_REQ_FRAG            #
#                     -DZAP_ZDO_STARTUP_AREQ=TRUE -DZAP_AF_FUNC               #
#                     -DZAP_SAPI_FUNC -DZAP_SYS_FUNC -DZAP_UTIL_FUNC          #
#                     -DZAP_ZDO_FUNC -DSECURE=0 -DZG_SECURE_DYNAMIC=0         #
#                     "-DDEFAULT_CHANLIST=(uint32)0x00000800"                 #
#                     -DZDAPP_CONFIG_PAN_ID=0xFFFF -DPOLL_RATE=1000           #
#                     -DNWK_START_DELAY=100 -DMAX_BINDING_CLUSTER_IDS=4)      #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\Source\zap_app.c -D                #
#                     ZAP_DEVICETYPE=ZG_DEVICETYPE_COORDINATOR -D             #
#                     TVSA_DEVICE_ID=0x0016 -D TVSA_DONGLE=1 -D HAL_UART=1    #
#                     -lC "C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430- #
#                     2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\ZAP              #
#                     Coordinator\List\" -lA "C:\Users\student\Documents\GitH #
#                     ub\MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP54 #
#                     38\ZAP Coordinator\List\" --remarks --diag_suppress     #
#                     Pe001,Pe193,Pe236,Pe826 -o                              #
#                     "C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5. #
#                     1\Projects\zstack\ZAP\TVSA\EXP5438\ZAP                  #
#                     Coordinator\Obj\" --debug -D__MSP430F5438__ -e          #
#                     --double=32 --clib -I C:\Users\student\Documents\GitHub #
#                     \MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438 #
#                     \ -I C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430- #
#                     2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\..\Source\ -I    #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\Source\ -I      #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\hal\target\MSP5438ZAP\ -I                          #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\hal\include\ -I C:\Users\student\Documents\GitHub\ #
#                     MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\ #
#                     ..\..\..\..\..\Components\mac\include\ -I               #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\mt\ -I C:\Users\student\Documents\GitHub\MHMS\ZAP- #
#                     MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\ #
#                     ..\..\Components\osal\include\ -I                       #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\osal\mcu\msp430\ -I C:\Users\student\Documents\Git #
#                     Hub\MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5 #
#                     438\..\..\..\..\..\Components\services\saddr\ -I        #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\services\sdata\ -I C:\Users\student\Documents\GitH #
#                     ub\MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP54 #
#                     38\..\..\..\..\..\Components\stack\af\ -I               #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\stack\nwk\ -I C:\Users\student\Documents\GitHub\MH #
#                     MS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\.. #
#                     \..\..\..\..\Components\stack\sapi\ -I                  #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\stack\sec\ -I C:\Users\student\Documents\GitHub\MH #
#                     MS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\.. #
#                     \..\..\..\..\Components\stack\sys\ -I                   #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\stack\zdo\ -I C:\Users\student\Documents\GitHub\MH #
#                     MS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\.. #
#                     \..\..\..\..\Components\zmac\ -I                        #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\zmac\f8w\ --core=430X --data_model=small -Ohz      #
#                     --multiplier=32 --multiplier_location=4C0               #
#                     --require_prototypes --hw_workaround=CPU40              #
#                     --hw_workaround=CPU42                                   #
#    List file     =  C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\ZAP                   #
#                     Coordinator\List\zap_app.lst                            #
#    Object file   =  C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\ZAP                   #
#                     Coordinator\Obj\zap_app.r43                             #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\Source\zap_app.c
      1          /**************************************************************************************************
      2              Filename:       zap_app.c
      3              Revised:        $Date: 2011-07-05 11:35:58 -0700 (Tue, 05 Jul 2011) $
      4              Revision:       $Revision: 26589 $
      5          
      6              Description:
      7          
      8              This file defines the functionality of the ZNP Application Processor.
      9          
     10          
     11              Copyright 2009-2011 Texas Instruments Incorporated. All rights reserved.
     12          
     13              IMPORTANT: Your use of this Software is limited to those specific rights
     14              granted under the terms of a software license agreement between the user
     15              who downloaded the software, his/her employer (which must be your employer)
     16              and Texas Instruments Incorporated (the "License").  You may not use this
     17              Software unless you agree to abide by the terms of the License. The License
     18              limits your use, and you acknowledge, that the Software may not be modified,
     19              copied or distributed unless embedded on a Texas Instruments microcontroller
     20              or used solely and exclusively in conjunction with a Texas Instruments radio
     21              frequency transceiver, which is integrated into your product.  Other than for
     22              the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     23              works of, modify, distribute, perform, display or sell this Software and/or
     24              its documentation for any purpose.
     25          
     26              YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     27              PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     28              INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     29              NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     30              TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     31              NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     32              LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     33              INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     34              OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     35              OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     36              (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     37          
     38              Should you have any questions regarding your right to use this Software,
     39              contact Texas Instruments Incorporated at www.TI.com.
     40          **************************************************************************************************/
     41          
     42          /* ------------------------------------------------------------------------------------------------
     43           *                                          Includes
     44           * ------------------------------------------------------------------------------------------------
     45           */
     46          
     47          #include "hal_board.h"

   \                                 In  segment DATA16_AN, at 0x120
   \   union <unnamed> _A_PMMCTL0_L
   \                     _A_PMMCTL0_L:
   \   000000                DS8 2
     48          #include "hal_key.h"
     49          #include "hal_lcd.h"
     50          #include "hal_led.h"
     51          #include "mt.h"
     52          #include "mt_rpc.h"
     53          #include "mt_sys.h"
     54          #include "mt_uart.h"
     55          #include "OSAL.h"
     56          #include "OSAL_Tasks.h"
     57          //MHMS: Inlude NV memory read and write stuff
     58          #include "OSAL_Nv.h"
     59          #include "sapi.h"
     60          #include "zap_app.h"
     61          #include "zap_phy.h"
     62          #include "zap_znp.h"
     63          #include "ZDApp.h"
     64          #include "ZDObject.h"
     65          #include "ZComDef.h"
     66          
     67          /* ------------------------------------------------------------------------------------------------
     68           *                                           Constants
     69           * ------------------------------------------------------------------------------------------------
     70           */
     71          
     72          #if !defined ZAP_APP_PORT
     73          #define ZAP_APP_PORT  0
     74          #endif
     75          
     76          #if !defined ZAP_APP_LED
     77          #define ZAP_APP_LED   FALSE
     78          #endif
     79          
     80          #if !defined ZAP_APP_KEYS
     81          #define ZAP_APP_KEYS  TRUE
     82          #endif
     83          
     84          /* ------------------------------------------------------------------------------------------------
     85           *                                           Typedefs
     86           * ------------------------------------------------------------------------------------------------
     87           */
     88          
     89          typedef void (*zapProcessFunc_t)(uint8 port, uint8 *pBuf);
     90          
     91          /* ------------------------------------------------------------------------------------------------
     92           *                                           Macros
     93           * ------------------------------------------------------------------------------------------------
     94           */
     95          
     96          /* ------------------------------------------------------------------------------------------------
     97           *                                           Global Variables
     98           * ------------------------------------------------------------------------------------------------
     99           */
    100          //MHMS:Switches Logical type

   \                                 In  segment DATA16_I, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
    101          uint8 zLogicalType=ZG_DEVICETYPE_ROUTER;
   \                     zLogicalType:
   \   000000                DS8 1
   \   000001                REQUIRE `?<Initializer for zLogicalType>`

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    102          uint8 zapTaskId;
   \                     zapTaskId:
   \   000000                DS8 1
    103          
    104          // Hook for supporting more than 1 ZNP on different ports.
    105          // An example of use would be to set this to the desired port before invoking AF_DataRequest().

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    106          uint8 zapAppPort;
   \                     zapAppPort:
   \   000000                DS8 1
    107          
    108          // Count of the global ZNP variables that are cached locally on ZAP.
    109          #define ZAP_MON_INFO_CNT  5
    110          // IEEE Address (64-bit Extended Address) of the ZNP device.

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    111          uint8 znpIEEE[8];
   \                     znpIEEE:
   \   000000                DS8 8
    112          // ZigBee Network Address of the ZNP device.

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    113          uint16 znpAddr;
   \                     znpAddr:
   \   000000                DS8 2
    114          // ZigBee Network Address of the parent of the ZNP device.

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    115          uint16 znpParent;
   \                     znpParent:
   \   000000                DS8 2
    116          // ZigBee Network PanId.

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    117          uint16 znpPanId;
   \                     znpPanId:
   \   000000                DS8 2
    118          // ZNP variable indicating the current device state (from Z-Stack ZDO/ZD_App.c).

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    119          devStates_t devState;
   \                     devState:
   \   000000                DS8 1
    120          
    121          #if SECURE
    122          // ZNP variable read from NV at powerup by the ZGlobals manager - TODO: how to sync value with ZNP?
    123          uint8 zgSecurityMode = ZG_SECURITY_MODE;
    124          #endif
    125          
    126          // Trust center address

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    127          uint16 zgTrustCenterAddr = ZG_TRUSTCENTER_ADDR;
   \                     zgTrustCenterAddr:
   \   000000                DS8 2
    128          
    129          /* ------------------------------------------------------------------------------------------------
    130           *                                           Local Variables
    131           * ------------------------------------------------------------------------------------------------
    132           */
    133          

   \                                 In  segment DATA16_C, align 2, align-sorted
    134          static const zapProcessFunc_t zapProcessFunc[] =
   \                     zapProcessFunc:
   \   000000   00000000.... DC32 0H, zapSysProcessIncoming, 0H, 0H, zapAfProcessIncoming
   \            ....00000000
   \            00000000....
   \            ....        
   \   000014   ............ DC32 zapZdoProcessIncoming, zapSapiProcessIncoming
   \            ....        
   \   00001C   ........0000 DC32 zapUtilProcessIncoming, 0H, 0H
   \            000000000000
    135          {
    136            NULL,
    137          
    138          #if defined (ZAP_SYS_FUNC)
    139            zapSysProcessIncoming,
    140          #else
    141            NULL,
    142          #endif
    143          
    144          #if defined (ZAP_MAC_FUNC)
    145            zapMacProcessIncoming,
    146          #else
    147            NULL,
    148          #endif
    149          
    150          #if defined (ZAP_NWK_FUNC)
    151            zapNwkProcessIncoming,
    152          #else
    153            NULL,
    154          #endif
    155          
    156          #if defined (ZAP_AF_FUNC)
    157            zapAfProcessIncoming,
    158          #else
    159            NULL,
    160          #endif
    161          
    162          #if defined (ZAP_ZDO_FUNC)
    163            zapZdoProcessIncoming,
    164          #else
    165            NULL,
    166          #endif
    167          
    168          #if defined (ZAP_SAPI_FUNC)
    169            zapSapiProcessIncoming,
    170          #else
    171            NULL,
    172          #endif
    173          
    174          #if defined (ZAP_UTIL_FUNC)
    175            zapUtilProcessIncoming,
    176          #else
    177            NULL,
    178          #endif
    179          
    180          #if defined (ZAP_DEBUG_FUNC)
    181            zapDebugProcessIncoming,
    182          #else
    183            NULL,
    184          #endif
    185          
    186          #if defined (ZAP_APP_FUNC)
    187            zapApsProcessIncoming,
    188          #else
    189            NULL,
    190          #endif
    191          };
    192          
    193          #ifdef LCD_SUPPORTED

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    194          static uint16 zapDisAddr;
   \                     zapDisAddr:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    195          static uint16 zapDisPanId;
   \                     zapDisPanId:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    196          static uint8  zapDisIEEE[Z_EXTADDR_LEN];
   \                     zapDisIEEE:
   \   000000                DS8 8

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    197          static uint8  zapDisState;
   \                     zapDisState:
   \   000000                DS8 1
    198          #endif
    199          
    200          /* ------------------------------------------------------------------------------------------------
    201           *                                           Local Functions
    202           * ------------------------------------------------------------------------------------------------
    203           */
    204          
    205          #if ZAP_ZNP_MT
    206          #include "zap_phy_uart.c"
    207          #if ZAP_APP_MSG
    208          #define MT_APP_FUNC
    209          #include "MT_App.c"
    210          #endif
    211          #endif
    212          
    213          #ifdef LCD_SUPPORTED
    214          static void zapDisInfo(void);
    215          #endif
    216          static void zapMonInfo(void);
    217          #if ZAP_APP_KEYS
    218          static void zapKeys(keyChange_t *msg);
    219          #endif
    220          static void zapMonitor(void);
    221          static void zapSync(void);
    222          static void zapSysEvtMsg(void);
    223          
    224          //MHMS:Adding function from ZGlobals.c to avoid includes
    225          uint8 zgWriteStartupOptions( uint8 action, uint8 bitOptions );
    226          
    227          /*********************************************************************
    228           * @fn          zgWriteStartupOptions
    229           *
    230           * @brief       Writes bits into the ZCD_NV_STARTUP_OPTION NV Item.
    231           *
    232           * @param       action - ZG_STARTUP_SET set bit, ZG_STARTUP_CLEAR to
    233           *               clear bit. The set bit is an OR operation, and the
    234           *               clear bit is an AND ~(bitOptions) operation.
    235           *
    236           * @param       bitOptions - which bits to perform action on:
    237           *                      ZCD_STARTOPT_DEFAULT_CONFIG_STATE
    238           *                      ZCD_STARTOPT_DEFAULT_NETWORK_STATE
    239             
    240           *
    241           * @return      ZSUCCESS if successful
    242           */

   \                                 In  segment CODE, align 2
    243          uint8 zgWriteStartupOptions( uint8 action, uint8 bitOptions )
   \                     zgWriteStartupOptions:
    244          {
   \   000000   1B15         PUSHM.W #0x2, R11
   \   000002   2183         SUB.W   #0x2, SP
   \   000004   4B4C         MOV.B   R12, R11
   \   000006   4A4D         MOV.B   R13, R10
    245            uint8 status;
    246            uint8 startupOptions = 0;
   \   000008   C1430000     MOV.B   #0x0, 0(SP)
    247          
    248            status = osal_nv_read( ZCD_NV_STARTUP_OPTION,
    249                          0,
    250                          sizeof( startupOptions ),
    251                          &startupOptions );
   \   00000C   ........     CALLA   #?Subroutine4
   \                     ??CrossCallReturnLabel_6:
   \   000010   ........     CALLA   #osal_nv_read
    252          
    253            if ( status == ZSUCCESS )
   \   000014   4C93         CMP.B   #0x0, R12
   \   000016   0C20         JNE     ??zgWriteStartupOptions_0
    254            {
    255              if ( action == ZG_STARTUP_SET )
   \   000018   7B93         CMP.B   #0xff, R11
   \   00001A   0220         JNE     ??zgWriteStartupOptions_1
    256              {
    257                // Set bits
    258                startupOptions |= bitOptions;
   \   00001C   6AD1         BIS.B   @SP, R10
   \   00001E   023C         JMP     ??zgWriteStartupOptions_2
    259              }
    260              else
    261              {
    262                // Clear bits
    263                startupOptions &= (bitOptions ^ 0xFF);
   \                     ??zgWriteStartupOptions_1:
   \   000020   7AE3         XOR.B   #0xff, R10
   \   000022   6AF1         AND.B   @SP, R10
   \                     ??zgWriteStartupOptions_2:
   \   000024   C14A0000     MOV.B   R10, 0(SP)
    264              }
    265          
    266              // Changed?
    267              status = osal_nv_write( ZCD_NV_STARTUP_OPTION,
    268                           0,
    269                           sizeof( startupOptions ),
    270                           &startupOptions );
   \   000028   ........     CALLA   #?Subroutine4
    271            }
   \                     ??CrossCallReturnLabel_7:
   \   00002C   ........     CALLA   #osal_nv_write
    272          
    273            return ( status );
   \                     ??zgWriteStartupOptions_0:
   \   000030   2153         ADD.W   #0x2, SP
   \   000032   1A17         POPM.W  #0x2, R11
   \   000034   1001         RETA
    274          }

   \                                 In  segment CODE, align 2
   \                     ?Subroutine4:
   \   000000   0F41         MOV.W   SP, R15
   \   000002   2F52         ADD.W   #0x4, R15
   \   000004   1E43         MOV.W   #0x1, R14
   \   000006   0D43         MOV.W   #0x0, R13
   \   000008   3C400300     MOV.W   #0x3, R12
   \   00000C   1001         RETA
    275          /**************************************************************************************************
    276           * @fn          zapInit
    277           *
    278           * @brief       This function is the application's task initialization.
    279           *
    280           * input parameters
    281           *
    282           * None.
    283           *
    284           * output parameters
    285           *
    286           * None.
    287           *
    288           * @return      None.
    289           **************************************************************************************************
    290           */

   \                                 In  segment CODE, align 2
   \                     ?Subroutine0:
   \   000000   3E40E803     MOV.W   #0x3e8, R14
   \   000004   3D400010     MOV.W   #0x1000, R13
   \   000008   5C42....     MOV.B   &zapTaskId, R12
   \   00000C   ........     CALLA   #osal_start_timerEx
   \   000010   4C93         CMP.B   #0x0, R12
   \   000012   0624         JEQ     ??zapMonitor_0
   \   000014   3D400010     MOV.W   #0x1000, R13
   \   000018   5C42....     MOV.B   &zapTaskId, R12
   \   00001C   ........     CALLA   #osal_set_event
   \                     ??zapMonitor_0:
   \   000020   1001         RETA

   \                                 In  segment CODE, align 2
    291          void zapInit(uint8 id)
   \                     zapInit:
    292          {
   \   000000   0A12         PUSH.W  R10
   \   000002   4A4C         MOV.B   R12, R10
    293            zapTaskId = id;
   \   000004   C24C....     MOV.B   R12, &zapTaskId
    294            zapAppPort = ZAP_APP_PORT;
   \   000008   C243....     MOV.B   #0x0, &zapAppPort
    295          
    296            zapPhyInit();
   \   00000C   ........     CALLA   #zapPhyInit
    297          #if ZAP_APP_KEYS
    298            RegisterForKeys(id);
   \   000010   4C4A         MOV.B   R10, R12
   \   000012   ........     CALLA   #RegisterForKeys
    299          #endif
    300          
    301            zapLostSync(ZAP_APP_PORT);
   \   000016   4C43         MOV.B   #0x0, R12
   \   000018   ........     CALLA   #zapLostSync
    302            if (ZSuccess != osal_start_timerEx(zapTaskId, ZAP_APP_TMR_EVT, ZAP_APP_TMR_DLY))
   \   00001C   ........     CALLA   #?Subroutine0
    303            {
    304              (void)osal_set_event(zapTaskId, ZAP_APP_TMR_EVT);
    305            }
    306          
    307          #if !ZAP_PHY_RESET_ZNP
    308            uint8 *pBuf;
    309            if ((pBuf = zap_msg_allocate(0, (uint8)MT_RPC_SYS_UTIL | (uint8)MT_RPC_CMD_AREQ,
    310                                            (uint8)MT_UTIL_SYNC_REQ)) != NULL)
    311            {
    312              zapPhySend(zapAppPort, pBuf);
    313              zap_msg_deallocate(&pBuf);
    314            }
    315          #endif
    316          
    317          #if ZAP_ZNP_MT
    318            zapPhyUartInit();
    319          #endif
    320          }
   \                     ??CrossCallReturnLabel_0:
   \   000020   3A41         POP.W   R10
   \   000022   1001         RETA
    321          
    322          /**************************************************************************************************
    323           * @fn          zapEvt
    324           *
    325           * @brief       This function is called to process the OSAL events for the task.
    326           *
    327           * input parameters
    328           *
    329           * @param       id - OSAL task Id.
    330           * @param       evts - OSAL events bit mask of pending events.
    331           *
    332           * output parameters
    333           *
    334           * None.
    335           *
    336           * @return      evts - OSAL events bit mask of unprocessed events.
    337           **************************************************************************************************
    338           */

   \                                 In  segment CODE, align 2
    339          uint16 zapEvt(uint8 id, uint16 evts)
   \                     zapEvt:
    340          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   0A4D         MOV.W   R13, R10
    341            uint16 mask = 0;
    342            (void)id;
    343          
    344            if (evts & SYS_EVENT_MSG)
   \   000004   0D93         CMP.W   #0x0, R13
   \   000006   1C34         JGE     ??zapEvt_4
    345            {
    346              mask = SYS_EVENT_MSG;
   \   000008   3B400080     MOV.W   #0x8000, R11
    347              zapSysEvtMsg();
   \   00000C   093C         JMP     ??zapEvt_5
   \                     ??zapEvt_0:
   \   00000E   1D4C0200     MOV.W   0x2(R12), R13
   \   000012   5C480100     MOV.B   0x1(R8), R12
   \   000016   ........     CALLA   #zapProcessIncoming
   \                     ??zapEvt_1:
   \   00001A   0C48         MOV.W   R8, R12
   \   00001C   ........     CALLA   #osal_msg_deallocate
   \                     ??zapEvt_5:
   \   000020   5C42....     MOV.B   &zapTaskId, R12
   \   000024   ........     CALLA   #osal_msg_receive
   \   000028   084C         MOV.W   R12, R8
   \   00002A   0C93         CMP.W   #0x0, R12
   \   00002C   3224         JEQ     ??zapEvt_6
   \   00002E   6E4C         MOV.B   @R12, R14
   \   000030   5E83         SUB.B   #0x1, R14
   \   000032   ED27         JEQ     ??zapEvt_0
   \   000034   7E80BF00     SUB.B   #0xbf, R14
   \   000038   F023         JNE     ??zapEvt_1
   \   00003A   ........     CALLA   #zapKeys
   \   00003E   ED3F         JMP     ??zapEvt_1
    348            }
    349            else if (evts & (ZAP_PHY_SPI_EVT | ZAP_PHY_UART_EVT))
   \                     ??zapEvt_4:
   \   000040   0B4D         MOV.W   R13, R11
   \   000042   3BF00060     AND.W   #0x6000, R11
   \   000046   0424         JEQ     ??zapEvt_7
    350            {
    351              mask = evts & (ZAP_PHY_SPI_EVT | ZAP_PHY_UART_EVT);
    352              zapPhyExec(mask);
   \   000048   0C4B         MOV.W   R11, R12
   \   00004A   ........     CALLA   #zapPhyExec
   \   00004E   213C         JMP     ??zapEvt_6
    353            }
    354            else if (evts & ZAP_APP_TMR_EVT)
   \                     ??zapEvt_7:
   \   000050   3DB00010     BIT.W   #0x1000, R13
   \   000054   0528         JNC     ??zapEvt_8
    355            {
    356              mask = ZAP_APP_TMR_EVT;
   \   000056   3B400010     MOV.W   #0x1000, R11
    357              zapMonitor();
   \   00005A   ........     CALLA   #zapMonitor
   \   00005E   193C         JMP     ??zapEvt_6
    358            }
    359            else if (evts & ZAP_APP_SYNC_EVT)
   \                     ??zapEvt_8:
   \   000060   3DB00008     BIT.W   #0x800, R13
   \   000064   0528         JNC     ??zapEvt_9
    360            {
    361              mask = ZAP_APP_SYNC_EVT;
   \   000066   3B400008     MOV.W   #0x800, R11
    362              zapSync();
   \   00006A   ........     CALLA   #zapSync
   \   00006E   113C         JMP     ??zapEvt_6
    363            }
    364            else if (evts & ZAP_APP_ZDO_STATE_CHANGE_EVT)
   \                     ??zapEvt_9:
   \   000070   3DB00004     BIT.W   #0x400, R13
   \   000074   0D28         JNC     ??zapEvt_10
    365            {
    366              mask = ZAP_APP_ZDO_STATE_CHANGE_EVT;
   \   000076   3B400004     MOV.W   #0x400, R11
    367          
    368          #ifdef LCD_SUPPORTED
    369              // Loop to get all of the cached, global ZNP variables for the sake of a timely LCD update.
    370              for (id = 0; id <= ZAP_MON_INFO_CNT; id++)
   \   00007A   78400600     MOV.B   #0x6, R8
    371              {
    372                zapMonInfo();
   \                     ??zapEvt_2:
   \   00007E   ........     CALLA   #zapMonInfo
    373              }
   \   000082   7853         ADD.B   #0xff, R8
   \   000084   FC23         JNE     ??zapEvt_2
    374          #else
    375              // Otherwise, just get what is needed for the ZDO state change update.
    376              zb_GetDeviceInfo(ZB_INFO_DEV_STATE, &devState);
    377          #endif
    378          
    379              ZDO_UpdateNwkStatus(devState);
   \   000086   5C42....     MOV.B   &devState, R12
   \   00008A   ........     CALLA   #ZDO_UpdateNwkStatus
   \   00008E   013C         JMP     ??zapEvt_6
    380            }
    381            else
    382            {
    383              mask = evts;  // Discard unknown events - should never happen.
   \                     ??zapEvt_10:
   \   000090   0B4D         MOV.W   R13, R11
    384            }
    385          
    386            return (evts ^ mask);  // Return unprocessed events.
   \                     ??zapEvt_6:
   \   000092   0AEB         XOR.W   R11, R10
   \   000094   0C4A         MOV.W   R10, R12
   \   000096   3817         POPM.W  #0x4, R11
   \   000098   1001         RETA
    387          }
    388          
    389          /**************************************************************************************************
    390           * @fn          zapGotSync
    391           *
    392           * @brief       This function is invoked upon receipt of MT_SYS_RESET_IND or MT_UTIL_SYNC_REQ
    393           *              and would indicate that sync is (re-)gained with the ZNP.
    394           *
    395           * input parameters
    396           *
    397           * @param       port - Port Id corresponding to the ZNP that got sync.
    398           *
    399           * output parameters
    400           *
    401           * None.
    402           *
    403           * @return      None.
    404           **************************************************************************************************
    405           */

   \                                 In  segment CODE, align 2
    406          void zapGotSync(uint8 port)
   \                     zapGotSync:
    407          {
    408            zapPhySync(port);
   \   000000   ........     CALLA   #zapPhySync
    409          
    410            // Especially for UART transport, allow time for multiple got syncs before acting on it.
    411            if (ZSuccess != osal_start_timerEx(zapTaskId, ZAP_APP_SYNC_EVT, ZAP_APP_SYNC_DLY))
   \   000004   3E406400     MOV.W   #0x64, R14
   \   000008   3D400008     MOV.W   #0x800, R13
   \   00000C   5C42....     MOV.B   &zapTaskId, R12
   \   000010   ........     CALLA   #osal_start_timerEx
   \   000014   4C93         CMP.B   #0x0, R12
   \   000016   0624         JEQ     ??zapGotSync_0
    412            {
    413              (void)osal_set_event(zapTaskId, ZAP_APP_SYNC_EVT);
   \   000018   3D400008     MOV.W   #0x800, R13
   \   00001C   5C42....     MOV.B   &zapTaskId, R12
   \   000020   ........     CALLA   #osal_set_event
    414            }
    415          }
   \                     ??zapGotSync_0:
   \   000024   1001         RETA
    416          
    417          /**************************************************************************************************
    418           * @fn          zapLostSync
    419           *
    420           * @brief       This function is invoked by the PHY drivers when sync is lost with the ZNP.
    421           *
    422           * input parameters
    423           *
    424           * @param       port - Port Id corresponding to the ZNP that lost sync.
    425           *
    426           * output parameters
    427           *
    428           * None.
    429           *
    430           * @return      None.
    431           **************************************************************************************************
    432           */

   \                                 In  segment CODE, align 2
    433          void zapLostSync(uint8 port)
   \                     zapLostSync:
    434          {
    435            devState = DEV_STATE_INVALID;
   \   000000   F240FC00.... MOV.B   #0xfc, &devState
    436            znpAddr = znpParent = INVALID_NODE_ADDR;
   \   000006   B240FEFF.... MOV.W   #0xfffe, &znpParent
   \   00000C   B240FEFF.... MOV.W   #0xfffe, &znpAddr
    437            znpPanId = 0xFFFF;
   \   000012   B243....     MOV.W   #0xffff, &znpPanId
    438          }
   \   000016   1001         RETA
    439          
    440          /**************************************************************************************************
    441           * @fn          zapProcessIncoming
    442           *
    443           * @brief       This function is called by zapSysEvtMsg() to process an incoming message from ZNP.
    444           *
    445           * input parameters
    446           *
    447           * @param       port - Port Id corresponding to the ZNP that sent the message.
    448           * @param       pBuf - Pointer to event message.
    449           *
    450           * output parameters
    451           *
    452           * None.
    453           *
    454           * @return      None.
    455           **************************************************************************************************
    456           */

   \                                 In  segment CODE, align 2
    457          void zapProcessIncoming(uint8 port, uint8 *pBuf)
   \                     zapProcessIncoming:
    458          {
   \   000000   0A12         PUSH.W  R10
    459            if ((pBuf[MT_RPC_POS_CMD0] & MT_RPC_SUBSYSTEM_MASK) < MT_RPC_SYS_MAX)
   \   000002   5F4D0100     MOV.B   0x1(R13), R15
   \   000006   4E4F         MOV.B   R15, R14
   \   000008   7EF01F00     AND.B   #0x1f, R14
   \   00000C   7E900B00     CMP.B   #0xb, R14
   \   000010   0D2C         JC      ??zapProcessIncoming_0
    460            {
    461              zapProcessFunc_t func;
    462          
    463              if (NULL != (func = zapProcessFunc[pBuf[MT_RPC_POS_CMD0] & MT_RPC_SUBSYSTEM_MASK]))
   \   000012   3FF01F00     AND.W   #0x1f, R15
   \   000016   5F06         RLAM.W  #0x2, R15
   \   000018   1E4F....     MOV.W   zapProcessFunc(R15), R14
   \   00001C   1F4F....     MOV.W   zapProcessFunc + 2(R15), R15
   \   000020   0A4E         MOV.W   R14, R10
   \   000022   0ADF         BIS.W   R15, R10
   \   000024   0A93         CMP.W   #0x0, R10
   \   000026   0224         JEQ     ??zapProcessIncoming_0
    464              {
    465                func(port, pBuf);
   \   000028   ........     CALLA   #?IndCallR15
    466              }
    467            }
    468          
    469          #if ZAP_ZNP_MT
    470          #if ZAP_APP_MSG
    471            if ((MT_RPC_SYS_APP == (pBuf[MT_RPC_POS_CMD0] & MT_RPC_SUBSYSTEM_MASK)) &&
    472                    (MT_APP_MSG ==  pBuf[MT_RPC_POS_CMD1]))
    473            {
    474              MT_AppMsg(pBuf);
    475            }
    476            else
    477          #endif
    478            {
    479              MT_BuildAndSendZToolResponse(pBuf[MT_RPC_POS_CMD0], pBuf[MT_RPC_POS_CMD1],
    480                                           pBuf[MT_RPC_POS_LEN],  pBuf+MT_RPC_POS_DAT0);
    481            }
    482          #endif
    483          }
   \                     ??zapProcessIncoming_0:
   \   00002C   3A41         POP.W   R10
   \   00002E   1001         RETA
    484          
    485          /**************************************************************************************************
    486           * @fn          zap_msg_allocate
    487           *
    488           * @brief       This function allocates and pre-fills a dynamic RPC message buffer.
    489           *
    490           * input parameters
    491           *
    492           * @param       len - length of the data to send via RPC (i.e. not including RPC overhead.)
    493           * @param       cmd0 - a valid logical OR of the mtRpcCmdType_t & mtRpcSysType_t.
    494           * @param       cmd1 - a valid command for the mtRpcSysType_t.
    495           *
    496           * output parameters
    497           *
    498           * None.
    499           *
    500           * @return      NULL on failure to allocate all memory necessary.
    501           *              A pointer to the data area (size 'len') of a valid dynamic memory buffer on success.
    502           **************************************************************************************************
    503           */

   \                                 In  segment CODE, align 2
    504          uint8 *zap_msg_allocate(uint8 len, uint8 cmd0, uint8 cmd1)
   \                     zap_msg_allocate:
    505          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   4A4C         MOV.B   R12, R10
   \   000004   4B4D         MOV.B   R13, R11
   \   000006   484E         MOV.B   R14, R8
    506            // An SREQ buffer must be big enough to accept an SRSP up to the max allowable size.
    507            const uint8 sz = (MT_RPC_CMD_SREQ == (cmd0 & MT_RPC_CMD_TYPE_MASK)) ? MT_RPC_DATA_MAX : len;
   \   000008   4E4D         MOV.B   R13, R14
   \   00000A   7EF0E000     AND.B   #0xe0, R14
   \   00000E   7E902000     CMP.B   #0x20, R14
   \   000012   0320         JNE     ??zap_msg_allocate_0
   \   000014   7C40FA00     MOV.B   #0xfa, R12
   \   000018   013C         JMP     ??zap_msg_allocate_1
   \                     ??zap_msg_allocate_0:
   \   00001A   4C4A         MOV.B   R10, R12
    508            // Add space for the RPC frame header and UART transport SOP and FCS.
    509            uint8 *pBuf = (uint8 *)osal_mem_alloc(sz + MT_RPC_FRAME_HDR_SZ + 2);
   \                     ??zap_msg_allocate_1:
   \   00001C   3C500500     ADD.W   #0x5, R12
   \   000020   ........     CALLA   #osal_mem_alloc
    510          
    511            if (NULL != pBuf)
   \   000024   0C93         CMP.W   #0x0, R12
   \   000026   1424         JEQ     ??zap_msg_allocate_2
    512            {
    513              // Pre-seed the SOP for UART transport.
    514              *pBuf++ = MT_UART_SOF;
   \   000028   FC40FE000000 MOV.B   #0xfe, 0(R12)
   \   00002E   1C53         ADD.W   #0x1, R12
    515              *pBuf++ = len;
   \   000030   CC4A0000     MOV.B   R10, 0(R12)
   \   000034   1C53         ADD.W   #0x1, R12
    516              *pBuf++ = cmd0;
   \   000036   CC4B0000     MOV.B   R11, 0(R12)
   \   00003A   1C53         ADD.W   #0x1, R12
    517              *pBuf++ = cmd1;
   \   00003C   CC480000     MOV.B   R8, 0(R12)
   \   000040   1C53         ADD.W   #0x1, R12
    518              #if (3 != MT_RPC_FRAME_HDR_SZ)
    519              #error Need to port RPC frame header changes here.
    520              #endif
    521              // Pre-seed the FCS for UART transport.
    522              *(pBuf + len) = len ^ cmd0 ^ cmd1;
   \   000042   4E4A         MOV.B   R10, R14
   \   000044   4EEB         XOR.B   R11, R14
   \   000046   4EE8         XOR.B   R8, R14
   \   000048   0F4C         MOV.W   R12, R15
   \   00004A   0F5A         ADD.W   R10, R15
   \   00004C   CF4E0000     MOV.B   R14, 0(R15)
    523            }
    524          
    525            return pBuf;
   \                     ??zap_msg_allocate_2:
   \   000050   3817         POPM.W  #0x4, R11
   \   000052   1001         RETA
    526          }
    527          
    528          /**************************************************************************************************
    529           * @fn          zap_msg_deallocate
    530           *
    531           * @brief       This function deallocates an RPC message buffer created with zap_msg_allocate().
    532           *
    533           * input parameters
    534           *
    535           * @param       ppBuf - A pointer to the buffer pointer returned by zap_msg_allocate().
    536           *
    537           * output parameters
    538           *
    539           * None.
    540           *
    541           * @return      None.
    542           **************************************************************************************************
    543           */

   \                                 In  segment CODE, align 2
    544          void zap_msg_deallocate(uint8 **ppBuf)
   \                     zap_msg_deallocate:
    545          {
   \   000000   0A12         PUSH.W  R10
   \   000002   0A4C         MOV.W   R12, R10
    546            uint8 *pBuf;
    547          
    548            HAL_ASSERT(ppBuf);
   \   000004   0C93         CMP.W   #0x0, R12
   \   000006   0220         JNE     ??zap_msg_deallocate_0
   \   000008   ........     CALLA   #halAssertHandler
    549          
    550            if (NULL == *ppBuf)
   \                     ??zap_msg_deallocate_0:
   \   00000C   2C4A         MOV.W   @R10, R12
   \   00000E   0C93         CMP.W   #0x0, R12
   \   000010   0524         JEQ     ??zap_msg_deallocate_1
    551            {
    552              return;
    553            }
    554          
    555            pBuf = *ppBuf - (MT_RPC_FRAME_HDR_SZ + 1);
   \   000012   2C82         SUB.W   #0x4, R12
    556            *ppBuf = NULL;
   \   000014   8A430000     MOV.W   #0x0, 0(R10)
    557            osal_mem_free((void *)pBuf);
   \   000018   ........     CALLA   #osal_mem_free
    558          }
   \                     ??zap_msg_deallocate_1:
   \   00001C   3A41         POP.W   R10
   \   00001E   1001         RETA
    559          
    560          #ifdef LCD_SUPPORTED
    561          /**************************************************************************************************
    562           * @fn          zapDisInfo
    563           *
    564           * @brief       This displays the IEEE (MSB to LSB) and Network State & Address on the LCD whenever
    565           *              a change in the value is detected.
    566           *
    567           * input parameters
    568           *
    569           * None.
    570           *
    571           * output parameters
    572           *
    573           * None.
    574           *
    575           * @return      None.
    576           **************************************************************************************************
    577           */

   \                                 In  segment CODE, align 2
    578          static void zapDisInfo(void)
   \                     zapDisInfo:
    579          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   31801200     SUB.W   #0x12, SP
    580            uint8 i;
    581            uint8 *xad;
    582            uint8 lcd_buf[Z_EXTADDR_LEN*2+1];
    583          
    584            if (!osal_memcmp(zapDisIEEE, znpIEEE, Z_EXTADDR_LEN))
   \   000006   7A401000     MOV.B   #0x10, R10
   \   00000A   3E42         MOV.W   #0x8, R14
   \   00000C   3D40....     MOV.W   #znpIEEE, R13
   \   000010   3C40....     MOV.W   #zapDisIEEE, R12
   \   000014   ........     CALLA   #osal_memcmp
   \   000018   4C93         CMP.B   #0x0, R12
   \   00001A   1E20         JNE     ??zapDisInfo_6
    585            {
    586              (void)osal_memcpy(zapDisIEEE, znpIEEE, Z_EXTADDR_LEN);
   \   00001C   3E42         MOV.W   #0x8, R14
   \   00001E   3D40....     MOV.W   #znpIEEE, R13
   \   000022   3C40....     MOV.W   #zapDisIEEE, R12
   \   000026   ........     CALLA   #osal_memcpy
    587              xad = znpIEEE + Z_EXTADDR_LEN - 1;
   \   00002A   3D40....     MOV.W   #znpIEEE + 7, R13
    588          
    589              for (i = 0; i < Z_EXTADDR_LEN*2; xad--)
   \   00002E   4843         MOV.B   #0x0, R8
   \   000030   0C41         MOV.W   SP, R12
   \   000032   0C53         ADD.W   #0x0, R12
    590              {
    591                uint8 ch;
    592                ch = (*xad >> 4) & 0x0F;
   \                     ??zapDisInfo_0:
   \   000034   6B4D         MOV.B   @R13, R11
   \   000036                RPT     #0x4
   \   000036   43194B10     RRUX.B  R11
    593                lcd_buf[i++] = ch + (( ch < 10 ) ? '0' : '7');
   \   00003A   ........     CALLA   #?Subroutine3
    594                ch = *xad & 0x0F;
   \                     ??CrossCallReturnLabel_4:
   \   00003E   6B4D         MOV.B   @R13, R11
   \   000040   7BF00F00     AND.B   #0xf, R11
    595                lcd_buf[i++] = ch + (( ch < 10 ) ? '0' : '7');
   \   000044   ........     CALLA   #?Subroutine3
    596              }
   \                     ??CrossCallReturnLabel_5:
   \   000048   3D53         ADD.W   #0xffff, R13
   \   00004A   489A         CMP.B   R10, R8
   \   00004C   F32B         JNC     ??zapDisInfo_0
    597              lcd_buf[Z_EXTADDR_LEN*2] = '\0';
   \   00004E   C1431000     MOV.B   #0x0, 0x10(SP)
    598              HalLcdWriteString((char *)lcd_buf, HAL_LCD_LINE_1);
   \   000052   5D43         MOV.B   #0x1, R13
   \   000054   ........     CALLA   #HalLcdWriteString
    599            }
    600          
    601            if ((zapDisState != devState) || (zapDisAddr != znpAddr))
   \                     ??zapDisInfo_6:
   \   000058   1D42....     MOV.W   &znpAddr, R13
   \   00005C   5E42....     MOV.B   &devState, R14
   \   000060   C29E....     CMP.B   R14, &zapDisState
   \   000064   0320         JNE     ??zapDisInfo_7
   \   000066   829D....     CMP.W   R13, &zapDisAddr
   \   00006A   2124         JEQ     ??zapDisInfo_8
    602            {
    603              zapDisState = devState;
   \                     ??zapDisInfo_7:
   \   00006C   C24E....     MOV.B   R14, &zapDisState
    604              zapDisAddr = znpAddr;
   \   000070   824D....     MOV.W   R13, &zapDisAddr
    605          
    606              switch (devState)
   \   000074   7E800600     SUB.B   #0x6, R14
   \   000078   0524         JEQ     ??zapDisInfo_9
   \   00007A   5E83         SUB.B   #0x1, R14
   \   00007C   0824         JEQ     ??zapDisInfo_10
   \   00007E   6E83         SUB.B   #0x2, R14
   \   000080   0B24         JEQ     ??zapDisInfo_11
   \   000082   0F3C         JMP     ??zapDisInfo_12
    607              {
    608              case DEV_END_DEVICE:
    609                HalLcdWriteStringValue("End Device", znpAddr, 16, HAL_LCD_LINE_2);
   \                     ??zapDisInfo_9:
   \   000084   6F43         MOV.B   #0x2, R15
   \   000086   4E4A         MOV.B   R10, R14
   \   000088   3C40....     MOV.W   #`?<Constant "End Device">`, R12
   \   00008C   0E3C         JMP     ??zapDisInfo_1
    610                break;
    611          
    612              case DEV_ROUTER:
    613                HalLcdWriteStringValue("ZigBee Rtr", znpAddr, 16, HAL_LCD_LINE_2);
   \                     ??zapDisInfo_10:
   \   00008E   6F43         MOV.B   #0x2, R15
   \   000090   4E4A         MOV.B   R10, R14
   \   000092   3C40....     MOV.W   #`?<Constant "ZigBee Rtr">`, R12
   \   000096   093C         JMP     ??zapDisInfo_1
    614                break;
    615          
    616              case DEV_ZB_COORD:
    617                HalLcdWriteStringValue("ZigBee Coord", znpAddr, 16, HAL_LCD_LINE_2);
   \                     ??zapDisInfo_11:
   \   000098   6F43         MOV.B   #0x2, R15
   \   00009A   4E4A         MOV.B   R10, R14
   \   00009C   3C40....     MOV.W   #`?<Constant "ZigBee Coord">`, R12
   \   0000A0   043C         JMP     ??zapDisInfo_1
    618                break;
    619          
    620              default:
    621                HalLcdWriteStringValue("Other Inval", znpAddr, 16, HAL_LCD_LINE_2);
   \                     ??zapDisInfo_12:
   \   0000A2   6F43         MOV.B   #0x2, R15
   \   0000A4   4E4A         MOV.B   R10, R14
   \   0000A6   3C40....     MOV.W   #`?<Constant "Other Inval">`, R12
   \                     ??zapDisInfo_1:
   \   0000AA   ........     CALLA   #HalLcdWriteStringValue
    622                break;
    623              }
    624            }
    625          
    626            if (zapDisPanId != znpPanId)
   \                     ??zapDisInfo_8:
   \   0000AE   1D42....     MOV.W   &znpPanId, R13
   \   0000B2   829D....     CMP.W   R13, &zapDisPanId
   \   0000B6   0924         JEQ     ??zapDisInfo_13
    627            {
    628              zapDisPanId = znpPanId;
   \   0000B8   824D....     MOV.W   R13, &zapDisPanId
    629              HalLcdWriteStringValue("PanId 0x", znpPanId, 16, HAL_LCD_LINE_3);
   \   0000BC   7F400300     MOV.B   #0x3, R15
   \   0000C0   4E4A         MOV.B   R10, R14
   \   0000C2   3C40....     MOV.W   #`?<Constant "PanId 0x">`, R12
   \   0000C6   ........     CALLA   #HalLcdWriteStringValue
    630            }
    631          }
   \                     ??zapDisInfo_13:
   \   0000CA   31501200     ADD.W   #0x12, SP
   \   0000CE   3817         POPM.W  #0x4, R11
   \   0000D0   1001         RETA

   \                                 In  segment CODE, align 2
   \                     ?Subroutine3:
   \   000000   4F48         MOV.B   R8, R15
   \   000002   5853         ADD.B   #0x1, R8
   \   000004   7B900A00     CMP.B   #0xa, R11
   \   000008   0328         JNC     ??zapDisInfo_2
   \   00000A   7E403700     MOV.B   #0x37, R14
   \   00000E   023C         JMP     ??zapDisInfo_3
   \                     ??zapDisInfo_2:
   \   000010   7E403000     MOV.B   #0x30, R14
   \                     ??zapDisInfo_3:
   \   000014   4B5E         ADD.B   R14, R11
   \   000016   0E4C         MOV.W   R12, R14
   \   000018   0E5F         ADD.W   R15, R14
   \   00001A   CE4B0000     MOV.B   R11, 0(R14)
   \   00001E   1001         RETA
    632          #endif
    633          
    634          /**************************************************************************************************
    635           * @fn          zapMonInfo
    636           *
    637           * @brief       This function is invoked by zapMonitor during steady state in order to maintain
    638           *              the local copies of ZNP-side global variables.
    639           *
    640           * input parameters
    641           *
    642           * None.
    643           *
    644           * output parameters
    645           *
    646           * None.
    647           *
    648           * @return      None.
    649           **************************************************************************************************
    650           */

   \                                 In  segment CODE, align 2
    651          static void zapMonInfo(void)
   \                     zapMonInfo:
    652          {
    653            static uint8 getInfoIdx;
    654          
    655            switch (getInfoIdx++)
   \   000000   5E42....     MOV.B   &??getInfoIdx, R14
   \   000004   4F4E         MOV.B   R14, R15
   \   000006   5F53         ADD.B   #0x1, R15
   \   000008   C24F....     MOV.B   R15, &??getInfoIdx
   \   00000C   4E83         SUB.B   #0x0, R14
   \   00000E   0924         JEQ     ??zapMonInfo_0
   \   000010   5E83         SUB.B   #0x1, R14
   \   000012   0C24         JEQ     ??zapMonInfo_1
   \   000014   5E83         SUB.B   #0x1, R14
   \   000016   0F24         JEQ     ??zapMonInfo_2
   \   000018   5E83         SUB.B   #0x1, R14
   \   00001A   1224         JEQ     ??zapMonInfo_3
   \   00001C   5E83         SUB.B   #0x1, R14
   \   00001E   1624         JEQ     ??zapMonInfo_4
   \   000020   1B3C         JMP     ??zapMonInfo_5
    656            {
    657            case 0:
    658              zb_GetDeviceInfo(ZB_INFO_DEV_STATE, &devState);
   \                     ??zapMonInfo_0:
   \   000022   3D40....     MOV.W   #devState, R13
   \   000026   4C43         MOV.B   #0x0, R12
   \   000028   ........     BRA     #zb_GetDeviceInfo
    659              break;
    660            case 1:
    661              zb_GetDeviceInfo(ZB_INFO_IEEE_ADDR, &znpIEEE);
   \                     ??zapMonInfo_1:
   \   00002C   3D40....     MOV.W   #znpIEEE, R13
   \   000030   5C43         MOV.B   #0x1, R12
   \   000032   ........     BRA     #zb_GetDeviceInfo
    662              break;
    663            case 2:
    664              zb_GetDeviceInfo(ZB_INFO_SHORT_ADDR, &znpAddr);
   \                     ??zapMonInfo_2:
   \   000036   3D40....     MOV.W   #znpAddr, R13
   \   00003A   6C43         MOV.B   #0x2, R12
   \   00003C   ........     BRA     #zb_GetDeviceInfo
    665              break;
    666            case 3:
    667              zb_GetDeviceInfo(ZB_INFO_PARENT_SHORT_ADDR, &znpParent);
   \                     ??zapMonInfo_3:
   \   000040   3D40....     MOV.W   #znpParent, R13
   \   000044   7C400300     MOV.B   #0x3, R12
   \   000048   ........     BRA     #zb_GetDeviceInfo
    668              break;
    669            case 4:
    670              zb_GetDeviceInfo(ZB_INFO_PAN_ID, &znpPanId);
   \                     ??zapMonInfo_4:
   \   00004C   3D40....     MOV.W   #znpPanId, R13
   \   000050   7C400600     MOV.B   #0x6, R12
   \   000054   ........     BRA     #zb_GetDeviceInfo
    671              break;
    672            // Update ZAP_MON_INFO_CNT whenever another case is added.
    673            default:
    674          #ifdef LCD_SUPPORTED
    675              zapDisInfo();
   \                     ??zapMonInfo_5:
   \   000058   ........     CALLA   #zapDisInfo
    676          #endif
    677              getInfoIdx = 0;
   \   00005C   C243....     MOV.B   #0x0, &??getInfoIdx
    678              break;
    679            }
    680          }
   \   000060   1001         RETA

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \                     ??getInfoIdx:
   \   000000                DS8 1
    681          
    682          #if ZAP_APP_KEYS
    683          /**************************************************************************************************
    684           * @fn          zapKeys
    685           *
    686           * @brief       This function is called by zapSysEvtMsg() to process a key(s) event.
    687           *
    688           * input parameters
    689           *
    690           * None.
    691           *
    692           * output parameters
    693           *
    694           * None.
    695           *
    696           * @return      None.
    697          * MHMS:SW1 and SW2 here are currently set to change the logical type of the Zigbee node.
    698          *
    699           **************************************************************************************************
    700           */

   \                                 In  segment CODE, align 2
    701          static void zapKeys(keyChange_t *msg)
   \                     zapKeys:
    702          {
   \   000000   1B15         PUSHM.W #0x2, R11
    703            const uint8 keys = msg->keys;
   \   000002   5A4C0300     MOV.B   0x3(R12), R10
    704          
    705            if (msg->state)  // Shift key.
   \   000006   CC930200     CMP.B   #0x0, 0x2(R12)
   \   00000A   2820         JNE     ??zapKeys_0
    706            {
    707              if (keys & HAL_KEY_SW_1)
    708              {
    709              }
    710              if (keys & HAL_KEY_SW_2)
    711              {
    712              }
    713              if (keys & HAL_KEY_SW_3)
    714              {
    715              }
    716              if (keys & HAL_KEY_SW_4)
    717              {
    718              }
    719            }
    720            else
    721            {
    722              if (keys & HAL_KEY_SW_1)
   \   00000C   3B40....     MOV.W   #zapAppPort, R11
   \   000010   5AB3         BIT.B   #0x1, R10
   \   000012   1228         JNC     ??zapKeys_1
    723              {
    724                //MHMS:SW1 type change to coordinator
    725                zapPhyReset(zapAppPort);
   \   000014   ........     CALLA   #?Subroutine5
    726                if(zgWriteStartupOptions( ZG_STARTUP_SET,ZCD_STARTOPT_DEFAULT_CONFIG_STATE&&ZCD_STARTOPT_DEFAULT_NETWORK_STATE)){
   \                     ??CrossCallReturnLabel_11:
   \   000018   5D43         MOV.B   #0x1, R13
   \   00001A   7C43         MOV.B   #0xff, R12
   \   00001C   ........     CALLA   #zgWriteStartupOptions
   \   000020   4C93         CMP.B   #0x0, R12
   \   000022   0A24         JEQ     ??zapKeys_1
    727                zapPhyReset(zapAppPort);
   \   000024   ........     CALLA   #?Subroutine5
    728                zLogicalType=ZG_DEVICETYPE_COORDINATOR;
   \                     ??CrossCallReturnLabel_10:
   \   000028   C243....     MOV.B   #0x0, &zLogicalType
    729                zapSync();
   \   00002C   ........     CALLA   #?Subroutine1
    730                zapPhyReset(zapAppPort);
    731                HalLcdWriteStringValue("Should be Coord.",0, 16, HAL_LCD_LINE_7);
    732                }
    733              }
   \                     ??CrossCallReturnLabel_1:
   \   000030   3C40....     MOV.W   #`?<Constant "Should be Coord.">`, R12
   \   000034   ........     CALLA   #HalLcdWriteStringValue
    734              if (keys & HAL_KEY_SW_2)
   \                     ??zapKeys_1:
   \   000038   6AB3         BIT.B   #0x2, R10
   \   00003A   1028         JNC     ??zapKeys_0
    735              {
    736               //MHMS: Try and implement ZdoStateChange to Router
    737                if(zgWriteStartupOptions( ZG_STARTUP_SET,ZCD_STARTOPT_DEFAULT_CONFIG_STATE&&ZCD_STARTOPT_DEFAULT_NETWORK_STATE)){
   \   00003C   5D43         MOV.B   #0x1, R13
   \   00003E   7C43         MOV.B   #0xff, R12
   \   000040   ........     CALLA   #zgWriteStartupOptions
   \   000044   4C93         CMP.B   #0x0, R12
   \   000046   0A24         JEQ     ??zapKeys_0
    738                zapPhyReset(zapAppPort);
   \   000048   ........     CALLA   #?Subroutine5
    739                zLogicalType=ZG_DEVICETYPE_ROUTER;
   \                     ??CrossCallReturnLabel_9:
   \   00004C   D243....     MOV.B   #0x1, &zLogicalType
    740                zapSync();
   \   000050   ........     CALLA   #?Subroutine1
    741                zapPhyReset(zapAppPort);
    742                HalLcdWriteStringValue("Should be Router.",0, 16, HAL_LCD_LINE_7);
    743                }
    744              }
    745              if (keys & HAL_KEY_SW_3)
    746              {
    747              }
    748              if (keys & HAL_KEY_SW_4)
    749              {
    750              }
    751            }
   \                     ??CrossCallReturnLabel_2:
   \   000054   3C40....     MOV.W   #`?<Constant "Should be Router.">`, R12
   \   000058   ........     CALLA   #HalLcdWriteStringValue
    752          }
   \                     ??zapKeys_0:
   \   00005C   1A17         POPM.W  #0x2, R11
   \   00005E   1001         RETA

   \                                 In  segment CODE, align 2
   \                     ?Subroutine1:
   \   000000   ........     CALLA   #zapSync
   \   000004   ........     CALLA   #?Subroutine5
   \                     ??CrossCallReturnLabel_8:
   \   000008   7F400700     MOV.B   #0x7, R15
   \   00000C   7E401000     MOV.B   #0x10, R14
   \   000010   0D43         MOV.W   #0x0, R13
   \   000012   1001         RETA

   \                                 In  segment CODE, align 2
   \                     ?Subroutine5:
   \   000000   6C4B         MOV.B   @R11, R12
   \   000002   ........     BRA     #zapPhyReset
    753          #endif
    754          
    755          /**************************************************************************************************
    756           * @fn          zapMonitor
    757           *
    758           * @brief       This function is called by OSAL timer or event to monitor the ZNP for all.
    759           *
    760           * input parameters
    761           *
    762           * None.
    763           *
    764           * output parameters
    765           *
    766           * None.
    767           *
    768           * @return      None.
    769           **************************************************************************************************
    770           */

   \                                 In  segment CODE, align 2, keep-with-next
    771          static void zapMonitor(void)
   \                     zapMonitor:
    772          {
    773            /* If the ZNP has not already reported by the first monitor run, only the ZAP has reset and not
    774             * the ZNP; or the ZAP/ZNP sync has been lost.
    775             */
    776            if (DEV_STATE_INVALID == devState)
   \   000000   5E42....     MOV.B   &devState, R14
   \   000004   7E90FC00     CMP.B   #0xfc, R14
   \   000008   0A20         JNE     ??zapMonitor_1
    777            {
    778          #if ZAP_APP_LED
    779              HalLedSet (HAL_LED_2, HAL_LED_MODE_OFF);
    780          #endif
    781              devState = DEV_STATE_SYNC_LOST;
   \   00000A   F240FD00.... MOV.B   #0xfd, &devState
    782              zapUtilReq(MT_UTIL_SYNC_REQ, NULL, NULL);
   \   000010   0E43         MOV.W   #0x0, R14
   \   000012   0D43         MOV.W   #0x0, R13
   \   000014   7C40E000     MOV.B   #0xe0, R12
   \   000018   ........     CALLA   #zapUtilReq
   \   00001C   1E3C         JMP     ??zapMonitor_2
    783            }
    784            else if (DEV_STATE_SYNC_LOST == devState)
   \                     ??zapMonitor_1:
   \   00001E   7E90FD00     CMP.B   #0xfd, R14
   \   000022   0720         JNE     ??zapMonitor_3
    785            {
    786              devState = DEV_STATE_ZNP_LOST;
   \   000024   F240FE00.... MOV.B   #0xfe, &devState
    787              znpSystemReset(ZNP_RESET_SOFT);
   \   00002A   5C43         MOV.B   #0x1, R12
   \   00002C   ........     CALLA   #znpSystemReset
   \   000030   143C         JMP     ??zapMonitor_2
    788            }
    789            else if (DEV_STATE_ZNP_LOST == devState)
   \                     ??zapMonitor_3:
   \   000032   7E90FE00     CMP.B   #0xfe, R14
   \   000036   0720         JNE     ??zapMonitor_4
    790            {
    791              devState = DEV_STATE_ZAP_LOST;
   \   000038   F243....     MOV.B   #0xff, &devState
    792              zapPhyReset(zapAppPort);
   \   00003C   5C42....     MOV.B   &zapAppPort, R12
   \   000040   ........     CALLA   #zapPhyReset
   \   000044   0A3C         JMP     ??zapMonitor_2
    793            }
    794            else if (DEV_STATE_ZAP_LOST == devState)
   \                     ??zapMonitor_4:
   \   000046   7E93         CMP.B   #0xff, R14
   \   000048   0620         JNE     ??zapMonitor_5
    795            {
    796              HalReset();
   \   00004A   32C2         dint
   \   00004C   0343         nop
   \   00004E   B24004A52001 MOV.W   #0xa504, &0x120
   \   000054   023C         JMP     ??zapMonitor_2
    797            }
    798            else
    799            {
    800          #if ZAP_APP_LED
    801              HalLedSet (HAL_LED_2, HAL_LED_MODE_ON);
    802          #endif
    803              zapMonInfo();
   \                     ??zapMonitor_5:
   \   000056   ........     CALLA   #zapMonInfo
    804            }
    805          
    806            if (ZSuccess != osal_start_timerEx(zapTaskId, ZAP_APP_TMR_EVT, ZAP_APP_TMR_DLY))
   \                     ??zapMonitor_2:
   \   00005A                REQUIRE ?Subroutine0
   \   00005A                REQUIRE _A_PMMCTL0_L
   \   00005A                // Fall through to label ?Subroutine0
    807            {
    808              (void)osal_set_event(zapTaskId, ZAP_APP_TMR_EVT);
    809            }
    810          
    811          #if ZAP_APP_LED
    812            HalLedSet (HAL_LED_4, HAL_LED_MODE_TOGGLE);
    813          #endif
    814          }
    815          
    816          /**************************************************************************************************
    817           * @fn          zapSync
    818           *
    819           * @brief       This function is invoked upon receipt of ZAP_APP_SYNC_EVT.
    820           *
    821           * input parameters
    822           *
    823           * None.
    824           *
    825           * output parameters
    826           *
    827           * None.
    828           *
    829           * @return      None.
    830           **************************************************************************************************
    831           */

   \                                 In  segment CODE, align 2
    832          static void zapSync(void)
   \                     zapSync:
    833          {
   \   000000   0A12         PUSH.W  R10
   \   000002   3182         SUB.W   #0x8, SP
    834            uint8 pBuf[Z_EXTADDR_LEN];
    835          
    836          #if ZAP_NV_RESTORE
    837            pBuf[0] = ZCD_STARTOPT_AUTO_START;
    838            (void)znp_nv_write(ZCD_NV_STARTUP_OPTION, 0, 1, pBuf);
    839          #else
    840            (void)osal_memset(pBuf, 0, Z_EXTADDR_LEN);
   \   000004   0A41         MOV.W   SP, R10
   \   000006   0A53         ADD.W   #0x0, R10
   \   000008   3E42         MOV.W   #0x8, R14
   \   00000A   4D43         MOV.B   #0x0, R13
   \   00000C   0C4A         MOV.W   R10, R12
   \   00000E   ........     CALLA   #osal_memset
    841            if (osal_memcmp(pBuf, znpIEEE, Z_EXTADDR_LEN))
   \   000012   3E42         MOV.W   #0x8, R14
   \   000014   3D40....     MOV.W   #znpIEEE, R13
   \   000018   0C4A         MOV.W   R10, R12
   \   00001A   ........     CALLA   #osal_memcmp
   \   00001E   4C93         CMP.B   #0x0, R12
   \   000020   1424         JEQ     ??zapSync_0
    842            {
    843              zb_GetDeviceInfo(ZB_INFO_IEEE_ADDR, &znpIEEE);
   \   000022   3D40....     MOV.W   #znpIEEE, R13
   \   000026   5C43         MOV.B   #0x1, R12
   \   000028   ........     CALLA   #zb_GetDeviceInfo
    844              pBuf[0] = ZCD_STARTOPT_CLEAR_STATE | ZCD_STARTOPT_CLEAR_CONFIG;
   \   00002C   F14003000000 MOV.B   #0x3, 0(SP)
    845              (void)znp_nv_write(ZCD_NV_STARTUP_OPTION, 0, 1, pBuf);
   \   000032   0F4A         MOV.W   R10, R15
   \   000034   5E43         MOV.B   #0x1, R14
   \   000036   4D43         MOV.B   #0x0, R13
   \   000038   3C400300     MOV.W   #0x3, R12
   \   00003C   ........     CALLA   #znp_nv_write
    846              zapPhyReset(zapAppPort);
   \   000040   5C42....     MOV.B   &zapAppPort, R12
   \   000044   ........     CALLA   #zapPhyReset
    847              return;
   \   000048   3D3C         JMP     ??zapSync_1
    848            }
    849          #endif
    850          
    851            zb_GetDeviceInfo(ZB_INFO_DEV_STATE, &devState);
   \                     ??zapSync_0:
   \   00004A   ........     CALLA   #?Subroutine2
    852            zapAfSync();
   \                     ??CrossCallReturnLabel_3:
   \   00004E   ........     CALLA   #zapAfSync
    853            zapZdoSync();
   \   000052   ........     CALLA   #zapZdoSync
    854          #if !ZAP_PHY_RESET_ZNP
    855            // If ZAP resets while a connected ZNP is left running, the ZNP cannot be expected to issue a
    856            // ZDO_STATE_CHANGE notification.
    857            if ((DEV_END_DEVICE == devState) || (DEV_ROUTER == devState) || (DEV_ZB_COORD == devState))
    858            {
    859              // Especially for UART transport, allow time for multiple got syncs before acting on it.
    860              if (ZSuccess != osal_start_timerEx(zapTaskId, ZAP_APP_ZDO_STATE_CHANGE_EVT,
    861                                                            ZAP_APP_ZDO_STATE_CHANGE_DLY))
    862              {
    863                (void)osal_set_event(zapTaskId, ZAP_APP_ZDO_STATE_CHANGE_EVT);
    864              }
    865            }
    866          #endif
    867          #if ZAP_AUTO_CFG
    868            if (devState < DEV_END_DEVICE)
   \   000056   F2900600.... CMP.B   #0x6, &devState
   \   00005C   242C         JC      ??zapSync_2
    869            {
    870              // Configure the defaults from zap.cfg into the ZNP.
    871              //pBuf[0] = ZAP_DEVICETYPE;
    872              //MHMS:fixing zapsync using global variable
    873              pBuf[0] = zLogicalType;
   \   00005E   D142....0000 MOV.B   &zLogicalType, 0(SP)
    874              (void)znp_nv_write(ZCD_NV_LOGICAL_TYPE, 0, 1, pBuf);
   \   000064   0F4A         MOV.W   R10, R15
   \   000066   5E43         MOV.B   #0x1, R14
   \   000068   4D43         MOV.B   #0x0, R13
   \   00006A   3C408700     MOV.W   #0x87, R12
   \   00006E   ........     CALLA   #znp_nv_write
    875          
    876              pBuf[0] = LO_UINT16(ZDAPP_CONFIG_PAN_ID);
   \   000072   F1430000     MOV.B   #0xff, 0(SP)
    877              pBuf[1] = HI_UINT16(ZDAPP_CONFIG_PAN_ID);
   \   000076   F1430100     MOV.B   #0xff, 0x1(SP)
    878              (void)znp_nv_write(ZCD_NV_PANID, 0, 2, pBuf);
   \   00007A   0F4A         MOV.W   R10, R15
   \   00007C   6E43         MOV.B   #0x2, R14
   \   00007E   4D43         MOV.B   #0x0, R13
   \   000080   3C408300     MOV.W   #0x83, R12
   \   000084   ........     CALLA   #znp_nv_write
    879          
    880              pBuf[0] = BREAK_UINT32(DEFAULT_CHANLIST, 0);
   \   000088   C1430000     MOV.B   #0x0, 0(SP)
    881              pBuf[1] = BREAK_UINT32(DEFAULT_CHANLIST, 1);
   \   00008C   F1420100     MOV.B   #0x8, 0x1(SP)
    882              pBuf[2] = BREAK_UINT32(DEFAULT_CHANLIST, 2);
   \   000090   C1430200     MOV.B   #0x0, 0x2(SP)
    883              pBuf[3] = BREAK_UINT32(DEFAULT_CHANLIST, 3);
   \   000094   C1430300     MOV.B   #0x0, 0x3(SP)
    884              (void)znp_nv_write(ZCD_NV_CHANLIST, 0, 4, pBuf);
   \   000098   0F4A         MOV.W   R10, R15
   \   00009A   6E42         MOV.B   #0x4, R14
   \   00009C   4D43         MOV.B   #0x0, R13
   \   00009E   3C408400     MOV.W   #0x84, R12
   \   0000A2   ........     CALLA   #znp_nv_write
    885            }
    886          #endif
    887          #if defined TC_LINKKEY_JOIN
    888            zapCertSync();
    889          #endif
    890          #if ZAP_AUTO_START
    891            if ((DEV_HOLD == devState) || (DEV_INIT == devState) || (DEV_NWK_ORPHAN == devState))
   \                     ??zapSync_2:
   \   0000A6   5E42....     MOV.B   &devState, R14
   \   0000AA   4E93         CMP.B   #0x0, R14
   \   0000AC   0524         JEQ     ??zapSync_3
   \   0000AE   5E93         CMP.B   #0x1, R14
   \   0000B0   0324         JEQ     ??zapSync_3
   \   0000B2   7E900A00     CMP.B   #0xa, R14
   \   0000B6   0420         JNE     ??zapSync_4
    892            {
    893              (void)ZDOInitDevice(NWK_START_DELAY);
   \                     ??zapSync_3:
   \   0000B8   3C406400     MOV.W   #0x64, R12
   \   0000BC   ........     CALLA   #ZDOInitDevice
    894            }
    895          #endif
    896            zb_GetDeviceInfo(ZB_INFO_DEV_STATE, &devState);
   \                     ??zapSync_4:
   \   0000C0   ........     CALLA   #?Subroutine2
    897          }
   \                     ??zapSync_1:
   \   0000C4   3152         ADD.W   #0x8, SP
   \   0000C6   3A41         POP.W   R10
   \   0000C8   1001         RETA

   \                                 In  segment CODE, align 2
   \                     ?Subroutine2:
   \   000000   3D40....     MOV.W   #devState, R13
   \   000004   4C43         MOV.B   #0x0, R12
   \   000006   ........     BRA     #zb_GetDeviceInfo

   \                                 In  segment DATA16_ID, align 1, align-sorted
   \                     `?<Initializer for zLogicalType>`:
   \   000000   01           DC8 1

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "End Device">`:
   \   000000   456E64204465 DC8 "End Device"
   \            7669636500  

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "ZigBee Rtr">`:
   \   000000   5A6967426565 DC8 "ZigBee Rtr"
   \            2052747200  

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "ZigBee Coord">`:
   \   000000   5A6967426565 DC8 "ZigBee Coord"
   \            20436F6F7264
   \            00          

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "Other Inval">`:
   \   000000   4F7468657220 DC8 "Other Inval"
   \            496E76616C00

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "PanId 0x">`:
   \   000000   50616E496420 DC8 "PanId 0x"
   \            307800      

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "Should be Coord.">`:
   \   000000   53686F756C64 DC8 "Should be Coord."
   \            20626520436F
   \            6F72642E00  

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "Should be Router.">`:
   \   000000   53686F756C64 DC8 "Should be Router."
   \            20626520526F
   \            757465722E00
    898          
    899          /**************************************************************************************************
    900           * @fn          zapSysEvtMsg
    901           *
    902           * @brief       This function is called by zapEvt() to process all of the pending OSAL messages.
    903           *
    904           * input parameters
    905           *
    906           * None.
    907           *
    908           * output parameters
    909           *
    910           * None.
    911           *
    912           * @return      None.
    913           **************************************************************************************************
    914           */
    915          static void zapSysEvtMsg(void)
    916          {
    917            uint8 *msg;
    918          
    919            while ((msg = osal_msg_receive(zapTaskId)))
    920            {
    921              switch (*msg)
    922              {
    923              case CMD_SERIAL_MSG:
    924                zapProcessIncoming(((mtOSALSerialData_t *)msg)->hdr.status, ((mtOSALSerialData_t *)msg)->msg);
    925                break;
    926          
    927          #if ZAP_APP_KEYS
    928              case KEY_CHANGE:
    929                zapKeys((keyChange_t *)msg);
    930                break;
    931          #endif
    932          
    933              default:
    934                break;
    935              }
    936          
    937              (void)osal_msg_deallocate(msg);  // Receiving task is responsible for releasing the memory.
    938            }
    939          }
    940          
    941          #if ZAP_ZNP_MT
    942          /**************************************************************************************************
    943           * @fn          MT_BuildAndSendZToolResponse
    944           *
    945           * @brief       This function is the ZAP proxy to the ZNP SystemReset() functionality.
    946           *
    947           * input parameters
    948           *
    949           * @param       cmdType - include type and subsystem
    950           * @param       cmdId - command ID
    951           * @param       dataLen
    952           * @param       *pData
    953           *
    954           * output parameters
    955           *
    956           * None.
    957           *
    958           * @return      None.
    959           **************************************************************************************************
    960           */
    961          void MT_BuildAndSendZToolResponse(uint8 cmdType, uint8 cmdId, uint8 dataLen, uint8 *pData)
    962          {
    963            uint8 *pBuf = zap_msg_allocate(dataLen, cmdType, cmdId);
    964          
    965            if (NULL != pBuf)
    966            {
    967              (void)osal_memcpy(pBuf, pData, dataLen);
    968              zapPhyUartSend(zapAppPort, pBuf);
    969              zap_msg_deallocate(&pBuf);
    970            }
    971          }
    972          #endif
    973          
    974          /**************************************************************************************************
    975          */

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      30  zapDisInfo
            30 -> HalLcdWriteString
            30 -> HalLcdWriteStringValue
            30 -> osal_memcmp
            30 -> osal_memcpy
      12  zapEvt
            12 -> ZDO_UpdateNwkStatus
            12 -> osal_msg_deallocate
            12 -> osal_msg_receive
            12 -> zapKeys
            12 -> zapMonInfo
            12 -> zapMonitor
            12 -> zapPhyExec
            12 -> zapProcessIncoming
            12 -> zapSync
       4  zapGotSync
             4 -> osal_set_event
             4 -> osal_start_timerEx
             4 -> zapPhySync
       6  zapInit
             6 -> RegisterForKeys
             6 -> osal_set_event
             6 -> osal_start_timerEx
             6 -> zapLostSync
             6 -> zapPhyInit
       8  zapKeys
             8 -> HalLcdWriteStringValue
             8 -> zapPhyReset
             8 -> zapSync
             8 -> zgWriteStartupOptions
       4  zapLostSync
       4  zapMonInfo
             4 -> zapDisInfo
             4 -> zb_GetDeviceInfo
       4  zapMonitor
             4 -> osal_set_event
             4 -> osal_start_timerEx
             4 -> zapMonInfo
             4 -> zapPhyReset
             4 -> zapUtilReq
             4 -> znpSystemReset
       6  zapProcessIncoming
             6 -- Indirect call
      14  zapSync
            14 -> ZDOInitDevice
            14 -> osal_memcmp
            14 -> osal_memset
            14 -> zapAfSync
            14 -> zapPhyReset
            14 -> zapZdoSync
            14 -> zb_GetDeviceInfo
            14 -> znp_nv_write
      12  zap_msg_allocate
            12 -> osal_mem_alloc
       6  zap_msg_deallocate
             6 -> halAssertHandler
             6 -> osal_mem_free
      10  zgWriteStartupOptions
            10 -> osal_nv_read
            10 -> osal_nv_write


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      11  ?<Constant "End Device">
      12  ?<Constant "Other Inval">
       9  ?<Constant "PanId 0x">
      17  ?<Constant "Should be Coord.">
      18  ?<Constant "Should be Router.">
      13  ?<Constant "ZigBee Coord">
      11  ?<Constant "ZigBee Rtr">
       1  ?<Initializer for zLogicalType>
      34  ?Subroutine0
      20  ?Subroutine1
      10  ?Subroutine2
      32  ?Subroutine3
      14  ?Subroutine4
       6  ?Subroutine5
       2  _A_PMMCTL0_L
       1  devState
       1  getInfoIdx
       1  zLogicalType
       1  zapAppPort
       2  zapDisAddr
       8  zapDisIEEE
     210  zapDisInfo
       2  zapDisPanId
       1  zapDisState
     154  zapEvt
      38  zapGotSync
      36  zapInit
      96  zapKeys
      24  zapLostSync
      98  zapMonInfo
      90  zapMonitor
      40  zapProcessFunc
      48  zapProcessIncoming
     202  zapSync
       1  zapTaskId
      84  zap_msg_allocate
      32  zap_msg_deallocate
       2  zgTrustCenterAddr
      54  zgWriteStartupOptions
       2  znpAddr
       8  znpIEEE
       2  znpPanId
       2  znpParent

 
 1 282 bytes in segment CODE
     2 bytes in segment DATA16_AN
   131 bytes in segment DATA16_C
     1 byte  in segment DATA16_I
     1 byte  in segment DATA16_ID
    33 bytes in segment DATA16_Z
 
 1 282 bytes of CODE  memory
   132 bytes of CONST memory
    34 bytes of DATA  memory (+ 2 bytes shared)

Errors: none
Warnings: none
