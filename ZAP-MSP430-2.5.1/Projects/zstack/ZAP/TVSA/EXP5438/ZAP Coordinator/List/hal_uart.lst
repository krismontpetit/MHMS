###############################################################################
#                                                                             #
# IAR C/C++ Compiler V5.51.2.50607/W32 for MSP430       19/Apr/2013  11:09:27 #
# Copyright 1996-2012 IAR Systems AB.                                         #
#                                                                             #
#    __rt_version  =  3                                                       #
#    __double_size =  32                                                      #
#    __reg_r4      =  free                                                    #
#    __reg_r5      =  free                                                    #
#    __pic         =  no                                                      #
#    __core        =  430X                                                    #
#    __data_model  =  small                                                   #
#    Source file   =  C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Components\hal\target\MSP5438ZAP\hal_uart.c            #
#    Command line  =  -f C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2. #
#                     5.1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\Source\zap.c #
#                     fg (-DTVSA_DEVICE_ID=0x0016 -DZAP_PHY_SPI=1             #
#                     -DZAP_PHY_UART=!ZAP_PHY_SPI -DZAP_PHY_RESET_ZNP=TRUE    #
#                     -DZAP_ZNP_MT=FALSE -DZAP_APP_MSG=FALSE                  #
#                     -DZAP_SBL_PROXY=FALSE -DZAP_AUTO_CFG=TRUE               #
#                     -DZAP_AUTO_START=TRUE -DZAP_NV_RESTORE=FALSE            #
#                     -DLCD_SUPPORTED -DZAP_AF_DATA_REQ_FRAG=FALSE            #
#                     -DZAP_AF_DATA_REQ_AREQ=!ZAP_AF_DATA_REQ_FRAG            #
#                     -DZAP_ZDO_STARTUP_AREQ=TRUE -DZAP_AF_FUNC               #
#                     -DZAP_SAPI_FUNC -DZAP_SYS_FUNC -DZAP_UTIL_FUNC          #
#                     -DZAP_ZDO_FUNC -DSECURE=0 -DZG_SECURE_DYNAMIC=0         #
#                     "-DDEFAULT_CHANLIST=(uint32)0x00000800"                 #
#                     -DZDAPP_CONFIG_PAN_ID=0xFFFF -DPOLL_RATE=1000           #
#                     -DNWK_START_DELAY=100 -DMAX_BINDING_CLUSTER_IDS=4)      #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Components\hal\target\MSP5438ZAP\hal_uart.c -D         #
#                     ZAP_DEVICETYPE=ZG_DEVICETYPE_COORDINATOR -D             #
#                     TVSA_DEVICE_ID=0x0016 -D TVSA_DONGLE=1 -D HAL_UART=1    #
#                     -lC "C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430- #
#                     2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\ZAP              #
#                     Coordinator\List\" -lA "C:\Users\student\Documents\GitH #
#                     ub\MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP54 #
#                     38\ZAP Coordinator\List\" --remarks --diag_suppress     #
#                     Pe001,Pe193,Pe236,Pe826 -o                              #
#                     "C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5. #
#                     1\Projects\zstack\ZAP\TVSA\EXP5438\ZAP                  #
#                     Coordinator\Obj\" --debug -D__MSP430F5438A__ -e         #
#                     --double=32 --clib -I C:\Users\student\Documents\GitHub #
#                     \MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438 #
#                     \ -I C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430- #
#                     2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\..\Source\ -I    #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\Source\ -I      #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\hal\target\MSP5438ZAP\ -I                          #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\hal\include\ -I C:\Users\student\Documents\GitHub\ #
#                     MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\ #
#                     ..\..\..\..\..\Components\mac\include\ -I               #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\mt\ -I C:\Users\student\Documents\GitHub\MHMS\ZAP- #
#                     MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\ #
#                     ..\..\Components\osal\include\ -I                       #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\osal\mcu\msp430\ -I C:\Users\student\Documents\Git #
#                     Hub\MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5 #
#                     438\..\..\..\..\..\Components\services\saddr\ -I        #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\services\sdata\ -I C:\Users\student\Documents\GitH #
#                     ub\MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP54 #
#                     38\..\..\..\..\..\Components\stack\af\ -I               #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\stack\nwk\ -I C:\Users\student\Documents\GitHub\MH #
#                     MS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\.. #
#                     \..\..\..\..\Components\stack\sapi\ -I                  #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\stack\sec\ -I C:\Users\student\Documents\GitHub\MH #
#                     MS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\.. #
#                     \..\..\..\..\Components\stack\sys\ -I                   #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\stack\zdo\ -I C:\Users\student\Documents\GitHub\MH #
#                     MS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\.. #
#                     \..\..\..\..\Components\zmac\ -I                        #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\zmac\f8w\ --core=430X --data_model=small -Ohz      #
#                     --multiplier=32 --multiplier_location=4C0               #
#                     --require_prototypes --hw_workaround=CPU40              #
#                     --hw_workaround=CPU42                                   #
#    List file     =  C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\ZAP                   #
#                     Coordinator\List\hal_uart.lst                           #
#    Object file   =  C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\ZAP                   #
#                     Coordinator\Obj\hal_uart.r43                            #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1\Components\hal\target\MSP5438ZAP\hal_uart.c
      1          /**************************************************************************************************
      2            Filename:       hal_uart.c
      3            Revised:        $Date: 2010-12-01 14:21:40 -0800 (Wed, 01 Dec 2010) $
      4            Revision:       $Revision: 24527 $
      5          
      6            Description:    This file contains the interface to the UART.
      7          
      8          
      9            Copyright 2007-2010 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /*********************************************************************
     41           * INCLUDES
     42           */
     43          
     44          #include "hal_board_cfg.h"

   \                                 In  segment DATA16_AN, at 0x244
   \   union <unnamed> _A_PCDIR_L
   \                     _A_PCDIR_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x24a
   \   union <unnamed> _A_PCSEL_L
   \                     _A_PCSEL_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x600
   \   union <unnamed> _A_UCA1CTLW0_L
   \                     _A_UCA1CTLW0_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x606
   \   union <unnamed> _A_UCA1BRW_L
   \                     _A_UCA1BRW_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x60c
   \   unsigned char const volatile UCA1RXBUF
   \                     UCA1RXBUF:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x60e
   \   unsigned char volatile UCA1TXBUF
   \                     UCA1TXBUF:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x61c
   \   union <unnamed> _A_UCA1ICTL_L
   \                     _A_UCA1ICTL_L:
   \   000000                DS8 2
     45          #include "hal_mcu.h"
     46          #include "hal_types.h"
     47          #include "hal_uart.h"
     48          #include "osal.h"
     49          #include "OSAL_Timers.h"
     50          
     51          /*-------------------------------------------------------------------------------------------------
     52                                                         MACROS
     53           ------------------------------------------------------------------------------------------------*/
     54          
     55          /* Get 1 byte from UART */
     56          #define HAL_UART_GETBYTE() UCxRXBUF
     57          
     58          /* Put 1 byte into the UART */
     59          #define HAL_UART_PUTBYTE(x)            { UCxTXBUF = (x); }
     60          
     61          /* Set Baud rate */
     62          #define HAL_UART_SETBAUDRATE(baudrate) { UCxBR1 = (baudrate) >> 8;  UCxBR0 = (baudrate); }
     63          
     64          /* Set Source Clock */
     65          #define HAL_UART_SET_SRC_CLK()         { UCxCTL1 |= UCSSEL_3; } /* SMCLK */
     66          
     67          /* Setup TXD and RXD Port */
     68          #define HAL_UART_PORT_CONFIG()         { PxSEL |= PxTX | PxRX; \
     69                                                   PxDIR |= PxTX; \
     70                                                   PxDIR &= ~PxRX; }
     71          
     72          /* Setup format frame */
     73          #define HAL_UART_FRAME_CONFIG()        { UCxCTL0 = UCMODE_0;   /* UART Mode */        \
     74                                                   UCxCTL0 &= ~UCPEN;    /* Disable parity */   \
     75                                                   UCxCTL0 &= ~UCSPB;    /* 1 stop bit */       \
     76                                                   UCxCTL0 &= ~UC7BIT;   /* 8bit data*/         \
     77                                                   UCxCTL0 &= ~UCSYNC; } /* Asynchronous mode */
     78          
     79          /* Enable/Disable TX INT */
     80          #define HAL_UART_TX_INT_ENABLE()       { UCxIE |= UCTXIE; }
     81          #define HAL_UART_TX_INT_DISABLE()      { UCxIE &= ~UCTXIE; }
     82          
     83          /* Enable/Disable RX */
     84          #define HAL_UART_RX_ENABLE()           /* N/A */
     85          #define HAL_UART_RX_DISABLE()          /* N/A */
     86          
     87          /* Enable/Disable TX INT */
     88          #define HAL_UART_RX_INT_ENABLE()       { UCxIE |= UCRXIE; }
     89          #define HAL_UART_RX_INT_DISABLE()      { UCxIE &= ~UCRXIE; }
     90          
     91          /* Enable/Disable SWRST */
     92          #define HAL_UART_SWRST_ENABLE()        { UCxCTL1 |= UCSWRST; }
     93          #define HAL_UART_SWRST_DISABLE()       { UCxCTL1 &= ~UCSWRST; }
     94          
     95          /* Get Rx/Tx status bit */
     96          #define HAL_UART_GET_RXTX_STATUS()    (UCxIFG & (UCRXIFG | UCTXIFG))
     97          #define HAL_UART_GET_RX_STATUS()      (UCxIFG & UCRXIFG)
     98          #define HAL_UART_GET_TX_STATUS()      (UCxIFG & UCTXIFG)
     99          #define HAL_UART_CLR_TX_STATUS()      (UCxIFG &= ~UCTXIFG)
    100          
    101          /* UART CTS and RTS */
    102          #define HAL_UART_CTS_PORT             /* N/A */
    103          #define HAL_UART_CTS_BIT              /* N/A */
    104          
    105          #define HAL_UART_RTS_PORT             /* N/A */
    106          #define HAL_UART_RTS_BIT              /* N/A */
    107          
    108          #define HAL_UART_FLOWCONTROL_INIT()   /* N/A */
    109          
    110          /*-------------------------------------------------------------------------------------------------
    111                                                    GLOBAL VARIABLES
    112          -------------------------------------------------------------------------------------------------*/
    113          

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    114          halUARTCfg_t uartRecord;
   \                     uartRecord:
   \   000000                DS8 34
    115          
    116          #define HAL_GET_UBRR(BAUD_BPS)   ((uint32)(HAL_CPU_CLOCK_MHZ * 1000000) / (uint32)BAUD_BPS)
    117          
    118          /* UBRR table */

   \                                 In  segment DATA16_I, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
    119          uint16 UBRRTable[] = { HAL_GET_UBRR (9600),
   \                     UBRRTable:
   \   000000                DS8 10
   \   00000A                REQUIRE `?<Initializer for UBRRTable>`
    120                                 HAL_GET_UBRR (19200),
    121                                 HAL_GET_UBRR (38400),
    122                                 HAL_GET_UBRR (57600),
    123                                 HAL_GET_UBRR (115200) };
    124          
    125          /*-------------------------------------------------------------------------------------------------
    126                                                   FUNCTIONS - LOCAL
    127          -------------------------------------------------------------------------------------------------*/
    128          
    129          static void Hal_UART_BufferInit(void);
    130          static void Hal_UART_RxProcessEvent(void);
    131          static void Hal_UART_TxProcessEvent(void);
    132          static void Hal_UART_SendCallBack(uint8 port, uint8 event);
    133          
    134          /*-------------------------------------------------------------------------------------------------
    135                                            Application Level Functions
    136          -------------------------------------------------------------------------------------------------*/
    137          
    138          /*************************************************************************************************
    139           * @fn      HalUARTInit()
    140           *
    141           * @brief   Initialize the UART
    142           *
    143           * @param   none
    144           *
    145           * @return  none
    146           *************************************************************************************************/

   \                                 In  segment CODE, align 2
    147          void HalUARTInit ( void )
   \                     HalUARTInit:
    148          {
    149            Hal_UART_BufferInit();
   \   000000   ........     BRA     #Hal_UART_BufferInit
    150          }
    151          
    152          /*************************************************************************************************
    153           * @fn      HalBufferInit()
    154           *
    155           * @brief   Initialize the UART Buffers
    156           *
    157           * @param   none
    158           *
    159           * @return  none
    160           *************************************************************************************************/

   \                                 In  segment CODE, align 2
    161          static void Hal_UART_BufferInit (void)
   \                     Hal_UART_BufferInit:
    162          {
    163            uartRecord.configured        = FALSE;
   \   000000   C243....     MOV.B   #0x0, &uartRecord
    164            uartRecord.rx.bufferHead     = 0;
   \   000004   8243....     MOV.W   #0x0, &uartRecord + 8
    165            uartRecord.rx.bufferTail     = 0;
   \   000008   8243....     MOV.W   #0x0, &uartRecord + 10
    166            uartRecord.rx.pBuffer        = (uint8 *)NULL;
   \   00000C   8243....     MOV.W   #0x0, &uartRecord + 14
    167            uartRecord.tx.bufferHead     = 0;
   \   000010   8243....     MOV.W   #0x0, &uartRecord + 16
    168            uartRecord.tx.bufferTail     = 0;
   \   000014   8243....     MOV.W   #0x0, &uartRecord + 18
    169            uartRecord.tx.pBuffer        = (uint8 *)NULL;
   \   000018   8243....     MOV.W   #0x0, &uartRecord + 22
    170            uartRecord.rxChRvdTime       = 0;
   \   00001C   8243....     MOV.W   #0x0, &uartRecord + 26
   \   000020   8243....     MOV.W   #0x0, &uartRecord + 28
    171            uartRecord.intEnable         = FALSE;
   \   000024   C243....     MOV.B   #0x0, &uartRecord + 24
    172          }
   \   000028   1001         RETA
    173          
    174          /*************************************************************************************************
    175           * @fn      HalUARTOpen()
    176           *
    177           * @brief   Open a port based on the configuration
    178           *
    179           * @param   port   - UART port
    180           *          config - contains configuration information
    181           *          cBack  - Call back function where events will be reported back
    182           *
    183           * @return  Status of the function call
    184           *************************************************************************************************/

   \                                 In  segment CODE, align 2
    185          uint8 HalUARTOpen ( uint8 port, halUARTCfg_t *config )
   \                     HalUARTOpen:
    186          {
   \   000000   0A12         PUSH.W  R10
   \   000002   0A4D         MOV.W   R13, R10
    187            /* Save important information */
    188            uartRecord.baudRate             = config->baudRate;
   \   000004   D24D0100.... MOV.B   0x1(R13), &uartRecord + 1
    189            uartRecord.flowControl          = config->flowControl;
   \   00000A   D24D0200.... MOV.B   0x2(R13), &uartRecord + 2
   \   000010   924D0400.... MOV.W   0x4(R13), &uartRecord + 4
    190            uartRecord.flowControlThreshold = config->flowControlThreshold;
    191            uartRecord.rx.maxBufSize        = config->rx.maxBufSize;
   \   000016   924D0C00.... MOV.W   0xc(R13), &uartRecord + 12
    192            uartRecord.tx.maxBufSize        = config->tx.maxBufSize;
   \   00001C   924D1400.... MOV.W   0x14(R13), &uartRecord + 20
    193            uartRecord.idleTimeout          = config->idleTimeout;
   \   000022   D24D0600.... MOV.B   0x6(R13), &uartRecord + 6
    194            uartRecord.intEnable            = config->intEnable;
   \   000028   D24D1800.... MOV.B   0x18(R13), &uartRecord + 24
    195            uartRecord.callBackFunc         = config->callBackFunc;
   \   00002E   924D1E00.... MOV.W   0x1e(R13), &uartRecord + 30
   \   000034   924D2000.... MOV.W   0x20(R13), &uartRecord + 32
    196          
    197            /* Set SWRST - UART logic held in reset state */
    198            HAL_UART_SWRST_ENABLE();
   \   00003A   D2D30006     BIS.B   #0x1, &0x600
    199          
    200            /* Setup GPIO */
    201            HAL_UART_PORT_CONFIG();
   \   00003E   F2D0C0004A02 BIS.B   #0xc0, &0x24a
   \   000044   F2D040004402 BIS.B   #0x40, &0x244
   \   00004A   F2C080004402 BIC.B   #0x80, &0x244
    202          
    203            /* Set Frame Format */
    204            HAL_UART_FRAME_CONFIG();
   \   000050   C2430106     MOV.B   #0x0, &0x601
   \   000054   F2C080000106 BIC.B   #0x80, &0x601
   \   00005A   F2C20106     BIC.B   #0x8, &0x601
   \   00005E   F2C010000106 BIC.B   #0x10, &0x601
   \   000064   D2C30106     BIC.B   #0x1, &0x601
    205          
    206            /* Set source clock */
    207            HAL_UART_SET_SRC_CLK();
   \   000068   F2D0C0000006 BIS.B   #0xc0, &0x600
    208          
    209            /* Setup Baudrate */
    210            if (config->baudRate > HAL_UART_BR_115200)
   \   00006E   5F4D0100     MOV.B   0x1(R13), R15
   \   000072   7F900500     CMP.B   #0x5, R15
   \   000076   0228         JNC     ??HalUARTOpen_1
    211            {
    212              return HAL_UART_BAUDRATE_ERROR;
   \   000078   6C42         MOV.B   #0x4, R12
   \   00007A   373C         JMP     ??HalUARTOpen_2
    213            }
    214            else
    215            {
    216              HAL_UART_SETBAUDRATE(UBRRTable[config->baudRate]);  /* Set baud rate */
   \                     ??HalUARTOpen_1:
   \   00007C   0F5F         RLA.W   R15
   \   00007E   D24F....0706 MOV.B   UBRRTable + 1(R15), &0x607
   \   000084   5F4D0100     MOV.B   0x1(R13), R15
   \   000088   0F5F         RLA.W   R15
   \   00008A   D24F....0606 MOV.B   UBRRTable(R15), &0x606
    217            }
    218          
    219            /* Setup Flow Control */
    220            if (uartRecord.flowControl)
    221            {
    222              HAL_UART_FLOWCONTROL_INIT();
    223              Hal_UART_FlowControlSet (port, uartRecord.flowControl);
    224            }
    225          
    226            /* Setup threshold */
    227            if (config->flowControlThreshold > config->rx.maxBufSize)
   \   000090   1F4D0400     MOV.W   0x4(R13), R15
   \   000094   8D9F0C00     CMP.W   R15, 0xc(R13)
   \   000098   012C         JC      ??HalUARTOpen_0
    228              uartRecord.flowControlThreshold = 0;
   \   00009A   0F43         MOV.W   #0x0, R15
    229            else
    230              uartRecord.flowControlThreshold = config->flowControlThreshold;
   \                     ??HalUARTOpen_0:
   \   00009C   824F....     MOV.W   R15, &uartRecord + 4
    231          
    232            /* Allocate memory for Rx and Tx buffer */
    233            uartRecord.rx.pBuffer = osal_mem_alloc (uartRecord.rx.maxBufSize);
   \   0000A0   1C42....     MOV.W   &uartRecord + 12, R12
   \   0000A4   ........     CALLA   #osal_mem_alloc
   \   0000A8   824C....     MOV.W   R12, &uartRecord + 14
    234            uartRecord.tx.pBuffer = osal_mem_alloc (uartRecord.tx.maxBufSize);
   \   0000AC   1C42....     MOV.W   &uartRecord + 20, R12
   \   0000B0   ........     CALLA   #osal_mem_alloc
   \   0000B4   824C....     MOV.W   R12, &uartRecord + 22
    235          
    236            /* Validate buffers */
    237            if ((uartRecord.rx.pBuffer) && (uartRecord.tx.pBuffer))
   \   0000B8   8293....     CMP.W   #0x0, &uartRecord + 14
   \   0000BC   1224         JEQ     ??HalUARTOpen_3
   \   0000BE   0C93         CMP.W   #0x0, R12
   \   0000C0   1024         JEQ     ??HalUARTOpen_3
    238            {
    239              /* Enable RX  Enable Rx Int */
    240              HAL_UART_RX_ENABLE();
    241          
    242              /* Clear SWRST - releaset to operation */
    243              HAL_UART_SWRST_DISABLE();
   \   0000C2   D2C30006     BIC.B   #0x1, &0x600
    244          
    245              /* Enable interrupt (optional) */
    246              if (config->intEnable)
   \   0000C6   CA931800     CMP.B   #0x0, 0x18(R10)
   \   0000CA   0324         JEQ     ??HalUARTOpen_4
    247              {
    248                HAL_UART_RX_INT_ENABLE();
   \   0000CC   D2D31C06     BIS.B   #0x1, &0x61c
   \   0000D0   023C         JMP     ??HalUARTOpen_5
    249              }
    250              else
    251              {
    252                HAL_UART_RX_INT_DISABLE();
   \                     ??HalUARTOpen_4:
   \   0000D2   D2C31C06     BIC.B   #0x1, &0x61c
    253              }
    254          
    255              HAL_UART_CLR_TX_STATUS();
   \                     ??HalUARTOpen_5:
   \   0000D6   E2C31D06     BIC.B   #0x2, &0x61d
    256          
    257              /* Mark record as "configured" */
    258              uartRecord.configured = TRUE;
   \   0000DA   D243....     MOV.B   #0x1, &uartRecord
    259          
    260              /* Ready to be used. */
    261              return HAL_UART_SUCCESS;
   \   0000DE   4C43         MOV.B   #0x0, R12
   \   0000E0   043C         JMP     ??HalUARTOpen_2
    262            }
    263            else
    264            {
    265              /* If memory allocation failed, not "configured" */
    266              uartRecord.configured = FALSE;
   \                     ??HalUARTOpen_3:
   \   0000E2   C243....     MOV.B   #0x0, &uartRecord
    267          
    268              /* Failed to allocate Rx and Tx Buffer, end of the story */
    269              return HAL_UART_MEM_FAIL;
   \   0000E6   7C400300     MOV.B   #0x3, R12
   \                     ??HalUARTOpen_2:
   \   0000EA   3A41         POP.W   R10
   \   0000EC   1001         RETA
   \   0000EE                REQUIRE _A_UCA1CTLW0_L
   \   0000EE                REQUIRE _A_PCSEL_L
   \   0000EE                REQUIRE _A_PCDIR_L
   \   0000EE                REQUIRE _A_UCA1BRW_L
   \   0000EE                REQUIRE _A_UCA1ICTL_L
    270            }
    271          }
    272          
    273          /*************************************************************************************************
    274           * @fn      Hal_UARTPoll
    275           *
    276           * @brief   This routine simulate polling and has to be called by the main loop
    277           *
    278           * @param   void
    279           *
    280           * @return  void
    281           *************************************************************************************************/

   \                                 In  segment CODE, align 2
    282          void HalUARTPoll(void)
   \                     HalUARTPoll:
    283          {
    284            if (!uartRecord.configured)  // If port is not configured, no point to poll it.
   \   000000   C293....     CMP.B   #0x0, &uartRecord
   \   000004   4424         JEQ     ??HalUARTPoll_0
    285            {
    286              return;
    287            }
    288          
    289            if (!uartRecord.intEnable)  // Check Port for items to process.
   \   000006   C293....     CMP.B   #0x0, &uartRecord + 24
   \   00000A   0A20         JNE     ??HalUARTPoll_1
    290            {
    291              if (HAL_UART_GET_RX_STATUS())
   \   00000C   D2B31D06     BIT.B   #0x1, &0x61d
   \   000010   0228         JNC     ??HalUARTPoll_2
    292              {
    293                Hal_UART_RxProcessEvent();
   \   000012   ........     CALLA   #Hal_UART_RxProcessEvent
    294              }
    295          
    296              if (HAL_UART_GET_TX_STATUS())
   \                     ??HalUARTPoll_2:
   \   000016   E2B31D06     BIT.B   #0x2, &0x61d
   \   00001A   0228         JNC     ??HalUARTPoll_1
    297              {
    298                Hal_UART_TxProcessEvent();
   \   00001C   ........     CALLA   #Hal_UART_TxProcessEvent
    299              }
    300            }
    301          
    302            if ((Hal_UART_RxBufLen(0) + 1) >= uartRecord.rx.maxBufSize)  // Report if Rx Buffer is full.
   \                     ??HalUARTPoll_1:
   \   000020   ........     CALLA   #?Subroutine0
   \                     ??CrossCallReturnLabel_1:
   \   000024   1C53         ADD.W   #0x1, R12
   \   000026   1C92....     CMP.W   &uartRecord + 12, R12
   \   00002A   0428         JNC     ??HalUARTPoll_3
    303            {
    304              Hal_UART_SendCallBack (0, HAL_UART_RX_FULL) ;
   \   00002C   5D43         MOV.B   #0x1, R13
   \   00002E   4C43         MOV.B   #0x0, R12
   \   000030   ........     CALLA   #Hal_UART_SendCallBack
    305            }
    306          
    307            if ((uartRecord.rxChRvdTime != 0) &&  // Report if Rx Buffer is idled.
    308               ((osal_GetSystemClock() - uartRecord.rxChRvdTime) > uartRecord.idleTimeout))
   \                     ??HalUARTPoll_3:
   \   000034   1F42....     MOV.W   &uartRecord + 26, R15
   \   000038   1FD2....     BIS.W   &uartRecord + 28, R15
   \   00003C   0F93         CMP.W   #0x0, R15
   \   00003E   1624         JEQ     ??HalUARTPoll_4
   \   000040   ........     CALLA   #osal_GetSystemClock
   \   000044   5E42....     MOV.B   &uartRecord + 6, R14
   \   000048   0F43         MOV.W   #0x0, R15
   \   00004A   1C82....     SUB.W   &uartRecord + 26, R12
   \   00004E   1D72....     SUBC.W  &uartRecord + 28, R13
   \   000052   0F9D         CMP.W   R13, R15
   \   000054   0328         JNC     ??HalUARTPoll_5
   \   000056   0A20         JNE     ??HalUARTPoll_4
   \   000058   0E9C         CMP.W   R12, R14
   \   00005A   082C         JC      ??HalUARTPoll_4
    309            {
    310              Hal_UART_SendCallBack (0, HAL_UART_RX_TIMEOUT) ;
   \                     ??HalUARTPoll_5:
   \   00005C   6D42         MOV.B   #0x4, R13
   \   00005E   4C43         MOV.B   #0x0, R12
   \   000060   ........     CALLA   #Hal_UART_SendCallBack
    311              uartRecord.rxChRvdTime = 0;
   \   000064   8243....     MOV.W   #0x0, &uartRecord + 26
   \   000068   8243....     MOV.W   #0x0, &uartRecord + 28
    312            }
    313          
    314            /* Send back warning when buffer it threshold  and turn off flow */
    315            if (Hal_UART_RxBufLen(0) >= uartRecord.rx.maxBufSize - uartRecord.flowControlThreshold)
   \                     ??HalUARTPoll_4:
   \   00006C   ........     CALLA   #?Subroutine0
   \                     ??CrossCallReturnLabel_0:
   \   000070   1F42....     MOV.W   &uartRecord + 12, R15
   \   000074   1F82....     SUB.W   &uartRecord + 4, R15
   \   000078   0C9F         CMP.W   R15, R12
   \   00007A   0428         JNC     ??HalUARTPoll_6
    316            {
    317              Hal_UART_SendCallBack (0, HAL_UART_RX_ABOUT_FULL) ;
   \   00007C   6D43         MOV.B   #0x2, R13
   \   00007E   4C43         MOV.B   #0x0, R12
   \   000080   ........     CALLA   #Hal_UART_SendCallBack
    318            }
    319          
    320            if (uartRecord.flowControl)
   \                     ??HalUARTPoll_6:
   \   000084   C293....     CMP.B   #0x0, &uartRecord + 2
   \   000088   0224         JEQ     ??HalUARTPoll_0
    321            {
    322              if (Hal_UART_RxBufLen(0) > uartRecord.rx.maxBufSize / 2)
   \   00008A   ........     CALLA   #?Subroutine0
    323              {
    324                Hal_UART_FlowControlSet (0, HAL_UART_FLOW_OFF);
    325              }
    326              else
    327              {
    328                Hal_UART_FlowControlSet (0, HAL_UART_FLOW_ON);
    329              }
    330            }
   \                     ??HalUARTPoll_0:
   \   00008E   1001         RETA
   \   000090                REQUIRE _A_UCA1ICTL_L
    331          }

   \                                 In  segment CODE, align 2
   \                     ?Subroutine0:
   \   000000   4C43         MOV.B   #0x0, R12
   \   000002   ........     BRA     #Hal_UART_RxBufLen
    332          
    333          /*************************************************************************************************
    334           * @fn      HalUARTClose()
    335           *
    336           * @brief   Close the UART
    337           *
    338           * @param   port - UART port (not used.)
    339           *
    340           * @return  none
    341           *************************************************************************************************/

   \                                 In  segment CODE, align 2
    342          void HalUARTClose ( uint8 port )
   \                     HalUARTClose:
    343          {
    344            /* Disable Rx Int */
    345            HAL_UART_RX_INT_DISABLE();
   \   000000   D2C31C06     BIC.B   #0x1, &0x61c
    346          
    347            /* Disable RX */
    348            HAL_UART_RX_DISABLE();
    349          
    350            /* Deallocate Rx and Tx Buffers */
    351            if (uartRecord.configured)
   \   000004   C293....     CMP.B   #0x0, &uartRecord
   \   000008   0A24         JEQ     ??HalUARTClose_0
    352            {
    353              /* Free Tx and Rx buffer */
    354              osal_mem_free (uartRecord.rx.pBuffer);
   \   00000A   1C42....     MOV.W   &uartRecord + 14, R12
   \   00000E   ........     CALLA   #osal_mem_free
    355              osal_mem_free (uartRecord.tx.pBuffer);
   \   000012   1C42....     MOV.W   &uartRecord + 22, R12
   \   000016   ........     CALLA   #osal_mem_free
    356          
    357              /* Re-Initialze buffers again */
    358              Hal_UART_BufferInit();
   \   00001A   ........     CALLA   #Hal_UART_BufferInit
    359            }
    360          }
   \                     ??HalUARTClose_0:
   \   00001E   1001         RETA
   \   000020                REQUIRE _A_UCA1ICTL_L
    361          
    362          /*************************************************************************************************
    363           * @fn      HalUARTRead()
    364           *
    365           * @brief   Read a buffer from the UART
    366           *
    367           * @param   port - UART port (not used.)
    368           *          ppBuffer - pointer to a pointer that points to the data that will be read
    369           *          length - length of the requested buffer
    370           *
    371           * @return  length of buffer that was read
    372           *************************************************************************************************/

   \                                 In  segment CODE, align 2
    373          uint16 HalUARTRead ( uint8 port, uint8 *pBuffer, uint16 length )
   \                     HalUARTRead:
    374          {
   \   000000   1B15         PUSHM.W #0x2, R11
    375            uint16 cnt, idx;
    376          
    377            if (!uartRecord.configured)  // If port is not configured, no point to read it.
   \   000002   C293....     CMP.B   #0x0, &uartRecord
   \   000006   0220         JNE     ??HalUARTRead_1
    378            {
    379              return 0;
   \   000008   0C43         MOV.W   #0x0, R12
   \   00000A   1B3C         JMP     ??HalUARTRead_2
    380            }
    381          
    382            // If requested length is bigger than what in buffer, re-adjust it to the buffer length.
    383            cnt = Hal_UART_RxBufLen(0);
   \                     ??HalUARTRead_1:
   \   00000C   ........     CALLA   #?Subroutine0
    384            if (cnt < length)
   \                     ??CrossCallReturnLabel_2:
   \   000010   0C9E         CMP.W   R14, R12
   \   000012   012C         JC      ??HalUARTRead_3
    385            {
    386              length = cnt;
   \   000014   0E4C         MOV.W   R12, R14
    387            }
    388          
    389            idx = uartRecord.rx.bufferHead;
   \                     ??HalUARTRead_3:
   \   000016   1A42....     MOV.W   &uartRecord + 8, R10
    390            for (cnt = 0; cnt < length; cnt++)
   \   00001A   0C43         MOV.W   #0x0, R12
   \   00001C   0D3C         JMP     ??HalUARTRead_4
    391            {
    392              pBuffer[cnt] = uartRecord.rx.pBuffer[idx++];
   \                     ??HalUARTRead_0:
   \   00001E   1B42....     MOV.W   &uartRecord + 14, R11
   \   000022   0B5A         ADD.W   R10, R11
   \   000024   0F4D         MOV.W   R13, R15
   \   000026   0F5C         ADD.W   R12, R15
   \   000028   EF4B0000     MOV.B   @R11, 0(R15)
   \   00002C   1A53         ADD.W   #0x1, R10
    393          
    394              if (idx >= uartRecord.rx.maxBufSize)
   \   00002E   1A92....     CMP.W   &uartRecord + 12, R10
   \   000032   0128         JNC     ??HalUARTRead_5
    395              {
    396                idx = 0;
   \   000034   0A43         MOV.W   #0x0, R10
    397              }
    398            }
   \                     ??HalUARTRead_5:
   \   000036   1C53         ADD.W   #0x1, R12
   \                     ??HalUARTRead_4:
   \   000038   0C9E         CMP.W   R14, R12
   \   00003A   F12B         JNC     ??HalUARTRead_0
    399            uartRecord.rx.bufferHead = idx;
   \   00003C   824A....     MOV.W   R10, &uartRecord + 8
    400          
    401            return length;  // Return number of bytes read.
   \   000040   0C4E         MOV.W   R14, R12
   \                     ??HalUARTRead_2:
   \   000042   1A17         POPM.W  #0x2, R11
   \   000044   1001         RETA
    402          }
    403          
    404          /*************************************************************************************************
    405           * @fn      HalUARTWrite()
    406           *
    407           * @brief   Write a buffer to the UART
    408           *
    409           * @param   port    - UART port (not used.)
    410           *          pBuffer - pointer to the buffer that will be written
    411           *          length  - length of
    412           *
    413           * @return  length of the buffer that was sent
    414           *************************************************************************************************/

   \                                 In  segment CODE, align 2
    415          uint16 HalUARTWrite ( uint8 port, uint8 *pBuffer, uint16 length )
   \                     HalUARTWrite:
    416          {
   \   000000   1B15         PUSHM.W #0x2, R11
    417            uint16 cnt, idx;
    418            halIntState_t intState;
    419          
    420            if (!uartRecord.configured)
   \   000002   C293....     CMP.B   #0x0, &uartRecord
   \   000006   1424         JEQ     ??HalUARTWrite_1
    421            {
    422              return 0;
    423            }
    424          
    425            // Capture the value of the volatile variables.
    426            idx = uartRecord.tx.bufferHead;
   \   000008   1F42....     MOV.W   &uartRecord + 16, R15
    427            cnt = uartRecord.tx.bufferTail;
   \   00000C   1C42....     MOV.W   &uartRecord + 18, R12
    428            if (cnt == idx)
   \   000010   0C9F         CMP.W   R15, R12
   \   000012   0320         JNE     ??HalUARTWrite_2
    429            {
    430              cnt = uartRecord.tx.maxBufSize;
   \   000014   1F42....     MOV.W   &uartRecord + 20, R15
   \   000018   093C         JMP     ??HalUARTWrite_3
    431            }
    432            else if (cnt > idx)
   \                     ??HalUARTWrite_2:
   \   00001A   0F9C         CMP.W   R12, R15
   \   00001C   062C         JC      ??HalUARTWrite_4
    433            {
    434              cnt = uartRecord.tx.maxBufSize - cnt + idx;
   \   00001E   1A42....     MOV.W   &uartRecord + 20, R10
   \   000022   0A8C         SUB.W   R12, R10
   \   000024   0A5F         ADD.W   R15, R10
   \   000026   0F4A         MOV.W   R10, R15
   \   000028   013C         JMP     ??HalUARTWrite_3
    435            }
    436            else // (cnt < idx)
    437            {
    438              cnt = idx - cnt;
   \                     ??HalUARTWrite_4:
   \   00002A   0F8C         SUB.W   R12, R15
    439            }
    440             
    441            // Accept "all-or-none" on write request.
    442            if (cnt < length)
   \                     ??HalUARTWrite_3:
   \   00002C   0F9E         CMP.W   R14, R15
   \   00002E   022C         JC      ??HalUARTWrite_5
    443            {
    444              return 0;
   \                     ??HalUARTWrite_1:
   \   000030   0C43         MOV.W   #0x0, R12
   \   000032   2A3C         JMP     ??HalUARTWrite_6
    445            }
    446          
    447            idx = uartRecord.tx.bufferTail;
   \                     ??HalUARTWrite_5:
   \   000034   1C42....     MOV.W   &uartRecord + 18, R12
    448          
    449            for (cnt = 0; cnt < length; cnt++)
   \   000038   0F43         MOV.W   #0x0, R15
   \   00003A   0D3C         JMP     ??HalUARTWrite_7
    450            {
    451              uartRecord.tx.pBuffer[idx++] = pBuffer[cnt];
   \                     ??HalUARTWrite_0:
   \   00003C   0A4D         MOV.W   R13, R10
   \   00003E   0A5F         ADD.W   R15, R10
   \   000040   1B42....     MOV.W   &uartRecord + 22, R11
   \   000044   0B5C         ADD.W   R12, R11
   \   000046   EB4A0000     MOV.B   @R10, 0(R11)
   \   00004A   1C53         ADD.W   #0x1, R12
    452          
    453              if (idx >= uartRecord.tx.maxBufSize)
   \   00004C   1C92....     CMP.W   &uartRecord + 20, R12
   \   000050   0128         JNC     ??HalUARTWrite_8
    454              {
    455                idx = 0;
   \   000052   0C43         MOV.W   #0x0, R12
    456              }
    457            }
   \                     ??HalUARTWrite_8:
   \   000054   1F53         ADD.W   #0x1, R15
   \                     ??HalUARTWrite_7:
   \   000056   0F9E         CMP.W   R14, R15
   \   000058   F12B         JNC     ??HalUARTWrite_0
    458          
    459            HAL_ENTER_CRITICAL_SECTION(intState);  // Hold off interrupts.
   \   00005A   0F42         MOV.W   SR, R15
   \   00005C   32C2         dint
   \   00005E   0343         nop
    460            cnt = uartRecord.tx.bufferTail;
   \   000060   1D42....     MOV.W   &uartRecord + 18, R13
    461            if (cnt == uartRecord.tx.bufferHead)
   \   000064   1D92....     CMP.W   &uartRecord + 16, R13
   \   000068   0B20         JNE     ??HalUARTWrite_9
    462            {
    463              if (uartRecord.intEnable)
   \   00006A   C293....     CMP.B   #0x0, &uartRecord + 24
   \   00006E   0224         JEQ     ??HalUARTWrite_10
    464              {
    465                HAL_UART_TX_INT_ENABLE();
   \   000070   E2D31C06     BIS.B   #0x2, &0x61c
    466              }
    467              HAL_UART_PUTBYTE(uartRecord.tx.pBuffer[uartRecord.tx.bufferHead]);  // Send a char to UART.
   \                     ??HalUARTWrite_10:
   \   000074   1B42....     MOV.W   &uartRecord + 22, R11
   \   000078   1B52....     ADD.W   &uartRecord + 16, R11
   \   00007C   E24B0E06     MOV.B   @R11, &0x60e
    468            }
    469            uartRecord.tx.bufferTail = idx;
   \                     ??HalUARTWrite_9:
   \   000080   824C....     MOV.W   R12, &uartRecord + 18
    470            HAL_EXIT_CRITICAL_SECTION(intState);  // Restore interrupt enable.
   \   000084   024F         MOV.W   R15, SR
    471          
    472            return length;  // Return the number of bytes actually put into the buffer.
   \   000086   0C4E         MOV.W   R14, R12
   \                     ??HalUARTWrite_6:
   \   000088   1A17         POPM.W  #0x2, R11
   \   00008A   1001         RETA
   \   00008C                REQUIRE _A_UCA1ICTL_L
   \   00008C                REQUIRE UCA1TXBUF
    473          }
    474          
    475          /*************************************************************************************************
    476           * @fn      Hal_UART_RxBufLen()
    477           *
    478           * @brief   Calculate Rx Buffer length of a port
    479           *
    480           * @param   port - UART port (not used.)
    481           *
    482           * @return  length of current Rx Buffer
    483           *************************************************************************************************/

   \                                 In  segment CODE, align 2
    484          uint16 Hal_UART_RxBufLen (uint8 port)
   \                     Hal_UART_RxBufLen:
    485          {
    486            int16 length = uartRecord.rx.bufferTail;
   \   000000   1C42....     MOV.W   &uartRecord + 10, R12
    487          
    488            length -= uartRecord.rx.bufferHead;
   \   000004   1C82....     SUB.W   &uartRecord + 8, R12
    489            if  (length < 0)
   \   000008   0C93         CMP.W   #0x0, R12
   \   00000A   0234         JGE     ??Hal_UART_RxBufLen_0
    490              length += uartRecord.rx.maxBufSize;
   \   00000C   1C52....     ADD.W   &uartRecord + 12, R12
    491          
    492            return (uint16)length;
   \                     ??Hal_UART_RxBufLen_0:
   \   000010   1001         RETA
    493          }
    494          
    495          /*************************************************************************************************
    496           * @fn      Hal_UART_TxBufLen()
    497           *
    498           * @brief   Calculate Tx Buffer length of a port
    499           *
    500           * @param   port - UART port (not used.)
    501           *
    502           * @return  length of current Tx buffer
    503           *************************************************************************************************/

   \                                 In  segment CODE, align 2
    504          uint16 Hal_UART_TxBufLen ( uint8 port )
   \                     Hal_UART_TxBufLen:
    505          {
    506            int16 length = uartRecord.tx.bufferTail;
   \   000000   1C42....     MOV.W   &uartRecord + 18, R12
    507          
    508            length -= uartRecord.tx.bufferHead;
   \   000004   1C82....     SUB.W   &uartRecord + 16, R12
    509            if  (length < 0)
   \   000008   0C93         CMP.W   #0x0, R12
   \   00000A   0234         JGE     ??Hal_UART_TxBufLen_0
    510              length += uartRecord.tx.maxBufSize;
   \   00000C   1C52....     ADD.W   &uartRecord + 20, R12
    511          
    512            return (uint16)length;
   \                     ??Hal_UART_TxBufLen_0:
   \   000010   1001         RETA
    513          }
    514          
    515          /*-------------------------------------------------------------------------------------------------
    516                                                     HELP FUNCTIONS
    517          -------------------------------------------------------------------------------------------------*/
    518          
    519          /*************************************************************************************************
    520           * @fn      HalUARTSendCallBack
    521           *
    522           * @brief   Send Callback back to the caller
    523           *
    524           * @param   port - UART port
    525           *          event - event that causes the call back
    526           *
    527           * @return  None
    528           *************************************************************************************************/

   \                                 In  segment CODE, align 2
    529          static void Hal_UART_SendCallBack(uint8 port, uint8 event)
   \                     Hal_UART_SendCallBack:
    530          {
    531            if (uartRecord.callBackFunc)
   \   000000   1F42....     MOV.W   &uartRecord + 30, R15
   \   000004   1FD2....     BIS.W   &uartRecord + 32, R15
   \   000008   0F93         CMP.W   #0x0, R15
   \   00000A   0224         JEQ     ??Hal_UART_SendCallBack_0
    532            {
    533              (uartRecord.callBackFunc)(port, event);
   \   00000C   ........     CALLA   &uartRecord + 30
    534            }
    535          }
   \                     ??Hal_UART_SendCallBack_0:
   \   000010   1001         RETA
    536          
    537          /*************************************************************************************************
    538           * @fn      Hal_UART_ProcessRxEvent
    539           *
    540           * @brief   Process the Rx data by putting them in Rx Buffer. Callback will happen if idle timeout
    541           *          or Rx buffer is full
    542           *
    543           * @param   void
    544           *
    545           * @return  void
    546           *************************************************************************************************/

   \                                 In  segment CODE, align 2
    547          static void Hal_UART_RxProcessEvent(void)
   \                     Hal_UART_RxProcessEvent:
    548          {
    549            uint8 ch = HAL_UART_GETBYTE();
   \   000000   5E420C06     MOV.B   &0x60c, R14
    550          
    551            uartRecord.rx.pBuffer[uartRecord.rx.bufferTail++] = ch;
   \   000004   1F42....     MOV.W   &uartRecord + 10, R15
   \   000008   0D4F         MOV.W   R15, R13
   \   00000A   1D53         ADD.W   #0x1, R13
   \   00000C   824D....     MOV.W   R13, &uartRecord + 10
   \   000010   1D42....     MOV.W   &uartRecord + 14, R13
   \   000014   0D5F         ADD.W   R15, R13
   \   000016   CD4E0000     MOV.B   R14, 0(R13)
    552            if (uartRecord.rx.bufferTail >= uartRecord.rx.maxBufSize)
   \   00001A   9292........ CMP.W   &uartRecord + 12, &uartRecord + 10
   \   000020   0228         JNC     ??Hal_UART_RxProcessEvent_0
    553            {
    554              uartRecord.rx.bufferTail = 0;
   \   000022   8243....     MOV.W   #0x0, &uartRecord + 10
    555            }
    556          
    557            uartRecord.rxChRvdTime = osal_GetSystemClock();
   \                     ??Hal_UART_RxProcessEvent_0:
   \   000026   ........     CALLA   #osal_GetSystemClock
   \   00002A   824C....     MOV.W   R12, &uartRecord + 26
   \   00002E   824D....     MOV.W   R13, &uartRecord + 28
    558          }
   \   000032   1001         RETA
   \   000034                REQUIRE UCA1RXBUF
    559          
    560          /*************************************************************************************************
    561           * @fn      Hal_UART_ProcessTxEvent
    562           *
    563           * @brief   Process Tx buffer and events
    564           *
    565           * @param   void
    566           *
    567           * @return  void
    568           *************************************************************************************************/

   \                                 In  segment CODE, align 2
    569          static void Hal_UART_TxProcessEvent(void)
   \                     Hal_UART_TxProcessEvent:
    570          {
    571            uint16 tail = uartRecord.tx.bufferTail;
   \   000000   1F42....     MOV.W   &uartRecord + 18, R15
    572          
    573            if (++uartRecord.tx.bufferHead >= uartRecord.tx.maxBufSize)
   \   000004   1E42....     MOV.W   &uartRecord + 16, R14
   \   000008   1E53         ADD.W   #0x1, R14
   \   00000A   824E....     MOV.W   R14, &uartRecord + 16
   \   00000E   1E92....     CMP.W   &uartRecord + 20, R14
   \   000012   0228         JNC     ??Hal_UART_TxProcessEvent_0
    574            {
    575              uartRecord.tx.bufferHead = 0;
   \   000014   8243....     MOV.W   #0x0, &uartRecord + 16
    576            }
    577          
    578            if (uartRecord.tx.bufferHead != tail)
   \                     ??Hal_UART_TxProcessEvent_0:
   \   000018   829F....     CMP.W   R15, &uartRecord + 16
   \   00001C   0724         JEQ     ??Hal_UART_TxProcessEvent_1
    579            {
    580              HAL_UART_PUTBYTE(uartRecord.tx.pBuffer[uartRecord.tx.bufferHead]);  // Send a char to UART.
   \   00001E   1F42....     MOV.W   &uartRecord + 22, R15
   \   000022   1F52....     ADD.W   &uartRecord + 16, R15
   \   000026   E24F0E06     MOV.B   @R15, &0x60e
   \   00002A   1001         RETA
    581            }
    582            else
    583            {
    584              HAL_UART_TX_INT_DISABLE();
   \                     ??Hal_UART_TxProcessEvent_1:
   \   00002C   E2C31C06     BIC.B   #0x2, &0x61c
    585              HAL_UART_CLR_TX_STATUS();
   \   000030   E2C31D06     BIC.B   #0x2, &0x61d
    586            }
    587          }
   \   000034   1001         RETA
   \   000036                REQUIRE UCA1TXBUF
   \   000036                REQUIRE _A_UCA1ICTL_L
    588          
    589          /*************************************************************************************************
    590           * @fn      Hal_UART_SetFlowControl
    591           *
    592           * @brief   Set UART Rx flow control
    593           *
    594           * @param   port: serial port (not used.)
    595           *          on:   0=OFF, !0=ON
    596           *
    597           * @return  none
    598           *
    599           *************************************************************************************************/

   \                                 In  segment CODE, align 2
    600          void Hal_UART_FlowControlSet( uint8 port, uint8 status )
   \                     Hal_UART_FlowControlSet:
    601          {
    602          }
   \   000000   1001         RETA
    603          
    604          /*-------------------------------------------------------------------------------------------------
    605                                              Interrupt Service Routines
    606          -------------------------------------------------------------------------------------------------*/
    607          
    608          /*************************************************************************************************
    609           * @fn      UART Rx/Tx ISR
    610           *
    611           * @brief   Called when a serial byte is ready to read and/or write.
    612           *  NOTE:   Assumes that uartRecord.configured is TRUE if this interrupt is enabled.
    613           *
    614           * @param   void
    615           *
    616           * @return  void
    617          **************************************************************************************************/

   \                                 In  segment ISR_CODE, align 2
    618          INTERRUPT_UART()
   \                     halBoardUart1Isr:
    619          {
   \   000000   3F15         PUSHM.W #0x4, R15
    620            do {
    621              if (HAL_UART_GET_RX_STATUS())
   \                     ??halBoardUart1Isr_0:
   \   000002   D2B31D06     BIT.B   #0x1, &0x61d
   \   000006   0228         JNC     ??halBoardUart1Isr_1
    622              {
    623                Hal_UART_RxProcessEvent();
   \   000008   ........     CALLA   #Hal_UART_RxProcessEvent
    624              }
    625          
    626              if (HAL_UART_GET_TX_STATUS())
   \                     ??halBoardUart1Isr_1:
   \   00000C   E2B31D06     BIT.B   #0x2, &0x61d
   \   000010   0228         JNC     ??halBoardUart1Isr_2
    627              {
    628                Hal_UART_TxProcessEvent();
   \   000012   ........     CALLA   #Hal_UART_TxProcessEvent
    629              }
    630            } while (HAL_UART_GET_RXTX_STATUS());
   \                     ??halBoardUart1Isr_2:
   \   000016   F2B003001D06 BIT.B   #0x3, &0x61d
   \   00001C   F223         JNE     ??halBoardUart1Isr_0
    631          }
   \   00001E   3C17         POPM.W  #0x4, R15
   \   000020   0013         RETI
   \   000022                REQUIRE _A_UCA1ICTL_L

   \                                 In  segment INTVEC, offset 0x5c, root
   \                     `??halBoardUart1Isr??INTVEC 92`:
   \   00005C   ....         DC16    halBoardUart1Isr

   \                                 In  segment DATA16_ID, align 2, align-sorted
   \                     `?<Initializer for UBRRTable>`:
   \   000000   E20471023801 DC16 1250, 625, 312, 208, 104
   \            D0006800    
    632          

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
       4  HalUARTClose
             4 -> Hal_UART_BufferInit
             4 -> osal_mem_free
       4  HalUARTInit
             4 -> Hal_UART_BufferInit
       6  HalUARTOpen
             6 -> osal_mem_alloc
       4  HalUARTPoll
             4 -> Hal_UART_RxBufLen
             4 -> Hal_UART_RxProcessEvent
             4 -> Hal_UART_SendCallBack
             4 -> Hal_UART_TxProcessEvent
             4 -> osal_GetSystemClock
       8  HalUARTRead
             8 -> Hal_UART_RxBufLen
       8  HalUARTWrite
       4  Hal_UART_BufferInit
       4  Hal_UART_FlowControlSet
       4  Hal_UART_RxBufLen
       4  Hal_UART_RxProcessEvent
             4 -> osal_GetSystemClock
       4  Hal_UART_SendCallBack
             4 -- Indirect call
       4  Hal_UART_TxBufLen
       4  Hal_UART_TxProcessEvent
      12  halBoardUart1Isr
            12 -> Hal_UART_RxProcessEvent
            12 -> Hal_UART_TxProcessEvent


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      10  ?<Initializer for UBRRTable>
       2  ??halBoardUart1Isr??INTVEC 92
       6  ?Subroutine0
      32  HalUARTClose
       4  HalUARTInit
     238  HalUARTOpen
     144  HalUARTPoll
      70  HalUARTRead
     140  HalUARTWrite
      42  Hal_UART_BufferInit
       2  Hal_UART_FlowControlSet
      18  Hal_UART_RxBufLen
      52  Hal_UART_RxProcessEvent
      18  Hal_UART_SendCallBack
      18  Hal_UART_TxBufLen
      54  Hal_UART_TxProcessEvent
      10  UBRRTable
       1  UCA1RXBUF
       1  UCA1TXBUF
       2  _A_PCDIR_L
       2  _A_PCSEL_L
       2  _A_UCA1BRW_L
       2  _A_UCA1CTLW0_L
       2  _A_UCA1ICTL_L
      34  halBoardUart1Isr
      34  uartRecord

 
 838 bytes in segment CODE
  12 bytes in segment DATA16_AN
  10 bytes in segment DATA16_I
  10 bytes in segment DATA16_ID
  34 bytes in segment DATA16_Z
   2 bytes in segment INTVEC
  34 bytes in segment ISR_CODE
 
 872 bytes of CODE  memory
  10 bytes of CONST memory (+  2 bytes shared)
  44 bytes of DATA  memory (+ 12 bytes shared)

Errors: none
Warnings: none
