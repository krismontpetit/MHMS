###############################################################################
#                                                                             #
# IAR C/C++ Compiler V5.51.2.50607/W32 for MSP430       26/Apr/2013  13:59:24 #
# Copyright 1996-2012 IAR Systems AB.                                         #
#                                                                             #
#    __rt_version  =  3                                                       #
#    __double_size =  32                                                      #
#    __reg_r4      =  free                                                    #
#    __reg_r5      =  free                                                    #
#    __pic         =  no                                                      #
#    __core        =  430X                                                    #
#    __data_model  =  small                                                   #
#    Source file   =  C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Components\osal\mcu\msp430\OSAL_Nv.c                   #
#    Command line  =  -f C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2. #
#                     5.1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\Source\zap.c #
#                     fg (-DTVSA_DEVICE_ID=0x0016 -DTVSA_DONGLE=1             #
#                     -DHAL_UART=1 -DZAP_PHY_SPI=1                            #
#                     -DZAP_PHY_UART=!ZAP_PHY_SPI -DZAP_PHY_RESET_ZNP=TRUE    #
#                     -DZAP_ZNP_MT=FALSE -DZAP_APP_MSG=FALSE                  #
#                     -DZAP_SBL_PROXY=FALSE -DZAP_AUTO_CFG=TRUE               #
#                     -DZAP_AUTO_START=TRUE -DZAP_NV_RESTORE=FALSE            #
#                     -DLCD_SUPPORTED -DZAP_AF_DATA_REQ_FRAG=FALSE            #
#                     -DZAP_AF_DATA_REQ_AREQ=!ZAP_AF_DATA_REQ_FRAG            #
#                     -DZAP_ZDO_STARTUP_AREQ=TRUE -DZAP_AF_FUNC               #
#                     -DZAP_SAPI_FUNC -DZAP_SYS_FUNC -DZAP_UTIL_FUNC          #
#                     -DZAP_ZDO_FUNC -DSECURE=0 -DZG_SECURE_DYNAMIC=0         #
#                     "-DDEFAULT_CHANLIST=(uint32)0x00000800"                 #
#                     -DZDAPP_CONFIG_PAN_ID=0xFFFF -DPOLL_RATE=1000           #
#                     -DNWK_START_DELAY=100 -DMAX_BINDING_CLUSTER_IDS=4)      #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Components\osal\mcu\msp430\OSAL_Nv.c -D                #
#                     ZAP_DEVICETYPE=ZG_DEVICETYPE_COORDINATOR -D             #
#                     TVSA_DEVICE_ID=0x0016 -D TVSA_DONGLE=1 -D HAL_UART=1    #
#                     -lC "C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430- #
#                     2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\ZAP              #
#                     Coordinator\List\" -lA "C:\Users\student\Documents\GitH #
#                     ub\MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP54 #
#                     38\ZAP Coordinator\List\" --remarks --diag_suppress     #
#                     Pe001,Pe193,Pe236,Pe826 -o                              #
#                     "C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5. #
#                     1\Projects\zstack\ZAP\TVSA\EXP5438\ZAP                  #
#                     Coordinator\Obj\" --debug -D__MSP430F5438A__ -e         #
#                     --double=32 --clib -I C:\Users\student\Documents\GitHub #
#                     \MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438 #
#                     \ -I C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430- #
#                     2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\..\Source\ -I    #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\Source\ -I      #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\hal\target\MSP5438ZAP\ -I                          #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\hal\include\ -I C:\Users\student\Documents\GitHub\ #
#                     MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\ #
#                     ..\..\..\..\..\Components\mac\include\ -I               #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\mt\ -I C:\Users\student\Documents\GitHub\MHMS\ZAP- #
#                     MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\ #
#                     ..\..\Components\osal\include\ -I                       #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\osal\mcu\msp430\ -I C:\Users\student\Documents\Git #
#                     Hub\MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5 #
#                     438\..\..\..\..\..\Components\services\saddr\ -I        #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\services\sdata\ -I C:\Users\student\Documents\GitH #
#                     ub\MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP54 #
#                     38\..\..\..\..\..\Components\stack\af\ -I               #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\stack\nwk\ -I C:\Users\student\Documents\GitHub\MH #
#                     MS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\.. #
#                     \..\..\..\..\Components\stack\sapi\ -I                  #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\stack\sec\ -I C:\Users\student\Documents\GitHub\MH #
#                     MS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\.. #
#                     \..\..\..\..\Components\stack\sys\ -I                   #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\stack\zdo\ -I C:\Users\student\Documents\GitHub\MH #
#                     MS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\.. #
#                     \..\..\..\..\Components\zmac\ -I                        #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\zmac\f8w\ --core=430X --data_model=small -Ohz      #
#                     --multiplier=32 --multiplier_location=4C0               #
#                     --require_prototypes --hw_workaround=CPU40              #
#                     --hw_workaround=CPU42                                   #
#    List file     =  C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\ZAP                   #
#                     Coordinator\List\OSAL_Nv.lst                            #
#    Object file   =  C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\ZAP                   #
#                     Coordinator\Obj\OSAL_Nv.r43                             #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1\Components\osal\mcu\msp430\OSAL_Nv.c
      1          /******************************************************************************
      2            Filename:       OSAL_Nv.c
      3            Revised:        $Date: 2011-06-05 18:52:21 -0700 (Sun, 05 Jun 2011) $
      4            Revision:       $Revision: 26212 $
      5          
      6            Description:    This module contains the OSAL non-volatile memory functions.
      7          
      8          
      9            Copyright 2006-2011 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License"). You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product. Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          ******************************************************************************/
     39          
     40          /******************************************************************************
     41            Notes:
     42              - A trick buried deep in initPage() requires that the MSB of the NV Item Id
     43                is to be reserved for use by this module.
     44          ******************************************************************************/
     45          
     46          /*********************************************************************
     47           * INCLUDES
     48           */
     49          
     50          #include "hal_adc.h"
     51          #include "hal_board_cfg.h"
     52          #include "MSP430FlashUtil.h"
     53          #include "OSAL_Nv.h"
     54          #include "ZComDef.h"
     55          
     56          /*********************************************************************
     57           * CONSTANTS
     58           */
     59          
     60          /* Physical pages per OSAL logical page - increase to get bigger OSAL_NV_ITEMs.
     61           * Changing this number requires a corresponding change in the linker file, currently
     62           * $PROJ_DIR$\..\..\..\Tools\"Processor Specific Name"\"Specific Name".xcl
     63           */
     64          #ifndef OSAL_NV_PHY_PER_PG
     65            #define OSAL_NV_PHY_PER_PG    2
     66          #endif
     67          
     68          #define OSAL_NV_PAGES_USED     (HAL_NV_PAGE_CNT / OSAL_NV_PHY_PER_PG)
     69          #if (OSAL_NV_PAGES_USED < 2)
     70          #error Need to increase the NV_PG_CNT or decrease the OSAL_NV_PHY_PER_PG.
     71          #endif
     72          
     73          #if (HAL_NV_PAGE_CNT != (OSAL_NV_PAGES_USED * OSAL_NV_PHY_PER_PG))
     74          #error HAL_NV_PAGE_CNT must be a multiple of OSAL_NV_PHY_PER_PG
     75          #endif
     76          
     77          #define OSAL_NV_PAGE_SIZE      (OSAL_NV_PHY_PER_PG * HAL_FLASH_PAGE_SIZE)
     78          
     79          #define OSAL_NV_ACTIVE          0x00
     80          #define OSAL_NV_ERASED          0xFF
     81          #define OSAL_NV_ERASED_ID       0xFFFF
     82          #define OSAL_NV_ZEROED_ID       0x0000
     83          // Reserve MSB of Id to signal a search for the "old" source copy (new write interrupted/failed.)
     84          #define OSAL_NV_SOURCE_ID       0x8000
     85          
     86          // In case pages 0-1 are ever used, define a null page value.
     87          #define OSAL_NV_PAGE_NULL       OSAL_NV_PAGES_USED
     88          
     89          // In case item Id 0 is ever used, define a null item value.
     90          #define OSAL_NV_ITEM_NULL       0
     91          
     92          #define OSAL_NV_WORD_SIZE       HAL_FLASH_WORD_SIZE
     93          
     94          #define OSAL_NV_PAGE_HDR_OFFSET 0
     95          
     96          #define OSAL_NV_MAX_HOT         3

   \                                 In  segment DATA16_C, align 2, align-sorted
     97          static const uint16 hotIds[OSAL_NV_MAX_HOT] = {
   \                     hotIds:
   \   000000   82003A003B00 DC16 130, 58, 59
     98            ZCD_NV_NWKKEY,
     99            ZCD_NV_NWK_ACTIVE_KEY_INFO,
    100            ZCD_NV_NWK_ALTERN_KEY_INFO,
    101          };
    102          
    103          /*********************************************************************
    104           * MACROS
    105           */
    106          
    107          #define OSAL_NV_CHECK_BUS_VOLTAGE  HalAdcCheckVdd(VDD_MIN_NV)
    108          
    109          #define OSAL_NV_DATA_SIZE( LEN )  \
    110             ((((LEN) + OSAL_NV_WORD_SIZE - 1) / OSAL_NV_WORD_SIZE) * OSAL_NV_WORD_SIZE)
    111          
    112          #define OSAL_NV_ITEM_SIZE( LEN )  \
    113            (((((LEN) + OSAL_NV_WORD_SIZE - 1) / OSAL_NV_WORD_SIZE) * OSAL_NV_WORD_SIZE) + OSAL_NV_HDR_SIZE)
    114          
    115          #define COMPACT_PAGE_CLEANUP( COM_PG ) st ( \
    116            /* In order to recover from a page compaction that is interrupted,\
    117             * the logic in osal_nv_init() depends upon the following order:\
    118             * 1. State of the target of compaction is changed to ePgInUse.\
    119             * 2. Compacted page is erased.\
    120             */\
    121            setPageUse( pgRes, TRUE );  /* Mark the reserve page as being in use. */\
    122            erasePage( (COM_PG) ); \
    123            \
    124            pgRes = (COM_PG);           /* Set the reserve page to be the newly erased page. */\
    125          )
    126          
    127          // The NV pages must be located in lower flash to simplify read/write operations to using pointers.
    128          #define OSAL_NV_PAGE_TO_PTR(pg) \
    129            ((uint8 *)((uint8 *)((HAL_NV_PAGE_BEG + ((pg) * OSAL_NV_PHY_PER_PG)) * HAL_FLASH_PAGE_SIZE)))
    130          
    131          /*********************************************************************
    132           * TYPEDEFS
    133           */
    134          
    135          typedef struct
    136          {
    137            uint16 id;
    138            uint16 len;   // Enforce Flash-WORD size on len.
    139            uint16 chk;   // Byte-wise checksum of the 'len' data bytes of the item.
    140            uint16 stat;  // Item status.
    141          } osalNvHdr_t;
    142          // Struct member offsets.
    143          #define OSAL_NV_HDR_ID    0
    144          #define OSAL_NV_HDR_LEN   2
    145          #define OSAL_NV_HDR_CHK   4
    146          #define OSAL_NV_HDR_STAT  6
    147          
    148          #define OSAL_NV_HDR_ITEM  2  // Length of any item of a header struct.
    149          #define OSAL_NV_HDR_SIZE  8
    150          #define OSAL_NV_HDR_HALF (OSAL_NV_HDR_SIZE / 2)
    151          
    152          typedef struct
    153          {
    154            uint16 active;
    155            uint16 inUse;
    156            uint16 xfer;
    157            uint16 spare;
    158          } osalNvPgHdr_t;
    159          // Struct member offsets.
    160          #define OSAL_NV_PG_ACTIVE 0
    161          #define OSAL_NV_PG_INUSE  2
    162          #define OSAL_NV_PG_XFER   4
    163          #define OSAL_NV_PG_SPARE  6
    164          
    165          #define OSAL_NV_PAGE_HDR_SIZE  8
    166          #define OSAL_NV_PAGE_HDR_HALF (OSAL_NV_PAGE_HDR_SIZE / 2)
    167          
    168          typedef enum
    169          {
    170            eNvXfer,
    171            eNvZero
    172          } eNvHdrEnum;
    173          
    174          typedef enum
    175          {
    176            ePgActive,
    177            ePgInUse,
    178            ePgXfer,
    179            ePgSpare
    180          } ePgHdrEnum;
    181          
    182          /*********************************************************************
    183           * GLOBAL VARIABLES
    184           */
    185          
    186          #ifndef OAD_KEEP_NV_PAGES
    187          // When NV pages are to remain intact during OAD download,
    188          // the image itself should not include NV pages.
    189          #pragma location="ZIGNV_ADDRESS_SPACE"

   \                                 In  segment ZIGNV_ADDRESS_SPACE, align 1, align-sorted
    190          __no_init uint8 _nvBuf[OSAL_NV_PAGES_USED * OSAL_NV_PAGE_SIZE];
   \                     _nvBuf:
   \   000000                DS8 12288
    191          #pragma required=_nvBuf
    192          #endif // OAD_KEEP_NV_PAGES
    193          
    194          /*********************************************************************
    195           * LOCAL VARIABLES
    196           */
    197          
    198          // Offset into the page of the first available erased space.

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    199          static uint16 pgOff[OSAL_NV_PAGES_USED];
   \                     pgOff:
   \   000000                DS8 24
   \   000018                REQUIRE _nvBuf
    200          
    201          // Count of the bytes lost for the zeroed-out items.

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    202          static uint16 pgLost[OSAL_NV_PAGES_USED];
   \                     pgLost:
   \   000000                DS8 24
    203          

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    204          static uint8 pgRes;  // Page reserved for item compacting transfer.
   \                     pgRes:
   \   000000                DS8 1
    205          
    206          // NV page and offsets for hot items.

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    207          static uint8 hotPg[OSAL_NV_MAX_HOT];
   \                     hotPg:
   \   000000                DS8 3

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    208          static uint16 hotOff[OSAL_NV_MAX_HOT];
   \                     hotOff:
   \   000000                DS8 6
    209          
    210          /*********************************************************************
    211           * LOCAL FUNCTIONS
    212           */
    213          
    214          static uint8  initNV( void );
    215          
    216          static void   setPageUse( uint8 pg, uint8 inUse );
    217          static uint16 initPage( uint8 pg, uint16 id, uint8 findDups );
    218          static void   erasePage( uint8 pg );
    219          static uint8  compactPage( uint8 srcPg, uint16 skipId );
    220          
    221          static uint16 findItem( uint16 id, uint8 *findPg );
    222          static uint8  initItem( uint8 flag, uint16 id, uint16 len, void *buf );
    223          static void   setItem( uint8 pg, uint16 offset, eNvHdrEnum stat );
    224          
    225          static uint16 calcChkB( uint16 len, uint8 *buf );
    226          static uint16 calcChkF( uint8 pg, uint16 offset, uint16 len );
    227          
    228          static void   readHdr( uint8 pg, uint16 offset, uint8 *buf );
    229          
    230          static void   writeBuf( uint8 pg, uint16 offset, uint16 len, uint8 *buf );
    231          static void   xferBuf( uint8 srcPg, uint16 srcOff, uint8 dstPg, uint16 dstOff, uint16 len );
    232          
    233          static uint8  writeItem( uint8 pg, uint16 id, uint16 len, void *buf, uint8 flag );
    234          static uint8  hotItem(uint16 id);
    235          static void   hotItemUpdate(uint8 pg, uint16 off, uint16 id);
    236          
    237          /*********************************************************************
    238           * @fn      initNV
    239           *
    240           * @brief   Initialize the NV flash pages.
    241           *
    242           * @param   none
    243           *
    244           * @return  TRUE
    245           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine0:
   \   000000   3152         ADD.W   #0x8, SP
   \   000002   3817         POPM.W  #0x4, R11
   \   000004   1001         RETA

   \                                 In  segment CODE, align 2
    246          static uint8 initNV( void )
   \                     initNV:
    247          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   3182         SUB.W   #0x8, SP
    248            osalNvPgHdr_t pgHdr;
    249            uint8 oldPg = OSAL_NV_PAGE_NULL;
   \   000004   7A400C00     MOV.B   #0xc, R10
   \   000008   4B4A         MOV.B   R10, R11
    250            uint8 findDups = FALSE;
   \   00000A   4843         MOV.B   #0x0, R8
    251            uint8 pg;
    252          
    253            pgRes = OSAL_NV_PAGE_NULL;
   \   00000C   C24A....     MOV.B   R10, &pgRes
    254          
    255            for ( pg = 0; pg < OSAL_NV_PAGES_USED; pg++ )
   \   000010   4943         MOV.B   #0x0, R9
    256            {
    257              readHdr( pg, OSAL_NV_PAGE_HDR_OFFSET, (uint8 *)(&pgHdr) );
   \                     ??initNV_0:
   \   000012   0E41         MOV.W   SP, R14
   \   000014   0E53         ADD.W   #0x0, R14
   \   000016   0D43         MOV.W   #0x0, R13
   \   000018   4C49         MOV.B   R9, R12
   \   00001A   ........     CALLA   #readHdr
    258          
    259              if ( pgHdr.active == OSAL_NV_ERASED_ID )
   \   00001E   B1930000     CMP.W   #0xffff, 0(SP)
   \   000022   0B20         JNE     ??initNV_4
    260              {
    261                if ( pgRes == OSAL_NV_PAGE_NULL )
   \   000024   C29A....     CMP.B   R10, &pgRes
   \   000028   0320         JNE     ??initNV_5
    262                {
    263                  pgRes = pg;
   \   00002A   C249....     MOV.B   R9, &pgRes
   \   00002E   093C         JMP     ??initNV_6
    264                }
    265                else
    266                {
    267                  setPageUse( pg, TRUE );
   \                     ??initNV_5:
   \   000030   5D43         MOV.B   #0x1, R13
   \   000032   4C49         MOV.B   R9, R12
   \   000034   ........     CALLA   #setPageUse
   \   000038   043C         JMP     ??initNV_6
    268                }
    269              }
    270              // An Xfer from this page was in progress.
    271              else if ( pgHdr.xfer != OSAL_NV_ERASED_ID )
   \                     ??initNV_4:
   \   00003A   B1930400     CMP.W   #0xffff, 0x4(SP)
   \   00003E   0124         JEQ     ??initNV_6
    272              {
    273                oldPg = pg;
   \   000040   4B49         MOV.B   R9, R11
    274              }
    275            }
   \                     ??initNV_6:
   \   000042   5953         ADD.B   #0x1, R9
   \   000044   499A         CMP.B   R10, R9
   \   000046   E52B         JNC     ??initNV_0
    276          
    277            // If a page compaction was interrupted before the old page was erased.
    278            if ( oldPg != OSAL_NV_PAGE_NULL )
   \   000048   5C42....     MOV.B   &pgRes, R12
   \   00004C   4B9A         CMP.B   R10, R11
   \   00004E   0F24         JEQ     ??initNV_7
    279            {
    280              /* Interrupted compaction before the target of compaction was put in use;
    281               * so erase the target of compaction and start again.
    282               */
    283              if ( pgRes != OSAL_NV_PAGE_NULL )
   \   000050   4C9A         CMP.B   R10, R12
   \   000052   0724         JEQ     ??initNV_8
    284              {
    285                erasePage( pgRes );
   \   000054   ........     CALLA   #erasePage
    286                (void)compactPage( oldPg, OSAL_NV_ITEM_NULL );
   \   000058   0D43         MOV.W   #0x0, R13
   \   00005A   4C4B         MOV.B   R11, R12
   \   00005C   ........     CALLA   #compactPage
   \   000060   0A3C         JMP     ??initNV_9
    287              }
    288              /* Interrupted compaction after the target of compaction was put in use,
    289               * but before the old page was erased; so erase it now and create a new reserve page.
    290               */
    291              else
    292              {
    293                erasePage( oldPg );
   \                     ??initNV_8:
   \   000062   4C4B         MOV.B   R11, R12
   \   000064   ........     CALLA   #erasePage
    294                pgRes = oldPg;
   \   000068   C24B....     MOV.B   R11, &pgRes
   \   00006C   043C         JMP     ??initNV_9
    295              }
    296            }
    297            else if ( pgRes != OSAL_NV_PAGE_NULL )
   \                     ??initNV_7:
   \   00006E   4C9A         CMP.B   R10, R12
   \   000070   0224         JEQ     ??initNV_9
    298            {
    299              erasePage( pgRes );  // The last page erase could have been interrupted by a power-cycle.
   \   000072   ........     CALLA   #erasePage
    300            }
    301            /* else if there is no reserve page, COMPACT_PAGE_CLEANUP() must have succeeded to put the old
    302             * reserve page (i.e. the target of the compacted items) into use but got interrupted by a reset
    303             * while trying to erase the page to be compacted. Such a page should only contain duplicate items
    304             * (i.e. all items will be marked 'Xfer') and thus should have the lost count equal to the page
    305             * size less the page header.
    306             */
    307          
    308            for ( pg = 0; pg < OSAL_NV_PAGES_USED; pg++ )
   \                     ??initNV_9:
   \   000076   4943         MOV.B   #0x0, R9
    309            {
    310              // Calculate page offset and lost bytes - any "old" item triggers an N^2 re-scan from start.
    311              if ( initPage( pg, OSAL_NV_ITEM_NULL, findDups ) != OSAL_NV_ITEM_NULL )
   \                     ??initNV_1:
   \   000078   4E48         MOV.B   R8, R14
   \   00007A   0D43         MOV.W   #0x0, R13
   \   00007C   4C49         MOV.B   R9, R12
   \   00007E   ........     CALLA   #initPage
   \   000082   0C93         CMP.W   #0x0, R12
   \   000084   0224         JEQ     ??initNV_10
    312              {
    313                findDups = TRUE;
   \   000086   5843         MOV.B   #0x1, R8
    314                pg = (256 - 1);  // Pre-decrement so that loop increment will start over at zero.
   \   000088   7943         MOV.B   #0xff, R9
    315                continue;
    316              }
    317            }
   \                     ??initNV_10:
   \   00008A   5953         ADD.B   #0x1, R9
   \   00008C   499A         CMP.B   R10, R9
   \   00008E   F42B         JNC     ??initNV_1
    318          
    319            if (findDups)
   \   000090   58B3         BIT.B   #0x1, R8
   \   000092   0928         JNC     ??initNV_11
    320            {
    321              // Final pass to calculate page lost after invalidating duplicate items.
    322              for ( pg = 0; pg < OSAL_NV_PAGES_USED; pg++ )
   \   000094   4943         MOV.B   #0x0, R9
    323              {
    324                (void)initPage( pg, OSAL_NV_ITEM_NULL, FALSE );
   \                     ??initNV_2:
   \   000096   4E43         MOV.B   #0x0, R14
   \   000098   0D43         MOV.W   #0x0, R13
   \   00009A   4C49         MOV.B   R9, R12
   \   00009C   ........     CALLA   #initPage
    325              }
   \   0000A0   5953         ADD.B   #0x1, R9
   \   0000A2   499A         CMP.B   R10, R9
   \   0000A4   F82B         JNC     ??initNV_2
    326            }
    327          
    328            if ( pgRes == OSAL_NV_PAGE_NULL )
   \                     ??initNV_11:
   \   0000A6   C29A....     CMP.B   R10, &pgRes
   \   0000AA   1920         JNE     ??initNV_12
    329            {
    330              uint8 idx, mostLost = 0;
   \   0000AC   4F43         MOV.B   #0x0, R15
    331          
    332              for ( idx = 0; idx < OSAL_NV_PAGES_USED; idx++ )
   \   0000AE   4E43         MOV.B   #0x0, R14
   \                     ??initNV_3:
   \   0000B0   4B4E         MOV.B   R14, R11
   \   0000B2   0B5B         RLA.W   R11
   \   0000B4   1B4B....     MOV.W   pgLost(R11), R11
   \   0000B8   3B90F803     CMP.W   #0x3f8, R11
   \   0000BC   0220         JNE     ??initNV_13
    333              {
    334                // Is this the page that was compacted?
    335                if (pgLost[idx] == (OSAL_NV_PAGE_SIZE - OSAL_NV_PAGE_HDR_SIZE))
    336                {
    337                  mostLost = idx;
   \   0000BE   4F4E         MOV.B   R14, R15
    338                  break;
   \   0000C0   093C         JMP     ??initNV_14
    339                }
    340                /* This check is not expected to be necessary because the above test should always succeed
    341                 * with an early loop exit.
    342                 */
    343                else if (pgLost[idx] > pgLost[mostLost])
   \                     ??initNV_13:
   \   0000C2   4D4F         MOV.B   R15, R13
   \   0000C4   0D5D         RLA.W   R13
   \   0000C6   8D9B....     CMP.W   R11, pgLost(R13)
   \   0000CA   012C         JC      ??initNV_15
    344                {
    345                  mostLost = idx;
   \   0000CC   4F4E         MOV.B   R14, R15
    346                }
    347              }
   \                     ??initNV_15:
   \   0000CE   5E53         ADD.B   #0x1, R14
   \   0000D0   4E9A         CMP.B   R10, R14
   \   0000D2   EE2B         JNC     ??initNV_3
    348          
    349              pgRes = mostLost;
   \                     ??initNV_14:
   \   0000D4   C24F....     MOV.B   R15, &pgRes
    350              erasePage( pgRes );  // The last page erase had been interrupted by a power-cycle.
   \   0000D8   4C4F         MOV.B   R15, R12
   \   0000DA   ........     CALLA   #erasePage
    351            }
    352          
    353            return TRUE;
   \                     ??initNV_12:
   \   0000DE   5C43         MOV.B   #0x1, R12
   \   0000E0   ........     BRA     #?Subroutine0
    354          }
    355          
    356          /*********************************************************************
    357           * @fn      setPageUse
    358           *
    359           * @brief   Set page header active/inUse state according to 'inUse'.
    360           *
    361           * @param   pg - Valid NV page to verify and init.
    362           * @param   inUse - Boolean TRUE if inUse, FALSE if only active.
    363           *
    364           * @return  none
    365           */

   \                                 In  segment CODE, align 2, keep-with-next
    366          static void setPageUse( uint8 pg, uint8 inUse )
   \                     setPageUse:
    367          {
   \   000000   3182         SUB.W   #0x8, SP
    368            osalNvPgHdr_t pgHdr;
    369          
    370            pgHdr.active = OSAL_NV_ZEROED_ID;
   \   000002   81430000     MOV.W   #0x0, 0(SP)
    371          
    372            if ( inUse )
   \   000006   4D93         CMP.B   #0x0, R13
   \   000008   0220         JNE     ??setPageUse_0
   \   00000A   3F43         MOV.W   #0xffff, R15
   \   00000C   013C         JMP     ??setPageUse_1
   \                     ??setPageUse_0:
   \   00000E   0F43         MOV.W   #0x0, R15
   \                     ??setPageUse_1:
   \   000010   814F0200     MOV.W   R15, 0x2(SP)
    373            {
    374              pgHdr.inUse = OSAL_NV_ZEROED_ID;
    375            }
    376            else
    377            {
    378              pgHdr.inUse = OSAL_NV_ERASED_ID;
    379            }
    380          
    381            flashWrite(OSAL_NV_PAGE_TO_PTR(pg)+OSAL_NV_PAGE_HDR_OFFSET, OSAL_NV_HDR_HALF, (uint8 *)(&pgHdr));
   \   000014   0E41         MOV.W   SP, R14
   \   000016   0E53         ADD.W   #0x0, R14
   \   000018   2D42         MOV.W   #0x4, R13
   \   00001A   ........     CALLA   #?Subroutine2
   \                     ??CrossCallReturnLabel_26:
   \   00001E   ........     CALLA   #flashWrite
    382          }
   \   000022   3152         ADD.W   #0x8, SP
   \   000024   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine2:
   \   000000   4C4C         MOV.B   R12, R12
   \   000002                REQUIRE ??Subroutine2_0
   \   000002                // Fall through to label ??Subroutine2_0

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ??Subroutine2_0:
   \   000000   0C5C         RLA.W   R12
   \   000002                REQUIRE ??Subroutine2_1
   \   000002                // Fall through to label ??Subroutine2_1

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ??Subroutine2_1:
   \   000000   3C506500     ADD.W   #0x65, R12
   \   000004                RPT     #0x9
   \   000004   48180C5C     RLAX.W  R12
   \   000008   1001         RETA
    383          
    384          /*********************************************************************
    385           * @fn      initPage
    386           *
    387           * @brief   Walk the page items; calculate checksums, lost bytes & page offset.
    388           *
    389           * @param   pg - Valid NV page to verify and init.
    390           * @param   id - Valid NV item Id to use function as a "findItem".
    391           *               If set to NULL then just perform the page initialization.
    392           * @param   findDups - TRUE on recursive call from initNV() to find and zero-out duplicate items
    393           *                     left from a write that is interrupted by a reset/power-cycle.
    394           *                     FALSE otherwise.
    395           *
    396           * @return  If 'id' is non-NULL and good checksums are found, return the offset
    397           *          of the data corresponding to item Id; else OSAL_NV_ITEM_NULL.
    398           */

   \                                 In  segment CODE, align 2, keep-with-next
    399          static uint16 initPage( uint8 pg, uint16 id, uint8 findDups )
   \                     initPage:
    400          {
   \   000000   5B15         PUSHM.W #0x6, R11
   \   000002   31800A00     SUB.W   #0xa, SP
   \   000006   4A4C         MOV.B   R12, R10
   \   000008   0B4D         MOV.W   R13, R11
   \   00000A   484E         MOV.B   R14, R8
   \   00000C   3942         MOV.W   #0x8, R9
    401            uint16 offset = OSAL_NV_PAGE_HDR_SIZE;
    402            uint16 sz, lost = 0;
   \   00000E   0643         MOV.W   #0x0, R6
    403            osalNvHdr_t hdr;
    404          
    405            do
    406            {
    407              readHdr( pg, offset, (uint8 *)(&hdr) );
   \                     ??initPage_0:
   \   000010   ........     CALLA   #?Subroutine4
    408          
    409              if ( hdr.id == OSAL_NV_ERASED_ID )
   \                     ??CrossCallReturnLabel_15:
   \   000014   B1930200     CMP.W   #0xffff, 0x2(SP)
   \   000018   4A24         JEQ     ??initPage_1
    410              {
    411                break;
    412              }
    413          
    414              // Get the actual size in bytes which is the ceiling(hdr.len)
    415              sz = OSAL_NV_DATA_SIZE( hdr.len );
   \   00001A   ........     CALLA   #?Subroutine7
    416          
    417              // A bad 'len' write has blown away the rest of the page.
    418              if (sz > (OSAL_NV_PAGE_SIZE - OSAL_NV_HDR_SIZE - offset))
   \                     ??CrossCallReturnLabel_5:
   \   00001E   062C         JC      ??initPage_2
    419              {
    420                lost += (OSAL_NV_PAGE_SIZE - offset);
   \   000020   36500004     ADD.W   #0x400, R6
   \   000024   0689         SUB.W   R9, R6
    421                offset = OSAL_NV_PAGE_SIZE;
   \   000026   39400004     MOV.W   #0x400, R9
    422                break;
   \   00002A   413C         JMP     ??initPage_1
    423              }
    424          
    425              offset += OSAL_NV_HDR_SIZE;
   \                     ??initPage_2:
   \   00002C   3952         ADD.W   #0x8, R9
    426          
    427              if ( hdr.id != OSAL_NV_ZEROED_ID )
   \   00002E   81930200     CMP.W   #0x0, 0x2(SP)
   \   000032   3624         JEQ     ??initPage_3
    428              {
    429                /* This trick allows function to do double duty for findItem() without
    430                 * compromising its essential functionality at powerup initialization.
    431                 */
    432                if ( id != OSAL_NV_ITEM_NULL )
   \   000034   0B93         CMP.W   #0x0, R11
   \   000036   1124         JEQ     ??initPage_4
    433                {
    434                  /* This trick allows asking to find the old/transferred item in case
    435                   * of a successful new item write that gets interrupted before the
    436                   * old item can be zeroed out.
    437                   */
    438                  if ( (id & 0x7fff) == hdr.id )
   \   000038   0F4B         MOV.W   R11, R15
   \   00003A   3FF0FF7F     AND.W   #0x7fff, R15
   \   00003E   1F910200     CMP.W   0x2(SP), R15
   \   000042   3120         JNE     ??initPage_5
    439                  {
    440                    if ( (((id & OSAL_NV_SOURCE_ID) == 0) && (hdr.stat == OSAL_NV_ERASED_ID)) ||
    441                         (((id & OSAL_NV_SOURCE_ID) != 0) && (hdr.stat != OSAL_NV_ERASED_ID)) )
   \   000044   1F410800     MOV.W   0x8(SP), R15
   \   000048   0B93         CMP.W   #0x0, R11
   \   00004A   0338         JL      ??initPage_6
   \   00004C   3F93         CMP.W   #0xffff, R15
   \   00004E   2B20         JNE     ??initPage_5
   \   000050   023C         JMP     ??initPage_7
   \                     ??initPage_6:
   \   000052   3F93         CMP.W   #0xffff, R15
   \   000054   2824         JEQ     ??initPage_5
    442                    {
    443                      return offset;
   \                     ??initPage_7:
   \   000056   0C49         MOV.W   R9, R12
   \   000058   303C         JMP     ??initPage_8
    444                    }
    445                  }
    446                }
    447                // When invoked from the osal_nv_init(), verify checksums and find & zero any duplicates.
    448                else
    449                {
    450                  if ( hdr.chk == calcChkF( pg, offset, hdr.len ) )
   \                     ??initPage_4:
   \   00005A   ........     CALLA   #?Subroutine5
   \                     ??CrossCallReturnLabel_0:
   \   00005E   1920         JNE     ??initPage_9
    451                  {
    452                    if ( findDups )
   \   000060   1F410800     MOV.W   0x8(SP), R15
   \   000064   4893         CMP.B   #0x0, R8
   \   000066   1124         JEQ     ??initPage_10
    453                    {
    454                      if ( hdr.stat == OSAL_NV_ERASED_ID )
   \   000068   3F93         CMP.W   #0xffff, R15
   \   00006A   1D20         JNE     ??initPage_5
    455                      {
    456                        /* The trick of setting the MSB of the item Id causes the logic
    457                         * immediately above to return a valid page only if the header 'stat'
    458                         * indicates that it was the older item being transferred.
    459                         */
    460                        uint8 findPg;
    461                        uint16 off = findItem( (hdr.id | OSAL_NV_SOURCE_ID), &findPg );
   \   00006C   0D41         MOV.W   SP, R13
   \   00006E   0D53         ADD.W   #0x0, R13
   \   000070   1C410200     MOV.W   0x2(SP), R12
   \   000074   3CD00080     BIS.W   #0x8000, R12
   \   000078   ........     CALLA   #findItem
   \   00007C   0D4C         MOV.W   R12, R13
    462          
    463                        if ( off != OSAL_NV_ITEM_NULL )
   \   00007E   0C93         CMP.W   #0x0, R12
   \   000080   1224         JEQ     ??initPage_5
    464                        {
    465                          setItem( findPg, off, eNvZero );  // Mark old duplicate as invalid.
   \   000082   5E43         MOV.B   #0x1, R14
   \   000084   ........     CALLA   #??Subroutine8_0
    466                        }
    467                      }
    468                    }
   \                     ??CrossCallReturnLabel_17:
   \   000088   0E3C         JMP     ??initPage_5
    469                    // Any "old" item immediately exits and triggers the N^2 exhaustive initialization.
    470                    else if ( hdr.stat != OSAL_NV_ERASED_ID )
   \                     ??initPage_10:
   \   00008A   3F93         CMP.W   #0xffff, R15
   \   00008C   0C24         JEQ     ??initPage_5
    471                    {
    472                      return OSAL_NV_ERASED_ID;
   \   00008E   3C43         MOV.W   #0xffff, R12
   \   000090   143C         JMP     ??initPage_8
    473                    }
    474                  }
    475                  else
    476                  {
    477                    setItem( pg, offset, eNvZero );  // Mark bad checksum as invalid.
   \                     ??initPage_9:
   \   000092   5E43         MOV.B   #0x1, R14
   \   000094   0D49         MOV.W   R9, R13
   \   000096   4C4A         MOV.B   R10, R12
   \   000098   ........     CALLA   #setItem
    478                    lost += (OSAL_NV_HDR_SIZE + sz);
   \   00009C   0F47         MOV.W   R7, R15
   \   00009E   013C         JMP     ??initPage_11
    479                  }
    480                }
    481              }
    482              else
    483              {
    484                lost += (OSAL_NV_HDR_SIZE + sz);
   \                     ??initPage_3:
   \   0000A0   0F4E         MOV.W   R14, R15
   \                     ??initPage_11:
   \   0000A2   3F52         ADD.W   #0x8, R15
   \   0000A4   065F         ADD.W   R15, R6
    485              }
    486              offset += sz;
   \                     ??initPage_5:
   \   0000A6   0957         ADD.W   R7, R9
    487          
    488            } while (offset < (OSAL_NV_PAGE_SIZE - OSAL_NV_HDR_SIZE));
   \   0000A8   3990F803     CMP.W   #0x3f8, R9
   \   0000AC   B12B         JNC     ??initPage_0
    489          
    490            pgOff[pg] = offset;
   \                     ??initPage_1:
   \   0000AE   0A5A         RLA.W   R10
   \   0000B0   8A49....     MOV.W   R9, pgOff(R10)
    491            pgLost[pg] = lost;
   \   0000B4   8A46....     MOV.W   R6, pgLost(R10)
    492          
    493            return OSAL_NV_ITEM_NULL;
   \   0000B8   0C43         MOV.W   #0x0, R12
   \                     ??initPage_8:
   \   0000BA   31500A00     ADD.W   #0xa, SP
   \   0000BE   5617         POPM.W  #0x6, R11
   \   0000C0   1001         RETA
    494          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine4:
   \   000000   0E41         MOV.W   SP, R14
   \   000002   3E500600     ADD.W   #0x6, R14
   \   000006                REQUIRE ??Subroutine12_0
   \   000006                // Fall through to label ??Subroutine12_0

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ??Subroutine12_0:
   \   000000   0D49         MOV.W   R9, R13
   \   000002                REQUIRE ??Subroutine4_0
   \   000002                // Fall through to label ??Subroutine4_0

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ??Subroutine4_0:
   \   000000   4C4A         MOV.B   R10, R12
   \   000002   ........     BRA     #readHdr

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ??Subroutine8_0:
   \   000000   5C410400     MOV.B   0x4(SP), R12
   \   000004   ........     BRA     #setItem

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine7:
   \   000000   1E410800     MOV.W   0x8(SP), R14
   \   000004   074E         MOV.W   R14, R7
   \   000006   3F40F803     MOV.W   #0x3f8, R15
   \   00000A   0F89         SUB.W   R9, R15
   \   00000C   0F9E         CMP.W   R14, R15
   \   00000E   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine5:
   \   000000   0D49         MOV.W   R9, R13
   \   000002   4C4A         MOV.B   R10, R12
   \   000004   ........     CALLA   #calcChkF
   \   000008   819C0A00     CMP.W   R12, 0xa(SP)
   \   00000C   1001         RETA
    495          
    496          /*********************************************************************
    497           * @fn      erasePage
    498           *
    499           * @brief   Erases a page in Flash.
    500           *
    501           * @param   pg - Valid NV page to erase.
    502           *
    503           * @return  none
    504           */

   \                                 In  segment CODE, align 2, keep-with-next
    505          static void erasePage( uint8 pg )
   \                     erasePage:
    506          {
   \   000000   1B15         PUSHM.W #0x2, R11
    507            uint8 *addr = OSAL_NV_PAGE_TO_PTR(pg);
   \   000002   4A4C         MOV.B   R12, R10
   \   000004   0A5A         RLA.W   R10
   \   000006   0B4A         MOV.W   R10, R11
   \   000008   3B506500     ADD.W   #0x65, R11
   \   00000C                RPT     #0x9
   \   00000C   48180B5B     RLAX.W  R11
    508            uint8 cnt = OSAL_NV_PHY_PER_PG;
    509          
    510            do {
    511              flashErasePage(addr);
   \   000010   0C4B         MOV.W   R11, R12
   \   000012   ........     CALLA   #flashErasePage
    512              addr += HAL_FLASH_PAGE_SIZE;
    513            } while (--cnt);
   \   000016   3B500002     ADD.W   #0x200, R11
   \   00001A   0C4B         MOV.W   R11, R12
   \   00001C   ........     CALLA   #flashErasePage
    514          
    515            pgOff[pg] = OSAL_NV_PAGE_HDR_SIZE;
   \   000020   BA42....     MOV.W   #0x8, pgOff(R10)
    516            pgLost[pg] = 0;
   \   000024   8A43....     MOV.W   #0x0, pgLost(R10)
    517          }
   \   000028   1A17         POPM.W  #0x2, R11
   \   00002A   1001         RETA
    518          
    519          /*********************************************************************
    520           * @fn      compactPage
    521           *
    522           * @brief   Compacts the page specified.
    523           *
    524           * @param   srcPg - Valid NV page to erase.
    525           * @param   skipId - Item Id to not compact.
    526           *
    527           * @return  TRUE if valid items from 'srcPg' are successully compacted onto the 'pgRes';
    528           *          FALSE otherwise.
    529           *          Note that on a failure, this could loop, re-erasing the 'pgRes' and re-compacting with
    530           *          the risk of infinitely looping on HAL flash failure.
    531           *          Worst case scenario: HAL flash starts failing in general, perhaps low Vdd?
    532           *          All page compactions will fail which will cause all osal_nv_write() calls to return
    533           *          NV_OPER_FAILED.
    534           *          Eventually, all pages in use may also be in the state of "pending compaction" where
    535           *          the page header member OSAL_NV_PG_XFER is zeroed out.
    536           *          During this "HAL flash brown-out", the code will run and OTA should work (until low Vdd
    537           *          causes an actual chip brown-out, of course.) Although no new NV items will be created
    538           *          or written, the last value written with a return value of SUCCESS can continue to be
    539           *          read successfully.
    540           *          If eventually HAL flash starts working again, all of the pages marked as
    541           *          "pending compaction" may or may not be eventually compacted. But, initNV() will
    542           *          deterministically clean-up one page pending compaction per power-cycle
    543           *          (if HAL flash is working.) Nevertheless, one erased reserve page will be maintained
    544           *          through such a scenario.
    545           */

   \                                 In  segment CODE, align 2, keep-with-next
    546          static uint8 compactPage( uint8 srcPg, uint16 skipId )
   \                     compactPage:
    547          {
   \   000000   7B15         PUSHM.W #0x8, R11
   \   000002   31800A00     SUB.W   #0xa, SP
   \   000006   4A4C         MOV.B   R12, R10
   \   000008   084D         MOV.W   R13, R8
   \   00000A   3942         MOV.W   #0x8, R9
    548            uint16 srcOff = OSAL_NV_PAGE_HDR_SIZE;
    549            uint8 rtrn = TRUE;
   \   00000C   5443         MOV.B   #0x1, R4
   \   00000E   3B40....     MOV.W   #pgRes, R11
    550          
    551            while ( srcOff < (OSAL_NV_PAGE_SIZE - OSAL_NV_HDR_SIZE ) )
    552            {
    553              osalNvHdr_t hdr;
    554              uint16 sz, dstOff = pgOff[pgRes];
   \                     ??compactPage_0:
   \   000012   6F4B         MOV.B   @R11, R15
   \   000014   0F5F         RLA.W   R15
   \   000016   164F....     MOV.W   pgOff(R15), R6
    555          
    556              readHdr( srcPg, srcOff, (uint8 *)(&hdr) );
   \   00001A   ........     CALLA   #?Subroutine4
    557          
    558              if ( hdr.id == OSAL_NV_ERASED_ID )
   \                     ??CrossCallReturnLabel_14:
   \   00001E   B1930200     CMP.W   #0xffff, 0x2(SP)
   \   000022   5A24         JEQ     ??compactPage_2
    559              {
    560                break;
    561              }
    562          
    563              // Get the actual size in bytes which is the ceiling(hdr.len)
    564              sz = OSAL_NV_DATA_SIZE( hdr.len );
   \   000024   ........     CALLA   #?Subroutine7
    565          
    566              if ( (sz > (OSAL_NV_PAGE_SIZE - OSAL_NV_HDR_SIZE - srcOff)) ||
    567                   (sz > (OSAL_NV_PAGE_SIZE - OSAL_NV_HDR_SIZE - dstOff)) )
   \                     ??CrossCallReturnLabel_6:
   \   000028   5728         JNC     ??compactPage_2
   \   00002A   3F40F803     MOV.W   #0x3f8, R15
   \   00002E   0F86         SUB.W   R6, R15
   \   000030   0F9E         CMP.W   R14, R15
   \   000032   5228         JNC     ??compactPage_2
    568              {
    569                break;
    570              }
    571          
    572              srcOff += OSAL_NV_HDR_SIZE;
   \   000034   3952         ADD.W   #0x8, R9
    573          
    574              if ( (hdr.id != OSAL_NV_ZEROED_ID) && (hdr.id != skipId) )
   \   000036   81930200     CMP.W   #0x0, 0x2(SP)
   \   00003A   4A24         JEQ     ??compactPage_3
   \   00003C   81980200     CMP.W   R8, 0x2(SP)
   \   000040   4724         JEQ     ??compactPage_3
    575              {
    576                if ( hdr.chk == calcChkF( srcPg, srcOff, hdr.len ) )
   \   000042   ........     CALLA   #?Subroutine5
   \                     ??CrossCallReturnLabel_1:
   \   000046   4420         JNE     ??compactPage_3
    577                {
    578                  /* Prevent excessive re-writes to item header caused by numerous, rapid, & successive
    579                   * OSAL_Nv interruptions caused by resets.
    580                   */
    581                  if ( hdr.stat == OSAL_NV_ERASED_ID )
   \   000048   B1930800     CMP.W   #0xffff, 0x8(SP)
   \   00004C   0520         JNE     ??compactPage_4
    582                  {
    583                    setItem( srcPg, srcOff, eNvXfer );
   \   00004E   4E43         MOV.B   #0x0, R14
   \   000050   0D49         MOV.W   R9, R13
   \   000052   4C4A         MOV.B   R10, R12
   \   000054   ........     CALLA   #setItem
    584                  }
    585          
    586                  if ( writeItem( pgRes, hdr.id, hdr.len, NULL, FALSE ) )
   \                     ??compactPage_4:
   \   000058   4312         PUSH.B  #0x0
   \   00005A   0F43         MOV.W   #0x0, R15
   \   00005C   1E410600     MOV.W   0x6(SP), R14
   \   000060   1D410400     MOV.W   0x4(SP), R13
   \   000064   6C4B         MOV.B   @R11, R12
   \   000066   ........     CALLA   #writeItem
   \   00006A   2153         ADD.W   #0x2, SP
   \   00006C   4C93         CMP.B   #0x0, R12
   \   00006E   3F24         JEQ     ??compactPage_5
    587                  {
    588                    uint16 chk;
    589          
    590                    dstOff += OSAL_NV_HDR_SIZE;
   \   000070   3652         ADD.W   #0x8, R6
    591                    xferBuf( srcPg, srcOff, pgRes, dstOff, sz );
   \   000072   0712         PUSH.W  R7
   \   000074   0F46         MOV.W   R6, R15
   \   000076   6E4B         MOV.B   @R11, R14
   \   000078   0D49         MOV.W   R9, R13
   \   00007A   4C4A         MOV.B   R10, R12
   \   00007C   ........     CALLA   #xferBuf
    592                    // Calculate and write the new checksum.
    593                    chk = calcChkF( pgRes, dstOff, hdr.len );
   \   000080   1E410600     MOV.W   0x6(SP), R14
   \   000084   0D46         MOV.W   R6, R13
   \   000086   6C4B         MOV.B   @R11, R12
   \   000088   ........     CALLA   #calcChkF
   \   00008C   814C0200     MOV.W   R12, 0x2(SP)
    594                    dstOff -= OSAL_NV_HDR_SIZE;
   \   000090   3682         SUB.W   #0x8, R6
    595                    flashWrite(OSAL_NV_PAGE_TO_PTR(pgRes) + dstOff + OSAL_NV_HDR_CHK, OSAL_NV_HDR_ITEM,
    596                                                                                      (uint8 *)(&chk));
   \   000092   0E41         MOV.W   SP, R14
   \   000094   2E53         ADD.W   #0x2, R14
   \   000096   2D43         MOV.W   #0x2, R13
   \   000098   6C4B         MOV.B   @R11, R12
   \   00009A   ........     CALLA   #??Subroutine2_0
   \                     ??CrossCallReturnLabel_24:
   \   00009E   0C56         ADD.W   R6, R12
   \   0000A0   2C52         ADD.W   #0x4, R12
   \   0000A2   ........     CALLA   #flashWrite
    597                    chk = hdr.chk;
   \   0000A6   914108000200 MOV.W   0x8(SP), 0x2(SP)
    598                    readHdr( pgRes, dstOff, (uint8 *)(&hdr) );
   \   0000AC   0E41         MOV.W   SP, R14
   \   0000AE   2E52         ADD.W   #0x4, R14
   \   0000B0   0D46         MOV.W   R6, R13
   \   0000B2   6C4B         MOV.B   @R11, R12
   \   0000B4   ........     CALLA   #readHdr
    599          
    600                    if ( chk != hdr.chk )
   \   0000B8   2153         ADD.W   #0x2, SP
   \   0000BA   919106000000 CMP.W   0x6(SP), 0(SP)
   \   0000C0   1620         JNE     ??compactPage_5
    601                    {
    602                      rtrn = FALSE;
    603                      break;
    604                    }
    605                    else
    606                    {
    607                      hotItemUpdate(pgRes, dstOff+OSAL_NV_HDR_SIZE, hdr.id);
   \   0000C2   1E410200     MOV.W   0x2(SP), R14
   \   0000C6   3652         ADD.W   #0x8, R6
   \   0000C8   0D46         MOV.W   R6, R13
   \   0000CA   6C4B         MOV.B   @R11, R12
   \   0000CC   ........     CALLA   #hotItemUpdate
    608                    }
    609                  }
    610                  else
    611                  {
    612                    rtrn = FALSE;
    613                    break;
    614                  }
    615                }
    616              }
    617          
    618              srcOff += sz;
   \                     ??compactPage_3:
   \   0000D0   0957         ADD.W   R7, R9
   \   0000D2   3990F803     CMP.W   #0x3f8, R9
   \   0000D6   9D2B         JNC     ??compactPage_0
    619            }
    620          
    621            if (rtrn == FALSE)
    622            {
    623              erasePage(pgRes);
    624            }
    625            else if (skipId == OSAL_NV_ITEM_NULL)
   \                     ??compactPage_2:
   \   0000D8   0893         CMP.W   #0x0, R8
   \   0000DA   0420         JNE     ??compactPage_1
    626            {
    627              COMPACT_PAGE_CLEANUP(srcPg);
   \   0000DC   5D43         MOV.B   #0x1, R13
   \   0000DE   6C4B         MOV.B   @R11, R12
   \   0000E0   ........     CALLA   #?Subroutine11
    628            }
    629            // else invoking function must cleanup.
    630          
    631            return rtrn;
   \                     ??compactPage_1:
   \   0000E4   4C44         MOV.B   R4, R12
   \   0000E6   31500A00     ADD.W   #0xa, SP
   \   0000EA   7417         POPM.W  #0x8, R11
   \   0000EC   1001         RETA
   \                     ??compactPage_5:
   \   0000EE   4443         MOV.B   #0x0, R4
   \   0000F0   6C4B         MOV.B   @R11, R12
   \   0000F2   ........     CALLA   #erasePage
   \   0000F6   F63F         JMP     ??compactPage_1
   \   0000F8   0343         NOP
    632          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine11:
   \   000000   ........     CALLA   #setPageUse
   \   000004   4C4A         MOV.B   R10, R12
   \   000006   ........     CALLA   #erasePage
   \   00000A   C24A....     MOV.B   R10, &pgRes
   \   00000E   1001         RETA
    633          
    634          /*********************************************************************
    635           * @fn      findItem
    636           *
    637           * @brief   Find an item Id in NV and return the page and offset to its data.
    638           *
    639           * @param   id - Valid NV item Id.
    640           *
    641           * @return  Offset of data corresponding to item Id, if found;
    642           *          otherwise OSAL_NV_ITEM_NULL.
    643           *
    644           *          The page containing the item, if found;
    645           *          otherwise no valid assignment made - left equal to item Id.
    646           *
    647           */

   \                                 In  segment CODE, align 2, keep-with-next
    648          static uint16 findItem( uint16 id, uint8 *findPg )
   \                     findItem:
    649          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   0A4C         MOV.W   R12, R10
   \   000004   0B4D         MOV.W   R13, R11
   \   000006   023C         JMP     ??findItem_2
    650            uint16 off;
    651            uint8 pg;
    652          
    653            for ( pg = 0; pg < OSAL_NV_PAGES_USED; pg++ )
    654            {
    655              if ( (off = initPage( pg, id, FALSE )) != OSAL_NV_ITEM_NULL )
    656              {
    657                *findPg = pg;
    658                return off;
    659              }
    660            }
    661          
    662            // Now attempt to find the item as the "old" item of a failed/interrupted NV write.
    663            if ( (id & OSAL_NV_SOURCE_ID) == 0 )
    664            {
    665              return findItem( (id | OSAL_NV_SOURCE_ID), findPg );
   \                     ??findItem_1:
   \   000008   3AD00080     BIS.W   #0x8000, R10
    666            }
   \                     ??findItem_2:
   \   00000C   4843         MOV.B   #0x0, R8
   \                     ??findItem_0:
   \   00000E   4E43         MOV.B   #0x0, R14
   \   000010   0D4A         MOV.W   R10, R13
   \   000012   4C48         MOV.B   R8, R12
   \   000014   ........     CALLA   #initPage
   \   000018   0C93         CMP.W   #0x0, R12
   \   00001A   0324         JEQ     ??findItem_3
   \   00001C   CB480000     MOV.B   R8, 0(R11)
   \   000020   0A3C         JMP     ??findItem_4
   \                     ??findItem_3:
   \   000022   5853         ADD.B   #0x1, R8
   \   000024   78900C00     CMP.B   #0xc, R8
   \   000028   F22B         JNC     ??findItem_0
   \   00002A   0A93         CMP.W   #0x0, R10
   \   00002C   ED37         JGE     ??findItem_1
    667            else
    668            {
    669              *findPg = OSAL_NV_PAGE_NULL;
   \   00002E   FB400C000000 MOV.B   #0xc, 0(R11)
    670              return OSAL_NV_ITEM_NULL;
   \   000034   0C43         MOV.W   #0x0, R12
   \                     ??findItem_4:
   \   000036   3817         POPM.W  #0x4, R11
   \   000038   1001         RETA
    671            }
    672          }
    673          
    674          /*********************************************************************
    675           * @fn      initItem
    676           *
    677           * @brief   An NV item is created and initialized with the data passed to the function, if any.
    678           *
    679           * @param   flag - TRUE if the 'buf' parameter contains data for the call to writeItem().
    680           *                 (i.e. if invoked from osal_nv_item_init() ).
    681           *                 FALSE if writeItem() should just write the header and the 'buf' parameter
    682           *                 is ok to use as a return value of the page number to be cleaned with
    683           *                 COMPACT_PAGE_CLEANUP().
    684           *                 (i.e. if invoked from osal_nv_write() ).
    685           * @param   id  - Valid NV item Id.
    686           * @param   len - Item data length.
    687           * @param  *buf - Pointer to item initalization data. Set to NULL if none.
    688           *
    689           * @return  The OSAL Nv page number if item write and read back checksums ok;
    690           *          OSAL_NV_PAGE_NULL otherwise.
    691           */

   \                                 In  segment CODE, align 2, keep-with-next
    692          static uint8 initItem( uint8 flag, uint16 id, uint16 len, void *buf )
   \                     initItem:
    693          {
   \   000000   7B15         PUSHM.W #0x8, R11
   \   000002   2183         SUB.W   #0x2, SP
   \   000004   494C         MOV.B   R12, R9
   \   000006   064D         MOV.W   R13, R6
   \   000008   074E         MOV.W   R14, R7
   \   00000A   044F         MOV.W   R15, R4
    694            uint16 sz = OSAL_NV_ITEM_SIZE( len );
   \   00000C   0F4E         MOV.W   R14, R15
   \   00000E   3F52         ADD.W   #0x8, R15
   \   000010   814F0000     MOV.W   R15, 0(SP)
    695            uint8 rtrn = OSAL_NV_PAGE_NULL;
   \   000014   7B400C00     MOV.B   #0xc, R11
    696            uint8 cnt = OSAL_NV_PAGES_USED;
   \   000018   4E4B         MOV.B   R11, R14
    697            uint8 pg = pgRes+1;  // Set to 1 after the reserve page to even wear across all available pages.
   \   00001A   3840....     MOV.W   #pgRes, R8
   \   00001E   6A48         MOV.B   @R8, R10
   \   000020   5A53         ADD.B   #0x1, R10
    698          
    699            do {
    700              if (pg >= OSAL_NV_PAGES_USED)
   \                     ??initItem_0:
   \   000022   4A9B         CMP.B   R11, R10
   \   000024   0128         JNC     ??initItem_1
    701              {
    702                pg = 0;
   \   000026   4A43         MOV.B   #0x0, R10
    703              }
    704              if ( pg != pgRes )
   \                     ??initItem_1:
   \   000028   6A98         CMP.B   @R8, R10
   \   00002A   0B24         JEQ     ??initItem_2
    705              {
    706                if ( sz <= (OSAL_NV_PAGE_SIZE - pgOff[pg] + pgLost[pg]) )
   \   00002C   4C4A         MOV.B   R10, R12
   \   00002E   0C5C         RLA.W   R12
   \   000030   3F400004     MOV.W   #0x400, R15
   \   000034   1F8C....     SUB.W   pgOff(R12), R15
   \   000038   0D4F         MOV.W   R15, R13
   \   00003A   1D5C....     ADD.W   pgLost(R12), R13
   \   00003E   2D91         CMP.W   @SP, R13
   \   000040   042C         JC      ??initItem_3
    707                {
    708                  break;
    709                }
    710              }
    711              pg++;
   \                     ??initItem_2:
   \   000042   5A53         ADD.B   #0x1, R10
    712            } while (--cnt);
   \   000044   7E53         ADD.B   #0xff, R14
   \   000046   ED23         JNE     ??initItem_0
   \   000048   343C         JMP     ??initItem_4
    713          
    714            if (cnt)
   \                     ??initItem_3:
   \   00004A   4E93         CMP.B   #0x0, R14
   \   00004C   3224         JEQ     ??initItem_4
    715            {
    716              // Item fits if an old page is compacted.
    717              if ( sz > (OSAL_NV_PAGE_SIZE - pgOff[pg]) )
   \   00004E   2F91         CMP.W   @SP, R15
   \   000050   252C         JC      ??initItem_5
    718              {
    719                // Mark the old page as being in process of compaction.
    720                sz = OSAL_NV_ZEROED_ID;
   \   000052   81430000     MOV.W   #0x0, 0(SP)
    721                flashWrite(OSAL_NV_PAGE_TO_PTR(pg) + OSAL_NV_PAGE_HDR_OFFSET + OSAL_NV_PG_XFER,
    722                                                     OSAL_NV_HDR_ITEM, (uint8 *)(&sz));
   \   000056   0E41         MOV.W   SP, R14
   \   000058   0E53         ADD.W   #0x0, R14
   \   00005A   2D43         MOV.W   #0x2, R13
   \   00005C   ........     CALLA   #??Subroutine2_1
   \                     ??CrossCallReturnLabel_22:
   \   000060   2C52         ADD.W   #0x4, R12
   \   000062   ........     CALLA   #flashWrite
    723          
    724                /* First the old page is compacted, then the new item will be the last one written to what
    725                 * had been the reserved page.
    726                 */
    727                if (compactPage( pg, id ))
   \   000066   0D46         MOV.W   R6, R13
   \   000068   4C4A         MOV.B   R10, R12
   \   00006A   ........     CALLA   #compactPage
   \   00006E   4C93         CMP.B   #0x0, R12
   \   000070   2024         JEQ     ??initItem_4
    728                {
    729                  if ( writeItem( pgRes, id, len, buf, flag ) )
   \   000072   4912         PUSH.B  R9
   \   000074   0F44         MOV.W   R4, R15
   \   000076   0E47         MOV.W   R7, R14
   \   000078   0D46         MOV.W   R6, R13
   \   00007A   6C48         MOV.B   @R8, R12
   \   00007C   ........     CALLA   #writeItem
   \   000080   2153         ADD.W   #0x2, SP
   \   000082   4C93         CMP.B   #0x0, R12
   \   000084   0124         JEQ     ??initItem_6
    730                  {
    731                    rtrn = pgRes;
   \   000086   6B48         MOV.B   @R8, R11
    732                  }
    733          
    734                  if ( flag == FALSE )
   \                     ??initItem_6:
   \   000088   4993         CMP.B   #0x0, R9
   \   00008A   0320         JNE     ??initItem_7
    735                  {
    736                    /* Overload 'buf' as an OUT parameter to pass back to the calling function
    737                     * the old page to be cleaned up.
    738                     */
    739                    *(uint8 *)buf = pg;
   \   00008C   C44A0000     MOV.B   R10, 0(R4)
   \   000090   103C         JMP     ??initItem_4
    740                  }
    741                  else
    742                  {
    743                    /* Safe to do the compacted page cleanup even if writeItem() above failed because the
    744                     * item does not yet exist since this call with flag==TRUE is from osal_nv_item_init().
    745                     */
    746                    COMPACT_PAGE_CLEANUP( pg );
   \                     ??initItem_7:
   \   000092   5D43         MOV.B   #0x1, R13
   \   000094   6C48         MOV.B   @R8, R12
   \   000096   ........     CALLA   #?Subroutine11
   \                     ??CrossCallReturnLabel_10:
   \   00009A   0B3C         JMP     ??initItem_4
    747                  }
    748                }
    749              }
    750              else
    751              {
    752                if ( writeItem( pg, id, len, buf, flag ) )
   \                     ??initItem_5:
   \   00009C   4912         PUSH.B  R9
   \   00009E   0F44         MOV.W   R4, R15
   \   0000A0   0E47         MOV.W   R7, R14
   \   0000A2   0D46         MOV.W   R6, R13
   \   0000A4   4C4A         MOV.B   R10, R12
   \   0000A6   ........     CALLA   #writeItem
   \   0000AA   2153         ADD.W   #0x2, SP
   \   0000AC   4C93         CMP.B   #0x0, R12
   \   0000AE   0124         JEQ     ??initItem_4
    753                {
    754                  rtrn = pg;
   \   0000B0   4B4A         MOV.B   R10, R11
    755                }
    756              }
    757            }
    758          
    759            return rtrn;
   \                     ??initItem_4:
   \   0000B2   4C4B         MOV.B   R11, R12
   \   0000B4   2153         ADD.W   #0x2, SP
   \   0000B6   7417         POPM.W  #0x8, R11
   \   0000B8   1001         RETA
    760          }
    761          
    762          /*********************************************************************
    763           * @fn      setItem
    764           *
    765           * @brief   Set an item Id or status to mark its state.
    766           *
    767           * @param   pg - Valid NV page.
    768           * @param   offset - Valid offset into the page of the item data - the header
    769           *                   offset is calculated from this.
    770           * @param   stat - Valid enum value for the item status.
    771           *
    772           * @return  none
    773           */

   \                                 In  segment CODE, align 2, keep-with-next
    774          static void setItem( uint8 pg, uint16 offset, eNvHdrEnum stat )
   \                     setItem:
    775          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   3182         SUB.W   #0x8, SP
   \   000004   4B4C         MOV.B   R12, R11
   \   000006   084D         MOV.W   R13, R8
   \   000008   4A4E         MOV.B   R14, R10
    776            osalNvHdr_t hdr;
    777          
    778            offset -= OSAL_NV_HDR_SIZE;
   \   00000A   3882         SUB.W   #0x8, R8
    779            readHdr( pg, offset, (uint8 *)(&hdr) );
   \   00000C   0941         MOV.W   SP, R9
   \   00000E   0953         ADD.W   #0x0, R9
   \   000010   0E49         MOV.W   R9, R14
   \   000012   0D48         MOV.W   R8, R13
   \   000014   ........     CALLA   #readHdr
    780          
    781            if ( stat == eNvXfer )
   \   000018   0B5B         RLA.W   R11
   \   00001A   0C4B         MOV.W   R11, R12
   \   00001C   ........     CALLA   #??Subroutine2_1
   \                     ??CrossCallReturnLabel_21:
   \   000020   0C58         ADD.W   R8, R12
   \   000022   4A93         CMP.B   #0x0, R10
   \   000024   0B20         JNE     ??setItem_0
    782            {
    783              hdr.stat = OSAL_NV_ACTIVE;
   \   000026   81430600     MOV.W   #0x0, 0x6(SP)
    784              flashWrite(OSAL_NV_PAGE_TO_PTR(pg) + offset + OSAL_NV_HDR_STAT, OSAL_NV_HDR_ITEM,
    785                                                                       (uint8 *)(&(hdr.stat)));
   \   00002A   39500600     ADD.W   #0x6, R9
   \   00002E   0E49         MOV.W   R9, R14
   \   000030   2D43         MOV.W   #0x2, R13
   \   000032   3C500600     ADD.W   #0x6, R12
   \   000036   ........     CALLA   #flashWrite
   \   00003A   0B3C         JMP     ??setItem_1
    786            }
    787            else // if ( stat == eNvZero )
    788            {
    789              uint16 sz = ((hdr.len + (OSAL_NV_WORD_SIZE-1)) / OSAL_NV_WORD_SIZE) * OSAL_NV_WORD_SIZE +
    790                                                                                    OSAL_NV_HDR_SIZE;
   \                     ??setItem_0:
   \   00003C   1A410200     MOV.W   0x2(SP), R10
   \   000040   3A52         ADD.W   #0x8, R10
    791              hdr.id = 0;
   \   000042   81430000     MOV.W   #0x0, 0(SP)
    792              flashWrite(OSAL_NV_PAGE_TO_PTR(pg) + offset, OSAL_NV_HDR_ITEM, (uint8*)(&hdr));
   \   000046   0E49         MOV.W   R9, R14
   \   000048   2D43         MOV.W   #0x2, R13
   \   00004A   ........     CALLA   #flashWrite
    793              pgLost[pg] += sz;
   \   00004E   8B5A....     ADD.W   R10, pgLost(R11)
    794            }
    795          }
   \                     ??setItem_1:
   \   000052                REQUIRE ?Subroutine0
   \   000052                // Fall through to label ?Subroutine0
    796          
    797          /*********************************************************************
    798           * @fn      calcChkB
    799           *
    800           * @brief   Calculates the data checksum over the 'buf' parameter.
    801           *
    802           * @param   len - Byte count of the data to be checksummed.
    803           * @param   buf - Data buffer to be checksummed.
    804           *
    805           * @return  Calculated checksum of the data bytes.
    806           */
    807          static uint16 calcChkB( uint16 len, uint8 *buf )
    808          {
    809            uint8 fill = len % OSAL_NV_WORD_SIZE;
    810            uint16 chk;
    811          
    812            if ( !buf )
    813            {
    814              chk = len * OSAL_NV_ERASED;
    815            }
    816            else
    817            {
    818              chk = 0;
    819              while ( len-- )
    820              {
    821                chk += *buf++;
    822              }
    823            }
    824          
    825            // calcChkF() will calculate over OSAL_NV_WORD_SIZE alignment.
    826            if ( fill )
    827            {
    828              chk += (OSAL_NV_WORD_SIZE - fill) * OSAL_NV_ERASED;
    829            }
    830          
    831            return chk;
    832          }
    833          
    834          /*********************************************************************
    835           * @fn      calcChkF
    836           *
    837           * @brief   Calculates the data checksum by reading the data bytes from NV.
    838           *
    839           * @param   pg - A valid NV Flash page.
    840           * @param   offset - A valid offset into the page.
    841           * @param   len - Byte count of the data to be checksummed.
    842           *
    843           * @return  Calculated checksum of the data bytes.
    844           */

   \                                 In  segment CODE, align 2, keep-with-next
    845          static uint16 calcChkF( uint8 pg, uint16 offset, uint16 len )
   \                     calcChkF:
    846          {
    847            uint8 *addr = OSAL_NV_PAGE_TO_PTR( pg ) + offset;
   \   000000   4F4C         MOV.B   R12, R15
   \   000002   0F5F         RLA.W   R15
   \   000004   3F506500     ADD.W   #0x65, R15
   \   000008                RPT     #0x9
   \   000008   48180F5F     RLAX.W  R15
   \   00000C   0F5D         ADD.W   R13, R15
    848            uint16 chk = 0;
   \   00000E   0C43         MOV.W   #0x0, R12
    849          
    850            len = (len + (OSAL_NV_WORD_SIZE-1)) / OSAL_NV_WORD_SIZE;
   \   000010   023C         JMP     ??calcChkF_1
    851          
    852            while ( len-- )
    853            {
    854              chk += *addr++;
   \                     ??calcChkF_0:
   \   000012   7D4F         MOV.B   @R15+, R13
   \   000014   0C5D         ADD.W   R13, R12
    855            }
   \                     ??calcChkF_1:
   \   000016   0D4E         MOV.W   R14, R13
   \   000018   3E53         ADD.W   #0xffff, R14
   \   00001A   0D93         CMP.W   #0x0, R13
   \   00001C   FA23         JNE     ??calcChkF_0
    856          
    857            return chk;
   \   00001E   1001         RETA
    858          }
    859          
    860          /*********************************************************************
    861           * @fn      readHdr
    862           *
    863           * @brief   Reads "sizeof( osalNvHdr_t )" bytes from NV.
    864           *
    865           * @param   pg - Valid NV page.
    866           * @param   offset - Valid offset into the page.
    867           * @param   buf - Valid buffer space of at least sizeof( osalNvHdr_t ) bytes.
    868           *
    869           * @return  none
    870           */

   \                                 In  segment CODE, align 2
    871          static void readHdr( uint8 pg, uint16 offset, uint8 *buf )
   \                     readHdr:
    872          {
    873            uint8 *addr = OSAL_NV_PAGE_TO_PTR( pg ) + offset;
   \   000000   ........     CALLA   #?Subroutine2
   \                     ??CrossCallReturnLabel_25:
   \   000004   0C5D         ADD.W   R13, R12
    874            uint8 len = OSAL_NV_HDR_SIZE;
   \   000006   7F42         MOV.B   #0x8, R15
    875          
    876            do
    877            {
    878              *buf++ = *addr++;
   \                     ??readHdr_0:
   \   000008   FE4C0000     MOV.B   @R12+, 0(R14)
   \   00000C   1E53         ADD.W   #0x1, R14
    879            } while ( --len );
   \   00000E   7F53         ADD.B   #0xff, R15
   \   000010   FB23         JNE     ??readHdr_0
    880          }
   \   000012   1001         RETA
    881          
    882          /*********************************************************************
    883           * @fn      writeBuf
    884           *
    885           * @brief   Writes a data buffer to NV.
    886           *
    887           * @param   dstPg - A valid NV Flash page.
    888           * @param   offset - A valid offset into the page.
    889           * @param   len  - Byte count of the data to write.
    890           * @param   buf  - The data to write.
    891           *
    892           * @return  TRUE if data buf checksum matches read back checksum, else FALSE.
    893           */
    894          static void writeBuf( uint8 dstPg, uint16 dstOff, uint16 len, uint8 *buf )
    895          {
    896            uint8 *addr;
    897            uint8 idx, rem, tmp[OSAL_NV_WORD_SIZE];
    898          
    899            rem = dstOff % OSAL_NV_WORD_SIZE;
    900            if ( rem )
    901            {
    902              dstOff -= rem;
    903              addr = OSAL_NV_PAGE_TO_PTR( dstPg ) + dstOff;
    904          
    905              for ( idx = 0; idx < rem; idx++ )
    906              {
    907                tmp[idx] = *addr++;
    908              }
    909          
    910              while ( (idx < OSAL_NV_WORD_SIZE) && len )
    911              {
    912                tmp[idx++] = *buf++;
    913                len--;
    914              }
    915          
    916              while ( idx < OSAL_NV_WORD_SIZE )
    917              {
    918                tmp[idx++] = OSAL_NV_ERASED;
    919              }
    920          
    921              flashWrite(OSAL_NV_PAGE_TO_PTR(dstPg) + dstOff, OSAL_NV_WORD_SIZE, tmp);
    922              dstOff += OSAL_NV_WORD_SIZE;
    923            }
    924          
    925            rem = len % OSAL_NV_WORD_SIZE;
    926            len = (len / OSAL_NV_WORD_SIZE) * OSAL_NV_WORD_SIZE;
    927            flashWrite(OSAL_NV_PAGE_TO_PTR(dstPg) + dstOff, len, buf);
    928          
    929            if ( rem )
    930            {
    931              dstOff += len;
    932              buf += len;
    933          
    934              for ( idx = 0; idx < rem; idx++ )
    935              {
    936                tmp[idx] = *buf++;
    937              }
    938          
    939              while ( idx < OSAL_NV_WORD_SIZE )
    940              {
    941                tmp[idx++] = OSAL_NV_ERASED;
    942              }
    943          
    944              flashWrite(OSAL_NV_PAGE_TO_PTR(dstPg) + dstOff, OSAL_NV_WORD_SIZE, tmp);
    945            }
    946          }
    947          
    948          /*********************************************************************
    949           * @fn      xferBuf
    950           *
    951           * @brief   Xfers an NV buffer from one location to another, enforcing OSAL_NV_WORD_SIZE writes.
    952           *
    953           * @return  none
    954           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ??Subroutine15_0:
   \   000000   0E5E         RLA.W   R14
   \   000002   3E506500     ADD.W   #0x65, R14
   \   000006                RPT     #0x9
   \   000006   48180E5E     RLAX.W  R14
   \   00000A   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
    955          static void xferBuf( uint8 srcPg, uint16 srcOff, uint8 dstPg, uint16 dstOff, uint16 len )
   \                     xferBuf:
    956          {
   \   000000   1B15         PUSHM.W #0x2, R11
   \   000002   4A4C         MOV.B   R12, R10
   \   000004   4C4E         MOV.B   R14, R12
   \   000006   1B410800     MOV.W   0x8(SP), R11
    957            uint8 *addr;
    958            uint8 idx, rem, tmp[OSAL_NV_WORD_SIZE];
    959          
    960            rem = dstOff % OSAL_NV_WORD_SIZE;
    961            if ( rem )
    962            {
    963              dstOff -= rem;
    964              addr = OSAL_NV_PAGE_TO_PTR( dstPg ) + dstOff;
    965          
    966              for ( idx = 0; idx < rem; idx++ )
    967              {
    968                tmp[idx] = *addr++;
    969              }
    970          
    971              addr = OSAL_NV_PAGE_TO_PTR( srcPg ) + srcOff;
    972          
    973              while ( (idx < OSAL_NV_WORD_SIZE) && len )
    974              {
    975                tmp[idx++] = *addr++;
    976                srcOff++;
    977                len--;
    978              }
    979          
    980              while ( idx < OSAL_NV_WORD_SIZE )
    981              {
    982                tmp[idx++] = OSAL_NV_ERASED;
    983              }
    984          
    985              flashWrite(OSAL_NV_PAGE_TO_PTR(dstPg) + dstOff, OSAL_NV_WORD_SIZE, tmp);
    986              dstOff += OSAL_NV_WORD_SIZE;
    987            }
    988          
    989            rem = len % OSAL_NV_WORD_SIZE;
    990            len = (len / OSAL_NV_WORD_SIZE) * OSAL_NV_WORD_SIZE;
    991            addr = OSAL_NV_PAGE_TO_PTR( srcPg ) + srcOff;
    992            flashWrite(OSAL_NV_PAGE_TO_PTR(dstPg) + dstOff, len, addr);
   \   00000A   4E4A         MOV.B   R10, R14
   \   00000C   ........     CALLA   #??Subroutine15_0
   \                     ??CrossCallReturnLabel_18:
   \   000010   0E5D         ADD.W   R13, R14
   \   000012   0D4B         MOV.W   R11, R13
   \   000014   ........     CALLA   #??Subroutine2_0
   \                     ??CrossCallReturnLabel_23:
   \   000018   0C5F         ADD.W   R15, R12
   \   00001A   ........     CALLA   #flashWrite
    993          
    994            if ( rem )
    995            {
    996              dstOff += len;
    997              addr += len;
    998          
    999              for ( idx = 0; idx < rem; idx++ )
   1000              {
   1001                tmp[idx] = *addr++;
   1002              }
   1003          
   1004              while ( idx < OSAL_NV_WORD_SIZE )
   1005              {
   1006                tmp[idx++] = OSAL_NV_ERASED;
   1007              }
   1008          
   1009              flashWrite(OSAL_NV_PAGE_TO_PTR(dstPg) + dstOff, OSAL_NV_WORD_SIZE, tmp);
   1010            }
   1011          }
   \   00001E   1A17         POPM.W  #0x2, R11
   \   000020   1001         RETA
   1012          
   1013          /*********************************************************************
   1014           * @fn      writeItem
   1015           *
   1016           * @brief   Writes an item header/data combo to the specified NV page.
   1017           *
   1018           * @param   pg - Valid NV Flash page.
   1019           * @param   id - Valid NV item Id.
   1020           * @param   len  - Byte count of the data to write.
   1021           * @param   buf  - The data to write. If NULL, no data/checksum write.
   1022           * @param   flag - TRUE if the checksum should be written, FALSE otherwise.
   1023           *
   1024           * @return  TRUE if header/data to write matches header/data read back, else FALSE.
   1025           */

   \                                 In  segment CODE, align 2, keep-with-next
   1026          static uint8 writeItem( uint8 pg, uint16 id, uint16 len, void *buf, uint8 flag )
   \                     writeItem:
   1027          {
   \   000000   7B15         PUSHM.W #0x8, R11
   \   000002   0D12         PUSH.W  R13
   \   000004   31800A00     SUB.W   #0xa, SP
   \   000008   4A4C         MOV.B   R12, R10
   \   00000A   0B4E         MOV.W   R14, R11
   \   00000C   054F         MOV.W   R15, R5
   1028            uint16 offset = pgOff[pg];
   \   00000E   484C         MOV.B   R12, R8
   \   000010   0858         RLA.W   R8
   \   000012   1948....     MOV.W   pgOff(R8), R9
   1029            uint8 rtrn = FALSE;
   \   000016   4643         MOV.B   #0x0, R6
   1030            osalNvHdr_t hdr;
   1031          
   1032            hdr.id = id;
   \   000018   91410A000200 MOV.W   0xa(SP), 0x2(SP)
   1033            hdr.len = len;
   \   00001E   814E0400     MOV.W   R14, 0x4(SP)
   1034          
   1035            flashWrite(OSAL_NV_PAGE_TO_PTR(pg) + offset, OSAL_NV_HDR_HALF, (uint8 *)(&hdr));
   \   000022   0748         MOV.W   R8, R7
   \   000024   37506500     ADD.W   #0x65, R7
   \   000028                RPT     #0x9
   \   000028   48180757     RLAX.W  R7
   \   00002C   0441         MOV.W   SP, R4
   \   00002E   2453         ADD.W   #0x2, R4
   \   000030   0E44         MOV.W   R4, R14
   \   000032   2D42         MOV.W   #0x4, R13
   \   000034   0C47         MOV.W   R7, R12
   \   000036   0C59         ADD.W   R9, R12
   \   000038   ........     CALLA   #flashWrite
   1036            readHdr( pg, offset, (uint8 *)(&hdr) );
   \   00003C   0E44         MOV.W   R4, R14
   \   00003E   ........     CALLA   #??Subroutine12_0
   1037          
   1038            if ( (hdr.id == id) && (hdr.len == len) )
   \                     ??CrossCallReturnLabel_13:
   \   000042   1F410400     MOV.W   0x4(SP), R15
   \   000046   91910A000200 CMP.W   0xa(SP), 0x2(SP)
   \   00004C   4B20         JNE     ??writeItem_2
   \   00004E   0F9B         CMP.W   R11, R15
   \   000050   4920         JNE     ??writeItem_2
   1039            {
   1040              if ( flag )
   \   000052   C1932000     CMP.B   #0x0, 0x20(SP)
   \   000056   4124         JEQ     ??writeItem_1
   1041              {
   1042                uint16 chk = calcChkB( len, buf );
   \   000058   0F45         MOV.W   R5, R15
   \   00005A   0D4B         MOV.W   R11, R13
   \   00005C   0593         CMP.W   #0x0, R5
   \   00005E   0C20         JNE     ??writeItem_3
   \   000060   0212         PUSH.W  SR
   \   000062   32C2         DINT
   \   000064   0343         NOP
   \   000066   824BC004     MOV.W   R11, &0x4c0
   \   00006A   B240FF00C804 MOV.W   #0xff, &0x4c8
   \   000070   1C42CA04     MOV.W   &0x4ca, R12
   \   000074   3241         POP.W   SR
   \   000076   083C         JMP     ??writeItem_4
   \                     ??writeItem_3:
   \   000078   0C43         MOV.W   #0x0, R12
   \   00007A   023C         JMP     ??writeItem_5
   \                     ??writeItem_0:
   \   00007C   7E4F         MOV.B   @R15+, R14
   \   00007E   0C5E         ADD.W   R14, R12
   \                     ??writeItem_5:
   \   000080   0E4D         MOV.W   R13, R14
   \   000082   3D53         ADD.W   #0xffff, R13
   \   000084   0E93         CMP.W   #0x0, R14
   \   000086   FA23         JNE     ??writeItem_0
   \                     ??writeItem_4:
   \   000088   814C0000     MOV.W   R12, 0(SP)
   1043          
   1044                offset += OSAL_NV_HDR_SIZE;
   \   00008C   3952         ADD.W   #0x8, R9
   1045                if ( buf != NULL )
   \   00008E   0759         ADD.W   R9, R7
   \   000090   0593         CMP.W   #0x0, R5
   \   000092   0524         JEQ     ??writeItem_6
   1046                {
   1047                  writeBuf( pg, offset, len, buf );
   \   000094   0E45         MOV.W   R5, R14
   \   000096   0D4B         MOV.W   R11, R13
   \   000098   0C47         MOV.W   R7, R12
   \   00009A   ........     CALLA   #flashWrite
   1048                }
   1049          
   1050                if ( chk == calcChkF( pg, offset, len ) )
   \                     ??writeItem_6:
   \   00009E   0E4B         MOV.W   R11, R14
   \   0000A0   0D49         MOV.W   R9, R13
   \   0000A2   4C4A         MOV.B   R10, R12
   \   0000A4   ........     CALLA   #calcChkF
   \   0000A8   819C0000     CMP.W   R12, 0(SP)
   \   0000AC   1720         JNE     ??writeItem_7
   1051                {
   1052                  flashWrite(OSAL_NV_PAGE_TO_PTR(pg) + offset - OSAL_NV_HDR_HALF, OSAL_NV_HDR_ITEM,
   1053                                                                                  (uint8 *)(&chk));
   \   0000AE   0E41         MOV.W   SP, R14
   \   0000B0   0E53         ADD.W   #0x0, R14
   \   0000B2   2D43         MOV.W   #0x2, R13
   \   0000B4   2782         SUB.W   #0x4, R7
   \   0000B6   0C47         MOV.W   R7, R12
   \   0000B8   ........     CALLA   #flashWrite
   1054                  readHdr( pg, (offset-OSAL_NV_HDR_SIZE), (uint8 *)(&hdr) );
   \   0000BC   0E44         MOV.W   R4, R14
   \   0000BE   0D49         MOV.W   R9, R13
   \   0000C0   3D82         SUB.W   #0x8, R13
   \   0000C2   ........     CALLA   #??Subroutine4_0
   1055          
   1056                  if ( chk == hdr.chk )
   \                     ??CrossCallReturnLabel_12:
   \   0000C6   919106000000 CMP.W   0x6(SP), 0(SP)
   \   0000CC   0720         JNE     ??writeItem_7
   1057                  {
   1058                    hotItemUpdate(pg, offset, hdr.id);
   \   0000CE   1E410200     MOV.W   0x2(SP), R14
   \   0000D2   0D49         MOV.W   R9, R13
   \   0000D4   4C4A         MOV.B   R10, R12
   \   0000D6   ........     CALLA   #hotItemUpdate
   1059                    rtrn = TRUE;
   1060                  }
   1061                }
   1062              }
   1063              else
   1064              {
   1065                rtrn = TRUE;
   \                     ??writeItem_1:
   \   0000DA   5643         MOV.B   #0x1, R6
   1066              }
   1067          
   1068              len = OSAL_NV_ITEM_SIZE( hdr.len );
   \                     ??writeItem_7:
   \   0000DC   1B410400     MOV.W   0x4(SP), R11
   \   0000E0   3B52         ADD.W   #0x8, R11
   \   0000E2   0B3C         JMP     ??writeItem_8
   1069            }
   1070            else
   1071            {
   1072              len = OSAL_NV_ITEM_SIZE( hdr.len );
   \                     ??writeItem_2:
   \   0000E4   0B4F         MOV.W   R15, R11
   \   0000E6   3B52         ADD.W   #0x8, R11
   1073          
   1074              if (len > (OSAL_NV_PAGE_SIZE - pgOff[pg]))
   \   0000E8   3F400004     MOV.W   #0x400, R15
   \   0000EC   1F88....     SUB.W   pgOff(R8), R15
   \   0000F0   0F9B         CMP.W   R11, R15
   \   0000F2   012C         JC      ??writeItem_9
   1075              {
   1076                len = (OSAL_NV_PAGE_SIZE - pgOff[pg]);
   \   0000F4   0B4F         MOV.W   R15, R11
   1077              }
   1078          
   1079              pgLost[pg] += len;
   \                     ??writeItem_9:
   \   0000F6   885B....     ADD.W   R11, pgLost(R8)
   1080            }
   1081            pgOff[pg] += len;
   \                     ??writeItem_8:
   \   0000FA   885B....     ADD.W   R11, pgOff(R8)
   1082          
   1083            return rtrn;
   \   0000FE   4C46         MOV.B   R6, R12
   \   000100   31500C00     ADD.W   #0xc, SP
   \   000104   7417         POPM.W  #0x8, R11
   \   000106   1001         RETA
   1084          }
   1085          
   1086          /*********************************************************************
   1087           * @fn      hotItem
   1088           *
   1089           * @brief   Look for the parameter 'id' in the hot items array.
   1090           *
   1091           * @param   id - A valid NV item Id.
   1092           *
   1093           * @return  A valid index into the hot items if the item is hot; OSAL_NV_MAX_HOT if not.
   1094           */

   \                                 In  segment CODE, align 2, keep-with-next
   1095          static uint8 hotItem(uint16 id)
   \                     hotItem:
   1096          {
   1097            uint8 hotIdx;
   1098          
   1099            for (hotIdx = 0; hotIdx < OSAL_NV_MAX_HOT; hotIdx++)
   \   000000   4E43         MOV.B   #0x0, R14
   1100            {
   1101              if (hotIds[hotIdx] == id)
   \                     ??hotItem_0:
   \   000002   4F4E         MOV.B   R14, R15
   \   000004   0F5F         RLA.W   R15
   \   000006   8F9C....     CMP.W   R12, hotIds(R15)
   \   00000A   0424         JEQ     ??hotItem_1
   1102              {
   1103                break;
   1104              }
   1105            }
   \   00000C   5E53         ADD.B   #0x1, R14
   \   00000E   7E900300     CMP.B   #0x3, R14
   \   000012   F72B         JNC     ??hotItem_0
   1106          
   1107            return hotIdx;
   \                     ??hotItem_1:
   \   000014   4C4E         MOV.B   R14, R12
   \   000016   1001         RETA
   1108          }
   1109          
   1110          /*********************************************************************
   1111           * @fn      hotItemUpdate
   1112           *
   1113           * @brief   If the parameter 'id' is a hot item, update the corresponding hot item data.
   1114           *
   1115           * @param   pg - The new NV page corresponding to the hot item.
   1116           * @param   off - The new NV page offset corresponding to the hot item.
   1117           * @param   id - A valid NV item Id.
   1118           *
   1119           * @return  none
   1120           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine9:
   \   000000   ........     CALLA   #hotItem
   \   000004   7C900300     CMP.B   #0x3, R12
   \   000008   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   1121          static void hotItemUpdate(uint8 pg, uint16 off, uint16 id)
   \                     hotItemUpdate:
   1122          {
   \   000000   0A12         PUSH.W  R10
   \   000002   4A4C         MOV.B   R12, R10
   1123            uint8 hotIdx = hotItem(id);
   \   000004   0C4E         MOV.W   R14, R12
   \   000006   ........     CALLA   #?Subroutine9
   1124          
   1125            if (hotIdx < OSAL_NV_MAX_HOT)
   \                     ??CrossCallReturnLabel_9:
   \   00000A   062C         JC      ??hotItemUpdate_0
   1126            {
   1127              {
   1128                hotPg[hotIdx] = pg;
   \   00000C   4C4C         MOV.B   R12, R12
   \   00000E   CC4A....     MOV.B   R10, hotPg(R12)
   1129                hotOff[hotIdx] = off;
   \   000012   0C5C         RLA.W   R12
   \   000014   8C4D....     MOV.W   R13, hotOff(R12)
   1130              }
   1131            }
   1132          }
   \                     ??hotItemUpdate_0:
   \   000018   3A41         POP.W   R10
   \   00001A   1001         RETA
   1133          
   1134          /*********************************************************************
   1135           * @fn      osal_nv_init
   1136           *
   1137           * @brief   Initialize NV service.
   1138           *
   1139           * @param   p - Not used.
   1140           *
   1141           * @return  none
   1142           */

   \                                 In  segment CODE, align 2
   1143          void osal_nv_init( void *p )
   \                     osal_nv_init:
   1144          {
   1145            (void)p;  // Suppress Lint warning.
   1146            (void)initNV();  // Always returns TRUE after pages have been erased.
   \   000000   ........     BRA     #initNV
   1147          }
   1148          
   1149          /*********************************************************************
   1150           * @fn      osal_nv_item_init
   1151           *
   1152           * @brief   If the NV item does not already exist, it is created and
   1153           *          initialized with the data passed to the function, if any.
   1154           *          This function must be called before calling osal_nv_read() or
   1155           *          osal_nv_write().
   1156           *
   1157           * @param   id  - Valid NV item Id.
   1158           * @param   len - Item length.
   1159           * @param  *buf - Pointer to item initalization data. Set to NULL if none.
   1160           *
   1161           * @return  NV_ITEM_UNINIT - Id did not exist and was created successfully.
   1162           *          SUCCESS       - Id already existed, no action taken.
   1163           *          NV_OPER_FAILED - Failure to find or create Id.
   1164           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine1:
   \   000000   2153         ADD.W   #0x2, SP
   \   000002   3817         POPM.W  #0x4, R11
   \   000004   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine6:
   \   000000   0D41         MOV.W   SP, R13
   \   000002   2D52         ADD.W   #0x4, R13
   \   000004   0C4A         MOV.W   R10, R12
   \   000006   ........     CALLA   #findItem
   \   00000A   0C93         CMP.W   #0x0, R12
   \   00000C   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   1165          uint8 osal_nv_item_init( uint16 id, uint16 len, void *buf )
   \                     osal_nv_item_init:
   1166          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   2183         SUB.W   #0x2, SP
   \   000004   0A4C         MOV.W   R12, R10
   \   000006   0B4D         MOV.W   R13, R11
   \   000008   084E         MOV.W   R14, R8
   1167            uint8 findPg;
   1168            uint16 offset;
   1169          
   1170            if ( !OSAL_NV_CHECK_BUS_VOLTAGE )
   \   00000A   7C40B300     MOV.B   #0xb3, R12
   \   00000E   ........     CALLA   #HalAdcCheckVdd
   \   000012   4C93         CMP.B   #0x0, R12
   \   000014   1624         JEQ     ??osal_nv_item_init_0
   1171            {
   1172              return NV_OPER_FAILED;
   1173            }
   1174            else if ((offset = findItem(id, &findPg)) != OSAL_NV_ITEM_NULL)
   \   000016   ........     CALLA   #?Subroutine6
   \                     ??CrossCallReturnLabel_4:
   \   00001A   0724         JEQ     ??osal_nv_item_init_1
   1175            {
   1176              // Re-populate the NV hot item data if the corresponding items are already established.
   1177              hotItemUpdate(findPg, offset, id);
   \   00001C   0E4A         MOV.W   R10, R14
   \   00001E   0D4C         MOV.W   R12, R13
   \   000020   6C41         MOV.B   @SP, R12
   \   000022   ........     CALLA   #hotItemUpdate
   1178          
   1179              return SUCCESS;
   \   000026   4C43         MOV.B   #0x0, R12
   \   000028   0E3C         JMP     ??osal_nv_item_init_2
   1180            }
   1181            else if ( initItem( TRUE, id, len, buf ) != OSAL_NV_PAGE_NULL )
   \                     ??osal_nv_item_init_1:
   \   00002A   0F48         MOV.W   R8, R15
   \   00002C   0E4B         MOV.W   R11, R14
   \   00002E   0D4A         MOV.W   R10, R13
   \   000030   5C43         MOV.B   #0x1, R12
   \   000032   ........     CALLA   #initItem
   \   000036   7C900C00     CMP.B   #0xc, R12
   \   00003A   0324         JEQ     ??osal_nv_item_init_0
   1182            {
   1183              return NV_ITEM_UNINIT;
   \   00003C   7C400900     MOV.B   #0x9, R12
   \   000040   023C         JMP     ??osal_nv_item_init_2
   1184            }
   1185            else
   1186            {
   1187              return NV_OPER_FAILED;
   \                     ??osal_nv_item_init_0:
   \   000042   7C400A00     MOV.B   #0xa, R12
   1188            }
   \                     ??osal_nv_item_init_2:
   \   000046   ........     BRA     #?Subroutine1
   1189          }
   1190          
   1191          /*********************************************************************
   1192           * @fn      osal_nv_item_len
   1193           *
   1194           * @brief   Get the data length of the item stored in NV memory.
   1195           *
   1196           * @param   id  - Valid NV item Id.
   1197           *
   1198           * @return  Item length, if found; zero otherwise.
   1199           */

   \                                 In  segment CODE, align 2, keep-with-next
   1200          uint16 osal_nv_item_len( uint16 id )
   \                     osal_nv_item_len:
   1201          {
   \   000000   0A12         PUSH.W  R10
   \   000002   31800A00     SUB.W   #0xa, SP
   \   000006   0A4C         MOV.W   R12, R10
   1202            uint8 findPg;
   1203            osalNvHdr_t hdr;
   1204            uint16 offset;
   1205            uint8 hotIdx;
   1206          
   1207            if ((hotIdx = hotItem(id)) < OSAL_NV_MAX_HOT)
   \   000008   ........     CALLA   #?Subroutine9
   \                     ??CrossCallReturnLabel_7:
   \   00000C   0F2C         JC      ??osal_nv_item_len_2
   1208            {
   1209              findPg = hotPg[hotIdx];
   \   00000E   ........     CALLA   #?Subroutine3
   1210              offset = hotOff[hotIdx];
   1211            }
   1212            else if ((offset = findItem(id, &findPg)) == OSAL_NV_ITEM_NULL)
   1213            {
   1214              return 0;
   1215            }
   1216          
   1217            readHdr( findPg, (offset - OSAL_NV_HDR_SIZE), (uint8 *)(&hdr) );
   \                     ??osal_nv_item_len_0:
   \   000012   0E41         MOV.W   SP, R14
   \   000014   2E53         ADD.W   #0x2, R14
   \   000016   3C82         SUB.W   #0x8, R12
   \   000018   0D4C         MOV.W   R12, R13
   \   00001A   6C41         MOV.B   @SP, R12
   \   00001C   ........     CALLA   #readHdr
   1218            return hdr.len;
   \   000020   1C410400     MOV.W   0x4(SP), R12
   \                     ??osal_nv_item_len_1:
   \   000024   31500A00     ADD.W   #0xa, SP
   \   000028   3A41         POP.W   R10
   \   00002A   1001         RETA
   \                     ??osal_nv_item_len_2:
   \   00002C   ........     CALLA   #?Subroutine6
   \                     ??CrossCallReturnLabel_2:
   \   000030   F023         JNE     ??osal_nv_item_len_0
   \   000032   0C43         MOV.W   #0x0, R12
   \   000034   F73F         JMP     ??osal_nv_item_len_1
   \   000036   0343         NOP
   1219          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine3:
   \   000000   4C4C         MOV.B   R12, R12
   \   000002   D14C....0400 MOV.B   hotPg(R12), 0x4(SP)
   \   000008   0C5C         RLA.W   R12
   \   00000A   1C4C....     MOV.W   hotOff(R12), R12
   \   00000E   1001         RETA
   1220          
   1221          /*********************************************************************
   1222           * @fn      osal_nv_write
   1223           *
   1224           * @brief   Write a data item to NV. Function can write an entire item to NV or
   1225           *          an element of an item by indexing into the item with an offset.
   1226           *
   1227           * @param   id  - Valid NV item Id.
   1228           * @param   ndx - Index offset into item
   1229           * @param   len - Length of data to write.
   1230           * @param  *buf - Data to write.
   1231           *
   1232           * @return  SUCCESS if successful, NV_ITEM_UNINIT if item did not
   1233           *          exist in NV and offset is non-zero, NV_OPER_FAILED if failure.
   1234           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine8:
   \   000000   0D4B         MOV.W   R11, R13
   \   000002                REQUIRE ??Subroutine8_0
   \   000002                // Fall through to label ??Subroutine8_0

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine10:
   \   000000   5E410400     MOV.B   0x4(SP), R14
   \   000004                REQUIRE ??Subroutine15_0
   \   000004                // Fall through to label ??Subroutine15_0

   \                                 In  segment CODE, align 2, keep-with-next
   1235          uint8 osal_nv_write( uint16 id, uint16 ndx, uint16 len, void *buf )
   \                     osal_nv_write:
   1236          {
   \   000000   7B15         PUSHM.W #0x8, R11
   \   000002   0F12         PUSH.W  R15
   \   000004   31800E00     SUB.W   #0xe, SP
   \   000008   074C         MOV.W   R12, R7
   \   00000A   084D         MOV.W   R13, R8
   \   00000C   094E         MOV.W   R14, R9
   1237            uint8 rtrn = SUCCESS;
   \   00000E   C1430400     MOV.B   #0x0, 0x4(SP)
   \   000012   7C40B300     MOV.B   #0xb3, R12
   1238          
   1239            if ( !OSAL_NV_CHECK_BUS_VOLTAGE )
   \   000016   ........     CALLA   #HalAdcCheckVdd
   \   00001A   4C93         CMP.B   #0x0, R12
   \   00001C   1A24         JEQ     ??osal_nv_write_1
   1240            {
   1241              return NV_OPER_FAILED;
   1242            }
   1243            else if ( len != 0 )
   \   00001E   0993         CMP.W   #0x0, R9
   \   000020   CC24         JEQ     ??osal_nv_write_2
   1244            {
   1245              osalNvHdr_t hdr;
   1246              uint16 origOff, srcOff;
   1247              uint16 cnt, chk;
   1248              uint8 *addr, *ptr, srcPg;
   1249          
   1250              origOff = srcOff = findItem( id, &srcPg );
   \   000022   0D41         MOV.W   SP, R13
   \   000024   0D53         ADD.W   #0x0, R13
   \   000026   0C47         MOV.W   R7, R12
   \   000028   ........     CALLA   #findItem
   \   00002C   0B4C         MOV.W   R12, R11
   1251              if ( srcOff == OSAL_NV_ITEM_NULL )
   \   00002E   0C93         CMP.W   #0x0, R12
   \   000030   0320         JNE     ??osal_nv_write_3
   1252              {
   1253                return NV_ITEM_UNINIT;
   \   000032   7C400900     MOV.B   #0x9, R12
   \   000036   C33C         JMP     ??osal_nv_write_4
   1254              }
   1255          
   1256              readHdr( srcPg, (srcOff - OSAL_NV_HDR_SIZE), (uint8 *)(&hdr) );
   \                     ??osal_nv_write_3:
   \   000038   0E41         MOV.W   SP, R14
   \   00003A   3E500600     ADD.W   #0x6, R14
   \   00003E   0D4C         MOV.W   R12, R13
   \   000040   3D82         SUB.W   #0x8, R13
   \   000042   6C41         MOV.B   @SP, R12
   \   000044   ........     CALLA   #readHdr
   1257              if ( hdr.len < (ndx + len) )
   \   000048   0F48         MOV.W   R8, R15
   \   00004A   0F59         ADD.W   R9, R15
   \   00004C   819F0800     CMP.W   R15, 0x8(SP)
   \   000050   032C         JC      ??osal_nv_write_5
   1258              {
   1259                return NV_OPER_FAILED;
   \                     ??osal_nv_write_1:
   \   000052   7C400A00     MOV.B   #0xa, R12
   \   000056   B33C         JMP     ??osal_nv_write_4
   1260              }
   \                     ??osal_nv_write_5:
   \   000058   ........     CALLA   #?Subroutine10
   \                     ??CrossCallReturnLabel_20:
   \   00005C   0E5B         ADD.W   R11, R14
   \   00005E   0E58         ADD.W   R8, R14
   1261          
   1262              addr = OSAL_NV_PAGE_TO_PTR( srcPg ) + srcOff + ndx;
   1263              ptr = buf;
   \   000060   1D410E00     MOV.W   0xe(SP), R13
   1264              cnt = len;
   \   000064   0A49         MOV.W   R9, R10
   1265              chk = 0;
   \   000066   0543         MOV.W   #0x0, R5
   \   000068   0B3C         JMP     ??osal_nv_write_6
   1266              while ( cnt-- )
   1267              {
   1268                if ( *addr != *ptr )
   \                     ??osal_nv_write_0:
   \   00006A   6F4E         MOV.B   @R14, R15
   \   00006C   6F9D         CMP.B   @R13, R15
   \   00006E   0624         JEQ     ??osal_nv_write_7
   1269                {
   1270                  chk = 1;  // Mark that at least one byte is different.
   \   000070   1543         MOV.W   #0x1, R5
   1271                  // Calculate expected checksum after transferring old data and writing new data.
   1272                  hdr.chk -= *addr;
   \   000072   818F0A00     SUB.W   R15, 0xa(SP)
   1273                  hdr.chk += *ptr;
   \   000076   6F4D         MOV.B   @R13, R15
   \   000078   815F0A00     ADD.W   R15, 0xa(SP)
   1274                }
   1275                addr++;
   \                     ??osal_nv_write_7:
   \   00007C   1E53         ADD.W   #0x1, R14
   1276                ptr++;
   \   00007E   1D53         ADD.W   #0x1, R13
   1277              }
   \                     ??osal_nv_write_6:
   \   000080   0F4A         MOV.W   R10, R15
   \   000082   3A53         ADD.W   #0xffff, R10
   \   000084   0F93         CMP.W   #0x0, R15
   \   000086   F123         JNE     ??osal_nv_write_0
   1278          
   1279              if ( chk != 0 )  // If the buffer to write is different in one or more bytes.
   \   000088   15B3         BIT.W   #0x1, R5
   \   00008A   9728         JNC     ??osal_nv_write_2
   1280              {
   1281                uint8 comPg = OSAL_NV_PAGE_NULL;
   \   00008C   F1400C000100 MOV.B   #0xc, 0x1(SP)
   1282                uint8 dstPg = initItem( FALSE, id, hdr.len, &comPg );
   \   000092   0F41         MOV.W   SP, R15
   \   000094   1F53         ADD.W   #0x1, R15
   \   000096   1E410800     MOV.W   0x8(SP), R14
   \   00009A   0D47         MOV.W   R7, R13
   \   00009C   4C43         MOV.B   #0x0, R12
   \   00009E   ........     CALLA   #initItem
   \   0000A2   4A4C         MOV.B   R12, R10
   1283          
   1284                if ( dstPg != OSAL_NV_PAGE_NULL )
   \   0000A4   7C900C00     CMP.B   #0xc, R12
   \   0000A8   5D24         JEQ     ??osal_nv_write_8
   1285                {
   1286                  uint16 tmp = OSAL_NV_DATA_SIZE( hdr.len );
   \   0000AA   914108000200 MOV.W   0x8(SP), 0x2(SP)
   1287                  uint16 dstOff = pgOff[dstPg] - tmp;
   \   0000B0   464C         MOV.B   R12, R6
   \   0000B2   0656         RLA.W   R6
   \   0000B4   1746....     MOV.W   pgOff(R6), R7
   \   0000B8   17810200     SUB.W   0x2(SP), R7
   1288                  srcOff = origOff;
   1289                  chk = hdr.chk;
   \   0000BC   15410A00     MOV.W   0xa(SP), R5
   1290          
   1291                  /* Prevent excessive re-writes to item header caused by numerous, rapid, & successive
   1292                   * OSAL_Nv interruptions caused by resets.
   1293                   */
   1294                  if ( hdr.stat == OSAL_NV_ERASED_ID )
   \   0000C0   B1930C00     CMP.W   #0xffff, 0xc(SP)
   \   0000C4   0320         JNE     ??osal_nv_write_9
   1295                  {
   1296                    setItem( srcPg, srcOff, eNvXfer );
   \   0000C6   4E43         MOV.B   #0x0, R14
   \   0000C8   ........     CALLA   #?Subroutine8
   1297                  }
   1298          
   1299                  xferBuf( srcPg, srcOff, dstPg, dstOff, ndx );
   \                     ??osal_nv_write_9:
   \   0000CC   0812         PUSH.W  R8
   \   0000CE   0F47         MOV.W   R7, R15
   \   0000D0   4E4A         MOV.B   R10, R14
   \   0000D2   0D4B         MOV.W   R11, R13
   \   0000D4   5C410200     MOV.B   0x2(SP), R12
   \   0000D8   ........     CALLA   #xferBuf
   1300                  srcOff += ndx;
   1301                  dstOff += ndx;
   \   0000DC   0758         ADD.W   R8, R7
   1302          
   1303                  writeBuf( dstPg, dstOff, len, buf );
   \   0000DE   0446         MOV.W   R6, R4
   \   0000E0   34506500     ADD.W   #0x65, R4
   \   0000E4                RPT     #0x9
   \   0000E4   48180454     RLAX.W  R4
   \   0000E8   1E411000     MOV.W   0x10(SP), R14
   \   0000EC   0D49         MOV.W   R9, R13
   \   0000EE   0C44         MOV.W   R4, R12
   \   0000F0   0C57         ADD.W   R7, R12
   \   0000F2   ........     CALLA   #flashWrite
   1304                  srcOff += len;
   1305                  dstOff += len;
   1306          
   1307                  xferBuf( srcPg, srcOff, dstPg, dstOff, (hdr.len-ndx-len) );
   \   0000F6   1F410A00     MOV.W   0xa(SP), R15
   \   0000FA   0F88         SUB.W   R8, R15
   \   0000FC   0F89         SUB.W   R9, R15
   \   0000FE   0F12         PUSH.W  R15
   \   000100   0759         ADD.W   R9, R7
   \   000102   0F47         MOV.W   R7, R15
   \   000104   4E4A         MOV.B   R10, R14
   \   000106   0D4B         MOV.W   R11, R13
   \   000108   0D58         ADD.W   R8, R13
   \   00010A   0D59         ADD.W   R9, R13
   \   00010C   5C410400     MOV.B   0x4(SP), R12
   \   000110   ........     CALLA   #xferBuf
   1308          
   1309                  // Calculate and write the new checksum.
   1310                  dstOff = pgOff[dstPg] - tmp;
   \   000114   1746....     MOV.W   pgOff(R6), R7
   \   000118   17810600     SUB.W   0x6(SP), R7
   1311                  tmp = calcChkF( dstPg, dstOff, hdr.len );
   \   00011C   1E410C00     MOV.W   0xc(SP), R14
   \   000120   0D47         MOV.W   R7, R13
   \   000122   4C4A         MOV.B   R10, R12
   \   000124   ........     CALLA   #calcChkF
   \   000128   814C0600     MOV.W   R12, 0x6(SP)
   1312                  dstOff -= OSAL_NV_HDR_SIZE;
   \   00012C   3782         SUB.W   #0x8, R7
   1313                  flashWrite(OSAL_NV_PAGE_TO_PTR(dstPg) + dstOff + OSAL_NV_HDR_CHK, OSAL_NV_HDR_ITEM,
   1314                                                                                    (uint8 *)(&tmp));
   \   00012E   0E41         MOV.W   SP, R14
   \   000130   3E500600     ADD.W   #0x6, R14
   \   000134   2D43         MOV.W   #0x2, R13
   \   000136   0457         ADD.W   R7, R4
   \   000138   2452         ADD.W   #0x4, R4
   \   00013A   0C44         MOV.W   R4, R12
   \   00013C   ........     CALLA   #flashWrite
   1315                  readHdr( dstPg, dstOff, (uint8 *)(&hdr) );
   \   000140   0E41         MOV.W   SP, R14
   \   000142   3E500A00     ADD.W   #0xa, R14
   \   000146   0D47         MOV.W   R7, R13
   \   000148   ........     CALLA   #??Subroutine4_0
   1316          
   1317                  if ( chk != hdr.chk )
   \                     ??CrossCallReturnLabel_11:
   \   00014C   2152         ADD.W   #0x4, SP
   \   00014E   15910A00     CMP.W   0xa(SP), R5
   \   000152   0820         JNE     ??osal_nv_write_8
   1318                  {
   1319                    rtrn = NV_OPER_FAILED;
   1320                  }
   1321                  else
   1322                  {
   1323                    hotItemUpdate(dstPg, dstOff+OSAL_NV_HDR_SIZE, hdr.id);
   \   000154   1E410600     MOV.W   0x6(SP), R14
   \   000158   3752         ADD.W   #0x8, R7
   \   00015A   0D47         MOV.W   R7, R13
   \   00015C   4C4A         MOV.B   R10, R12
   \   00015E   ........     CALLA   #hotItemUpdate
   \   000162   033C         JMP     ??osal_nv_write_10
   1324                  }
   1325                }
   1326                else
   1327                {
   1328                  rtrn = NV_OPER_FAILED;
   \                     ??osal_nv_write_8:
   \   000164   F1400A000400 MOV.B   #0xa, 0x4(SP)
   1329                }
   1330          
   1331                if ( comPg != OSAL_NV_PAGE_NULL )
   \                     ??osal_nv_write_10:
   \   00016A   F1900C000100 CMP.B   #0xc, 0x1(SP)
   \   000170   1924         JEQ     ??osal_nv_write_11
   1332                {
   1333                  /* Even though the page compaction succeeded, if the new item is coming from the compacted
   1334                   * page and writing the new value failed, then the compaction must be aborted.
   1335                   */
   1336                  if ( (srcPg == comPg) && (rtrn == NV_OPER_FAILED) )
   \   000172   D19101000000 CMP.B   0x1(SP), 0(SP)
   \   000178   0920         JNE     ??osal_nv_write_12
   \   00017A   F1900A000400 CMP.B   #0xa, 0x4(SP)
   \   000180   0520         JNE     ??osal_nv_write_12
   1337                  {
   1338                    erasePage( pgRes );
   \   000182   5C42....     MOV.B   &pgRes, R12
   \   000186   ........     CALLA   #erasePage
   \   00018A   173C         JMP     ??osal_nv_write_2
   1339                  }
   1340                  else
   1341                  {
   1342                    COMPACT_PAGE_CLEANUP( comPg );
   \                     ??osal_nv_write_12:
   \   00018C   5D43         MOV.B   #0x1, R13
   \   00018E   5C42....     MOV.B   &pgRes, R12
   \   000192   ........     CALLA   #setPageUse
   \   000196   5C410100     MOV.B   0x1(SP), R12
   \   00019A   ........     CALLA   #erasePage
   \   00019E   D2410100.... MOV.B   0x1(SP), &pgRes
   1343                  }
   1344                }
   1345          
   1346                /* Zero of the old item must wait until after compact page cleanup has finished - if the item
   1347                 * is zeroed before and cleanup is interrupted by a power-cycle, the new item can be lost.
   1348                 */
   1349                if ( (srcPg != comPg) && (rtrn != NV_OPER_FAILED) )
   \                     ??osal_nv_write_11:
   \   0001A4   D19101000000 CMP.B   0x1(SP), 0(SP)
   \   0001AA   0724         JEQ     ??osal_nv_write_2
   \   0001AC   F1900A000400 CMP.B   #0xa, 0x4(SP)
   \   0001B2   0324         JEQ     ??osal_nv_write_2
   1350                {
   1351                  setItem( srcPg, origOff, eNvZero );
   \   0001B4   5E43         MOV.B   #0x1, R14
   \   0001B6   ........     CALLA   #?Subroutine8
   1352                }
   1353              }
   1354            }
   1355          
   1356            return rtrn;
   \                     ??osal_nv_write_2:
   \   0001BA   5C410400     MOV.B   0x4(SP), R12
   \                     ??osal_nv_write_4:
   \   0001BE   31501000     ADD.W   #0x10, SP
   \   0001C2   7417         POPM.W  #0x8, R11
   \   0001C4   1001         RETA
   1357          }
   1358          
   1359          /*********************************************************************
   1360           * @fn      osal_nv_read
   1361           *
   1362           * @brief   Read data from NV. This function can be used to read an entire item from NV or
   1363           *          an element of an item by indexing into the item with an offset.
   1364           *          Read data is copied into *buf.
   1365           *
   1366           * @param   id  - Valid NV item Id.
   1367           * @param   ndx - Index offset into item
   1368           * @param   len - Length of data to read.
   1369           * @param  *buf - Data is read into this buffer.
   1370           *
   1371           * @return  SUCCESS if NV data was copied to the parameter 'buf'.
   1372           *          Otherwise, NV_OPER_FAILED for failure.
   1373           */

   \                                 In  segment CODE, align 2, keep-with-next
   1374          uint8 osal_nv_read( uint16 id, uint16 ndx, uint16 len, void *buf )
   \                     osal_nv_read:
   1375          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   2183         SUB.W   #0x2, SP
   \   000004   084C         MOV.W   R12, R8
   \   000006   094D         MOV.W   R13, R9
   \   000008   0A4E         MOV.W   R14, R10
   \   00000A   0B4F         MOV.W   R15, R11
   1376            uint8 *addr, *ptr = (uint8 *)buf;
   1377            uint8 findPg;
   1378            uint16 offset;
   1379            uint8 hotIdx;
   1380          
   1381            if ((hotIdx = hotItem(id)) < OSAL_NV_MAX_HOT)
   \   00000C   ........     CALLA   #?Subroutine9
   \                     ??CrossCallReturnLabel_8:
   \   000010   072C         JC      ??osal_nv_read_2
   1382            {
   1383              findPg = hotPg[hotIdx];
   \   000012   ........     CALLA   #?Subroutine3
   1384              offset = hotOff[hotIdx];
   1385            }
   1386            else if ((offset = findItem(id, &findPg)) == OSAL_NV_ITEM_NULL)
   1387            {
   1388              return NV_OPER_FAILED;
   1389            }
   1390          
   1391            addr = OSAL_NV_PAGE_TO_PTR(findPg) + offset + ndx;
   \                     ??osal_nv_read_0:
   \   000016   ........     CALLA   #?Subroutine10
   \                     ??CrossCallReturnLabel_19:
   \   00001A   0E5C         ADD.W   R12, R14
   \   00001C   0E59         ADD.W   R9, R14
   \   00001E   0D3C         JMP     ??osal_nv_read_3
   \                     ??osal_nv_read_2:
   \   000020   0D41         MOV.W   SP, R13
   \   000022   0D53         ADD.W   #0x0, R13
   \   000024   0C48         MOV.W   R8, R12
   \   000026   ........     CALLA   #findItem
   \   00002A   0C93         CMP.W   #0x0, R12
   \   00002C   F423         JNE     ??osal_nv_read_0
   \   00002E   7C400A00     MOV.B   #0xa, R12
   \   000032   083C         JMP     ??osal_nv_read_4
   1392            while ( len-- )
   1393            {
   1394              *ptr++ = *addr++;
   \                     ??osal_nv_read_1:
   \   000034   FB4E0000     MOV.B   @R14+, 0(R11)
   \   000038   1B53         ADD.W   #0x1, R11
   1395            }
   \                     ??osal_nv_read_3:
   \   00003A   0F4A         MOV.W   R10, R15
   \   00003C   3A53         ADD.W   #0xffff, R10
   \   00003E   0F93         CMP.W   #0x0, R15
   \   000040   F923         JNE     ??osal_nv_read_1
   1396          
   1397            return SUCCESS;
   \   000042   4C43         MOV.B   #0x0, R12
   \                     ??osal_nv_read_4:
   \   000044   ....         JMP     ?Subroutine1
   \   000046   0343         NOP
   1398          }
   1399          
   1400          /*********************************************************************
   1401           * @fn      osal_nv_delete
   1402           *
   1403           * @brief   Delete item from NV. This function will fail if the length
   1404           *          parameter does not match the length of the item in NV.
   1405           *
   1406           * @param   id  - Valid NV item Id.
   1407           * @param   len - Length of item to delete.
   1408           *
   1409           * @return  SUCCESS if item was deleted,
   1410           *          NV_ITEM_UNINIT if item did not exist in NV,
   1411           *          NV_BAD_ITEM_LEN if length parameter not correct,
   1412           *          NV_OPER_FAILED if attempted deletion failed.
   1413           */

   \                                 In  segment CODE, align 2, keep-with-next
   1414          uint8 osal_nv_delete( uint16 id, uint16 len )
   \                     osal_nv_delete:
   1415          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   2183         SUB.W   #0x2, SP
   \   000004   0A4C         MOV.W   R12, R10
   \   000006   0B4D         MOV.W   R13, R11
   1416            uint8 findPg;
   1417            uint16 length;
   1418            uint16 offset;
   1419          
   1420            offset = findItem( id, &findPg );
   \   000008   0D41         MOV.W   SP, R13
   \   00000A   0D53         ADD.W   #0x0, R13
   \   00000C   ........     CALLA   #findItem
   \   000010   084C         MOV.W   R12, R8
   1421            if ( offset == OSAL_NV_ITEM_NULL )
   \   000012   0C93         CMP.W   #0x0, R12
   \   000014   0320         JNE     ??osal_nv_delete_1
   1422            {
   1423              // NV item does not exist
   1424              return NV_ITEM_UNINIT;
   \   000016   7C400900     MOV.B   #0x9, R12
   \   00001A   133C         JMP     ??osal_nv_delete_0
   1425            }
   1426          
   1427            length = osal_nv_item_len( id );
   1428            if ( length != len )
   \                     ??osal_nv_delete_1:
   \   00001C   0C4A         MOV.W   R10, R12
   \   00001E   ........     CALLA   #osal_nv_item_len
   \   000022   0C9B         CMP.W   R11, R12
   \   000024   0324         JEQ     ??osal_nv_delete_2
   1429            {
   1430              // NV item has different length
   1431              return NV_BAD_ITEM_LEN;
   \   000026   7C400C00     MOV.B   #0xc, R12
   \   00002A   0B3C         JMP     ??osal_nv_delete_0
   1432            }
   1433          
   1434            // Set item header ID to zero to 'delete' the item
   1435            setItem( findPg, offset, eNvZero );
   \                     ??osal_nv_delete_2:
   \   00002C   5E43         MOV.B   #0x1, R14
   \   00002E   0D48         MOV.W   R8, R13
   \   000030   ........     CALLA   #??Subroutine8_0
   1436          
   1437            // Verify that item has been removed
   1438            offset = findItem( id, &findPg );
   1439            if ( offset != OSAL_NV_ITEM_NULL )
   \                     ??CrossCallReturnLabel_16:
   \   000034   ........     CALLA   #?Subroutine6
   \                     ??CrossCallReturnLabel_3:
   \   000038   0220         JNE     ??osal_nv_delete_3
   \   00003A   4C43         MOV.B   #0x0, R12
   \   00003C   023C         JMP     ??osal_nv_delete_0
   \                     ??osal_nv_delete_3:
   \   00003E   7C400A00     MOV.B   #0xa, R12
   1440            {
   1441              // Still there
   1442              return NV_OPER_FAILED;
   1443            }
   1444            else
   1445            {
   1446              // Yes, it's gone
   1447              return SUCCESS;
   \                     ??osal_nv_delete_0:
   \   000042                REQUIRE ?Subroutine1
   \   000042                // Fall through to label ?Subroutine1
   1448            }
   1449          }
   1450          
   1451          /*********************************************************************
   1452           */

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
       4  calcChkF
      32  compactPage
            30 -> calcChkF
            32 -> calcChkF
            30 -> erasePage
            32 -> flashWrite
            30 -> hotItemUpdate
            30 -> readHdr
            32 -> readHdr
            30 -> setItem
            30 -> setPageUse
            32 -> writeItem
            32 -> xferBuf
       8  erasePage
             8 -> flashErasePage
      12  findItem
            12 -> initPage
       4  hotItem
       6  hotItemUpdate
             6 -> hotItem
      24  initItem
            22 -> compactPage
            22 -> erasePage
            22 -> flashWrite
            22 -> setPageUse
            24 -> writeItem
      20  initNV
            20 -> compactPage
            20 -> erasePage
            20 -> initPage
            20 -> readHdr
            20 -> setPageUse
      26  initPage
            26 -> calcChkF
            26 -> findItem
            26 -> readHdr
            26 -> setItem
      14  osal_nv_delete
            14 -> findItem
            14 -> osal_nv_item_len
            14 -> setItem
       4  osal_nv_init
             4 -> initNV
      14  osal_nv_item_init
            14 -> HalAdcCheckVdd
            14 -> findItem
            14 -> hotItemUpdate
            14 -> initItem
      16  osal_nv_item_len
            16 -> findItem
            16 -> hotItem
            16 -> readHdr
      14  osal_nv_read
            14 -> findItem
            14 -> hotItem
      40  osal_nv_write
            36 -> HalAdcCheckVdd
            40 -> calcChkF
            36 -> erasePage
            36 -> findItem
            38 -> flashWrite
            40 -> flashWrite
            36 -> hotItemUpdate
            36 -> initItem
            36 -> readHdr
            40 -> readHdr
            36 -> setItem
            36 -> setPageUse
            38 -> xferBuf
            40 -> xferBuf
       4  readHdr
      20  setItem
            20 -> flashWrite
            20 -> readHdr
      12  setPageUse
            12 -> flashWrite
      34  writeItem
            32 -> calcChkF
            32 -> flashWrite
            32 -> hotItemUpdate
            32 -> readHdr
       8  xferBuf
             8 -> flashWrite


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       2  ??Subroutine12_0
      12  ??Subroutine15_0
       2  ??Subroutine2_0
      10  ??Subroutine2_1
       6  ??Subroutine4_0
       8  ??Subroutine8_0
       6  ?Subroutine0
       6  ?Subroutine1
       4  ?Subroutine10
      16  ?Subroutine11
       2  ?Subroutine2
      16  ?Subroutine3
       6  ?Subroutine4
      14  ?Subroutine5
      14  ?Subroutine6
      16  ?Subroutine7
       2  ?Subroutine8
      10  ?Subroutine9
   12288  _nvBuf
      32  calcChkF
     250  compactPage
      44  erasePage
      58  findItem
       6  hotIds
      24  hotItem
      28  hotItemUpdate
       6  hotOff
       3  hotPg
     186  initItem
     228  initNV
     194  initPage
      66  osal_nv_delete
       4  osal_nv_init
      74  osal_nv_item_init
      56  osal_nv_item_len
      72  osal_nv_read
     454  osal_nv_write
      24  pgLost
      24  pgOff
       1  pgRes
      20  readHdr
      82  setItem
      38  setPageUse
     264  writeItem
      34  xferBuf

 
  2 360 bytes in segment CODE
      6 bytes in segment DATA16_C
     58 bytes in segment DATA16_Z
 12 288 bytes in segment ZIGNV_ADDRESS_SPACE
 
  2 360 bytes of CODE  memory
      6 bytes of CONST memory
 12 346 bytes of DATA  memory

Errors: none
Warnings: none
