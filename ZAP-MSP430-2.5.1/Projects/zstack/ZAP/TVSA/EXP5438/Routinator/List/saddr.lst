###############################################################################
#                                                                             #
# IAR C/C++ Compiler V5.51.2.50607/W32 for MSP430       19/Apr/2013  11:30:20 #
# Copyright 1996-2012 IAR Systems AB.                                         #
#                                                                             #
#    __rt_version  =  3                                                       #
#    __double_size =  32                                                      #
#    __reg_r4      =  free                                                    #
#    __reg_r5      =  free                                                    #
#    __pic         =  no                                                      #
#    __core        =  430X                                                    #
#    __data_model  =  small                                                   #
#    Source file   =  C:\Users\student\Documents\GitHub\MHMS\MHMS\ZAP-MSP430- #
#                     2.5.1\Components\services\saddr\saddr.c                 #
#    Command line  =  -f C:\Users\student\Documents\GitHub\MHMS\MHMS\ZAP-MSP4 #
#                     30-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\Source\ #
#                     zap.cfg (-DTVSA_DEVICE_ID=0x0016 -DZAP_PHY_SPI=1        #
#                     -DZAP_PHY_UART=!ZAP_PHY_SPI -DZAP_PHY_RESET_ZNP=TRUE    #
#                     -DZAP_ZNP_MT=FALSE -DZAP_APP_MSG=FALSE                  #
#                     -DZAP_SBL_PROXY=FALSE -DZAP_AUTO_CFG=TRUE               #
#                     -DZAP_AUTO_START=TRUE -DZAP_NV_RESTORE=FALSE            #
#                     -DLCD_SUPPORTED -DZAP_AF_DATA_REQ_FRAG=FALSE            #
#                     -DZAP_AF_DATA_REQ_AREQ=!ZAP_AF_DATA_REQ_FRAG            #
#                     -DZAP_ZDO_STARTUP_AREQ=TRUE -DZAP_AF_FUNC               #
#                     -DZAP_SAPI_FUNC -DZAP_SYS_FUNC -DZAP_UTIL_FUNC          #
#                     -DZAP_ZDO_FUNC -DSECURE=0 -DZG_SECURE_DYNAMIC=0         #
#                     "-DDEFAULT_CHANLIST=(uint32)0x00000800"                 #
#                     -DZDAPP_CONFIG_PAN_ID=0xFFFF -DPOLL_RATE=1000           #
#                     -DNWK_START_DELAY=100 -DMAX_BINDING_CLUSTER_IDS=4)      #
#                     C:\Users\student\Documents\GitHub\MHMS\MHMS\ZAP-MSP430- #
#                     2.5.1\Components\services\saddr\saddr.c -lC             #
#                     C:\Users\student\Documents\GitHub\MHMS\MHMS\ZAP-MSP430- #
#                     2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\Routinator\List\ #
#                      -lA C:\Users\student\Documents\GitHub\MHMS\MHMS\ZAP-MS #
#                     P430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\Routinator\ #
#                     List\ --remarks --diag_suppress                         #
#                     Pe001,Pe193,Pe236,Pe826 -o                              #
#                     C:\Users\student\Documents\GitHub\MHMS\MHMS\ZAP-MSP430- #
#                     2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\Routinator\Obj\  #
#                     --debug -D__MSP430F5438A__ -e --double=32 --clib -I     #
#                     C:\Users\student\Documents\GitHub\MHMS\MHMS\ZAP-MSP430- #
#                     2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\ -I              #
#                     C:\Users\student\Documents\GitHub\MHMS\MHMS\ZAP-MSP430- #
#                     2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\..\Source\ -I    #
#                     C:\Users\student\Documents\GitHub\MHMS\MHMS\ZAP-MSP430- #
#                     2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\Source\    #
#                     -I C:\Users\student\Documents\GitHub\MHMS\MHMS\ZAP-MSP4 #
#                     30-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\. #
#                     .\Components\hal\target\MSP5438ZAP\ -I                  #
#                     C:\Users\student\Documents\GitHub\MHMS\MHMS\ZAP-MSP430- #
#                     2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\C #
#                     omponents\hal\include\ -I C:\Users\student\Documents\Gi #
#                     tHub\MHMS\MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVS #
#                     A\EXP5438\..\..\..\..\..\Components\mac\include\ -I     #
#                     C:\Users\student\Documents\GitHub\MHMS\MHMS\ZAP-MSP430- #
#                     2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\C #
#                     omponents\mt\ -I C:\Users\student\Documents\GitHub\MHMS #
#                     \MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438 #
#                     \..\..\..\..\..\Components\osal\include\ -I             #
#                     C:\Users\student\Documents\GitHub\MHMS\MHMS\ZAP-MSP430- #
#                     2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\C #
#                     omponents\osal\mcu\msp430\ -I                           #
#                     C:\Users\student\Documents\GitHub\MHMS\MHMS\ZAP-MSP430- #
#                     2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\C #
#                     omponents\services\saddr\ -I                            #
#                     C:\Users\student\Documents\GitHub\MHMS\MHMS\ZAP-MSP430- #
#                     2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\C #
#                     omponents\services\sdata\ -I                            #
#                     C:\Users\student\Documents\GitHub\MHMS\MHMS\ZAP-MSP430- #
#                     2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\C #
#                     omponents\stack\af\ -I C:\Users\student\Documents\GitHu #
#                     b\MHMS\MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\E #
#                     XP5438\..\..\..\..\..\Components\stack\nwk\ -I          #
#                     C:\Users\student\Documents\GitHub\MHMS\MHMS\ZAP-MSP430- #
#                     2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\C #
#                     omponents\stack\sapi\ -I C:\Users\student\Documents\Git #
#                     Hub\MHMS\MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA #
#                     \EXP5438\..\..\..\..\..\Components\stack\sec\ -I        #
#                     C:\Users\student\Documents\GitHub\MHMS\MHMS\ZAP-MSP430- #
#                     2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\C #
#                     omponents\stack\sys\ -I C:\Users\student\Documents\GitH #
#                     ub\MHMS\MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\ #
#                     EXP5438\..\..\..\..\..\Components\stack\zdo\ -I         #
#                     C:\Users\student\Documents\GitHub\MHMS\MHMS\ZAP-MSP430- #
#                     2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\C #
#                     omponents\zmac\ -I C:\Users\student\Documents\GitHub\MH #
#                     MS\MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP54 #
#                     38\..\..\..\..\..\Components\zmac\f8w\ --core=430X      #
#                     --data_model=small -Ohz --multiplier=32                 #
#                     --multiplier_location=4C0 --require_prototypes          #
#                     --hw_workaround=CPU40 --hw_workaround=CPU42             #
#    List file     =  C:\Users\student\Documents\GitHub\MHMS\MHMS\ZAP-MSP430- #
#                     2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\Routinator\List\ #
#                     saddr.lst                                               #
#    Object file   =  C:\Users\student\Documents\GitHub\MHMS\MHMS\ZAP-MSP430- #
#                     2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\Routinator\Obj\s #
#                     addr.r43                                                #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\student\Documents\GitHub\MHMS\MHMS\ZAP-MSP430-2.5.1\Components\services\saddr\saddr.c
      1          /****************************************************************************
      2            Filename:       saddr.c
      3            Revised:        $Date: 2009-12-10 08:32:15 -0800 (Thu, 10 Dec 2009) $
      4            Revision:       $Revision: 21311 $
      5          
      6            Description:    Zigbee and 802.15.4 device address utility functions.
      7          
      8          
      9            Copyright 2005-2010 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          ****************************************************************************/
     39          
     40          /****************************************************************************
     41           * INCLUDES
     42           */
     43          #include "hal_types.h"
     44          #include "OSAL.h"
     45          #include "saddr.h"
     46          
     47          /****************************************************************************
     48           * @fn          sAddrCmp
     49           *
     50           * @brief       Compare two device addresses.
     51           *
     52           * input parameters
     53           *
     54           * @param       pAddr1        - Pointer to first address.
     55           * @param       pAddr2        - Pointer to second address.
     56           *
     57           * output parameters
     58           *
     59           * @return      TRUE if addresses are equal, FALSE otherwise
     60           */

   \                                 In  segment CODE, align 2
     61          bool sAddrCmp(const sAddr_t *pAddr1, const sAddr_t *pAddr2)
   \                     sAddrCmp:
     62          {
     63            if (pAddr1->addrMode != pAddr2->addrMode)
   \   000000   5E4C0800     MOV.B   0x8(R12), R14
   \   000004   5E9D0800     CMP.B   0x8(R13), R14
   \   000008   1020         JNE     ??sAddrCmp_2
     64            {
     65              return FALSE;
     66            }
     67            else if (pAddr1->addrMode == SADDR_MODE_NONE)
   \   00000A   4E93         CMP.B   #0x0, R14
   \   00000C   0E24         JEQ     ??sAddrCmp_2
     68            {
     69              return FALSE;
     70            }
     71            else if (pAddr1->addrMode == SADDR_MODE_SHORT)
   \   00000E   6E93         CMP.B   #0x2, R14
   \   000010   0720         JNE     ??sAddrCmp_3
     72            {
     73              return (bool) (pAddr1->addr.shortAddr == pAddr2->addr.shortAddr);
   \   000012   AC9D0000     CMP.W   @R13, 0(R12)
   \   000016   0224         JEQ     ??sAddrCmp_4
   \   000018   4C43         MOV.B   #0x0, R12
   \   00001A   1001         RETA
   \                     ??sAddrCmp_4:
   \   00001C   5C43         MOV.B   #0x1, R12
   \   00001E   1001         RETA
     74            }
     75            else if (pAddr1->addrMode == SADDR_MODE_EXT)
   \                     ??sAddrCmp_3:
   \   000020   7E900300     CMP.B   #0x3, R14
   \   000024   0220         JNE     ??sAddrCmp_2
     76            {
     77              return (sAddrExtCmp(pAddr1->addr.extAddr, pAddr2->addr.extAddr));
   \   000026   ........     BRA     #sAddrExtCmp
     78            }
     79            else
     80            {
     81              return FALSE;
   \                     ??sAddrCmp_2:
   \   00002A   4C43         MOV.B   #0x0, R12
   \   00002C   1001         RETA
     82            }
     83          }
     84          
     85          /****************************************************************************
     86           * @fn          sAddrIden
     87           *
     88           * @brief       Check if two device addresses are identical.
     89           *
     90           *              This routine is virtually the same as sAddrCmp, which is used
     91           *              to determine if two different addresses are the same. However,
     92           *              this routine can be used to determine if an address is the
     93           *              same as a previously stored address. The key difference is in
     94           *              the former case, if the address mode is "none", then the
     95           *              assumption is that the two addresses can not be the same. But
     96           *              in the latter case, the address mode itself is being compared.
     97           *              So two addresses can be identical even if the address mode is
     98           *              "none", as long as the address mode of both addresses being
     99           *              compared is "none".
    100           *
    101           * input parameters
    102           *
    103           * @param       pAddr1        - Pointer to first address.
    104           * @param       pAddr2        - Pointer to second address.
    105           *
    106           * output parameters
    107           *
    108           * @return      TRUE if addresses are identical, FALSE otherwise
    109           */

   \                                 In  segment CODE, align 2
    110          bool sAddrIden(const sAddr_t *pAddr1, const sAddr_t *pAddr2)
   \                     sAddrIden:
    111          {
    112            // first check if the address modes are the same
    113            if (pAddr1->addrMode != pAddr2->addrMode)
   \   000000   5E4C0800     MOV.B   0x8(R12), R14
   \   000004   5E9D0800     CMP.B   0x8(R13), R14
   \   000008   1220         JNE     ??sAddrIden_2
    114            {
    115              // no, so no point in comparing any further
    116              return FALSE;
    117            }
    118            // the address modes are the same; check if there is no address
    119            else if (pAddr1->addrMode == SADDR_MODE_NONE)
   \   00000A   4E93         CMP.B   #0x0, R14
   \   00000C   0220         JNE     ??sAddrIden_3
    120            {
    121              // no address, so no need to compare any further as both addresses have the
    122              // same address mode but no address, so they are identical
    123              return TRUE;
   \   00000E   5C43         MOV.B   #0x1, R12
   \   000010   1001         RETA
    124            }
    125            // there's an address; check if it is short
    126            else if (pAddr1->addrMode == SADDR_MODE_SHORT)
   \                     ??sAddrIden_3:
   \   000012   6E93         CMP.B   #0x2, R14
   \   000014   0720         JNE     ??sAddrIden_4
    127            {
    128              // compare short addresses
    129              return (bool) (pAddr1->addr.shortAddr == pAddr2->addr.shortAddr);
   \   000016   AC9D0000     CMP.W   @R13, 0(R12)
   \   00001A   0224         JEQ     ??sAddrIden_5
   \   00001C   4C43         MOV.B   #0x0, R12
   \   00001E   1001         RETA
   \                     ??sAddrIden_5:
   \   000020   5C43         MOV.B   #0x1, R12
   \   000022   1001         RETA
    130            }
    131            // there's an address; check if it is extended
    132            else if (pAddr1->addrMode == SADDR_MODE_EXT)
   \                     ??sAddrIden_4:
   \   000024   7E900300     CMP.B   #0x3, R14
   \   000028   0220         JNE     ??sAddrIden_2
    133            {
    134              // compare extended addresses
    135              return (sAddrExtCmp(pAddr1->addr.extAddr, pAddr2->addr.extAddr));
   \   00002A   ........     BRA     #sAddrExtCmp
    136            }
    137            else // unknown error
    138            {
    139              return FALSE;
   \                     ??sAddrIden_2:
   \   00002E   4C43         MOV.B   #0x0, R12
   \   000030   1001         RETA
    140            }
    141          }
    142          
    143          /****************************************************************************
    144           * @fn          sAddrCpy
    145           *
    146           * @brief       Copy a device address.
    147           *
    148           * input parameters
    149           *
    150           * @param       pSrc         - Pointer to address to copy.
    151           *
    152           * output parameters
    153           *
    154           * @param       pDest        - Pointer to address of copy.
    155           *
    156           * @return      None.
    157           */

   \                                 In  segment CODE, align 2
    158          void sAddrCpy(sAddr_t *pDest, const sAddr_t *pSrc)
   \                     sAddrCpy:
    159          {
    160            pDest->addrMode = pSrc->addrMode;
   \   000000   5E4D0800     MOV.B   0x8(R13), R14
   \   000004   CC4E0800     MOV.B   R14, 0x8(R12)
    161          
    162            if (pDest->addrMode == SADDR_MODE_EXT)
   \   000008   7E900300     CMP.B   #0x3, R14
   \   00000C   0220         JNE     ??sAddrCpy_0
    163            {
    164              sAddrExtCpy(pDest->addr.extAddr, pSrc->addr.extAddr);
   \   00000E   ........     BRA     #sAddrExtCpy
    165            }
    166            else
    167            {
    168              pDest->addr.shortAddr = pSrc->addr.shortAddr;
   \                     ??sAddrCpy_0:
   \   000012   AC4D0000     MOV.W   @R13, 0(R12)
    169            }
    170          }
   \   000016   1001         RETA
    171          
    172          /****************************************************************************
    173           * @fn          sAddrExtCmp
    174           *
    175           * @brief       Compare two extended addresses.
    176           *
    177           * input parameters
    178           *
    179           * @param       pAddr1        - Pointer to first address.
    180           * @param       pAddr2        - Pointer to second address.
    181           *
    182           * output parameters
    183           *
    184           * @return      TRUE if addresses are equal, FALSE otherwise
    185           */

   \                                 In  segment CODE, align 2
    186          bool sAddrExtCmp(const uint8 * pAddr1, const uint8 * pAddr2)
   \                     sAddrExtCmp:
    187          {
    188            uint8 i;
    189          
    190            for (i = SADDR_EXT_LEN; i != 0; i--)
   \   000000   7E42         MOV.B   #0x8, R14
    191            {
    192              if (*pAddr1++ != *pAddr2++)
   \                     ??sAddrExtCmp_0:
   \   000002   7F4C         MOV.B   @R12+, R15
   \   000004   7F9D         CMP.B   @R13+, R15
   \   000006   0224         JEQ     ??sAddrExtCmp_1
    193              {
    194                return FALSE;
   \   000008   4C43         MOV.B   #0x0, R12
   \   00000A   1001         RETA
    195              }
    196            }
   \                     ??sAddrExtCmp_1:
   \   00000C   7E53         ADD.B   #0xff, R14
   \   00000E   F923         JNE     ??sAddrExtCmp_0
    197            return TRUE;
   \   000010   5C43         MOV.B   #0x1, R12
   \   000012   1001         RETA
    198          }
    199          
    200          /****************************************************************************
    201           * @fn          sAddrExtCpy
    202           *
    203           * @brief       Copy an extended address.
    204           *
    205           * input parameters
    206           *
    207           * @param       pSrc         - Pointer to address to copy.
    208           *
    209           * output parameters
    210           *
    211           * @param       pDest        - Pointer to address of copy.
    212           *
    213           * @return      pDest + SADDR_EXT_LEN.
    214           */

   \                                 In  segment CODE, align 2
    215          void *sAddrExtCpy(uint8 * pDest, const uint8 * pSrc)
   \                     sAddrExtCpy:
    216          {
    217            return osal_memcpy(pDest, pSrc, SADDR_EXT_LEN);
   \   000000   3E42         MOV.W   #0x8, R14
   \   000002   ........     BRA     #osal_memcpy
    218          }
    219          
    220          
    221          
    222          

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
       4  sAddrCmp
            4 -> sAddrExtCmp
       4  sAddrCpy
            4 -> sAddrExtCpy
       4  sAddrExtCmp
       4  sAddrExtCpy
            4 -> osal_memcpy
       4  sAddrIden
            4 -> sAddrExtCmp


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      46  sAddrCmp
      24  sAddrCpy
      20  sAddrExtCmp
       6  sAddrExtCpy
      50  sAddrIden

 
 146 bytes in segment CODE
 
 146 bytes of CODE memory

Errors: none
Warnings: none
