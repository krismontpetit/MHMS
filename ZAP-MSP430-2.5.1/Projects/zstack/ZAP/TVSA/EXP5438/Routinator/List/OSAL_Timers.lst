###############################################################################
#                                                                             #
# IAR C/C++ Compiler V5.51.2.50607/W32 for MSP430       07/Apr/2013  00:33:59 #
# Copyright 1996-2012 IAR Systems AB.                                         #
#                                                                             #
#    __rt_version  =  3                                                       #
#    __double_size =  32                                                      #
#    __reg_r4      =  free                                                    #
#    __reg_r5      =  free                                                    #
#    __pic         =  no                                                      #
#    __core        =  430X                                                    #
#    __data_model  =  small                                                   #
#    Source file   =  C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Components\osal\common\OSAL_Timers.c                   #
#    Command line  =  -f C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2. #
#                     5.1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\Source\zap.c #
#                     fg (-DZAP_PHY_SPI=1 -DZAP_PHY_UART=0                    #
#                     -DZAP_DEVICETYPE=ZG_DEVICETYPE_ROUTER                   #
#                     -DTVSA_DEVICE_ID=0x0016 -DTVSA_DONGLE=1 -DHAL_UART=1    #
#                     -DZAP_PHY_RESET_ZNP=TRUE -DZAP_ZNP_MT=FALSE             #
#                     -DZAP_APP_MSG=FALSE -DZAP_SBL_PROXY=FALSE               #
#                     -DZAP_AUTO_CFG=TRUE -DZAP_AUTO_START=TRUE               #
#                     -DZAP_NV_RESTORE=FALSE -DLCD_SUPPORTED                  #
#                     -DZAP_AF_DATA_REQ_FRAG=FALSE                            #
#                     -DZAP_AF_DATA_REQ_AREQ=!ZAP_AF_DATA_REQ_FRAG            #
#                     -DZAP_ZDO_STARTUP_AREQ=TRUE -DZAP_AF_FUNC               #
#                     -DZAP_SAPI_FUNC -DZAP_SYS_FUNC -DZAP_UTIL_FUNC          #
#                     -DZAP_ZDO_FUNC -DSECURE=0 -DZG_SECURE_DYNAMIC=0         #
#                     "-DDEFAULT_CHANLIST=(uint32)0x00000800"                 #
#                     -DZDAPP_CONFIG_PAN_ID=0xFFFF -DPOLL_RATE=1000           #
#                     -DNWK_START_DELAY=100 -DMAX_BINDING_CLUSTER_IDS=4)      #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Components\osal\common\OSAL_Timers.c -lC               #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\Routinator\List\ -lA  #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\Routinator\List\      #
#                     --remarks --diag_suppress Pe001,Pe193,Pe236,Pe826 -o    #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\Routinator\Obj\       #
#                     --debug -D__MSP430F5438A__ -e --double=32 --clib -I     #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\ -I                   #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\Source\ -I         #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\Source\ -I      #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\hal\target\MSP5438ZAP\ -I                          #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\hal\include\ -I C:\Users\student\Documents\GitHub\ #
#                     MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\ #
#                     ..\..\..\..\..\Components\mac\include\ -I               #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\mt\ -I C:\Users\student\Documents\GitHub\MHMS\ZAP- #
#                     MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\ #
#                     ..\..\Components\osal\include\ -I                       #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\osal\mcu\msp430\ -I C:\Users\student\Documents\Git #
#                     Hub\MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5 #
#                     438\..\..\..\..\..\Components\services\saddr\ -I        #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\services\sdata\ -I C:\Users\student\Documents\GitH #
#                     ub\MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP54 #
#                     38\..\..\..\..\..\Components\stack\af\ -I               #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\stack\nwk\ -I C:\Users\student\Documents\GitHub\MH #
#                     MS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\.. #
#                     \..\..\..\..\Components\stack\sapi\ -I                  #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\stack\sec\ -I C:\Users\student\Documents\GitHub\MH #
#                     MS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\.. #
#                     \..\..\..\..\Components\stack\sys\ -I                   #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\stack\zdo\ -I C:\Users\student\Documents\GitHub\MH #
#                     MS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\.. #
#                     \..\..\..\..\Components\zmac\ -I                        #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\zmac\f8w\ --core=430X --data_model=small -Ohz      #
#                     --multiplier=32 --multiplier_location=4C0               #
#                     --require_prototypes --hw_workaround=CPU40              #
#                     --hw_workaround=CPU42                                   #
#    List file     =  C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\Routinator\List\OSAL_ #
#                     Timers.lst                                              #
#    Object file   =  C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\Routinator\Obj\OSAL_T #
#                     imers.r43                                               #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1\Components\osal\common\OSAL_Timers.c
      1          /**************************************************************************************************
      2            Filename:       OSAL_Timers.c
      3            Revised:        $Date: 2010-09-17 16:25:30 -0700 (Fri, 17 Sep 2010) $
      4            Revision:       $Revision: 23835 $
      5          
      6            Description:    OSAL Timer definition and manipulation functions.
      7          
      8          
      9            Copyright 2004-2009 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /*********************************************************************
     41           * INCLUDES
     42           */
     43          
     44          #include "comdef.h"
     45          #include "OnBoard.h"
     46          #include "OSAL.h"
     47          #include "OSAL_Timers.h"
     48          #include "hal_timer.h"
     49          
     50          /*********************************************************************
     51           * MACROS
     52           */
     53          
     54          /*********************************************************************
     55           * CONSTANTS
     56           */
     57          
     58          /*********************************************************************
     59           * TYPEDEFS
     60           */
     61          
     62          typedef struct
     63          {
     64            void   *next;
     65            uint16 timeout;
     66            uint16 event_flag;
     67            uint8  task_id;
     68            uint16 reloadTimeout;
     69          } osalTimerRec_t;
     70          
     71          /*********************************************************************
     72           * GLOBAL VARIABLES
     73           */
     74          

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     75          osalTimerRec_t *timerHead;
   \                     timerHead:
   \   000000                DS8 2
     76          
     77          /*********************************************************************
     78           * EXTERNAL VARIABLES
     79           */
     80          
     81          /*********************************************************************
     82           * EXTERNAL FUNCTIONS
     83           */
     84          
     85          /*********************************************************************
     86           * LOCAL VARIABLES
     87           */
     88          // Milliseconds since last reboot

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     89          static uint32 osal_systemClock;
   \                     osal_systemClock:
   \   000000                DS8 4
     90          
     91          /*********************************************************************
     92           * LOCAL FUNCTION PROTOTYPES
     93           */
     94          osalTimerRec_t  *osalAddTimer( uint8 task_id, uint16 event_flag, uint16 timeout );
     95          osalTimerRec_t *osalFindTimer( uint8 task_id, uint16 event_flag );
     96          void osalDeleteTimer( osalTimerRec_t *rmTimer );
     97          
     98          /*********************************************************************
     99           * FUNCTIONS
    100           *********************************************************************/
    101          
    102          /*********************************************************************
    103           * @fn      osalTimerInit
    104           *
    105           * @brief   Initialization for the OSAL Timer System.
    106           *
    107           * @param   none
    108           *
    109           * @return
    110           */

   \                                 In  segment CODE, align 2
    111          void osalTimerInit( void )
   \                     osalTimerInit:
    112          {
    113            osal_systemClock = 0;
   \   000000   8243....     MOV.W   #0x0, &osal_systemClock
   \   000004   8243....     MOV.W   #0x0, &osal_systemClock + 2
    114          }
   \   000008   1001         RETA
    115          
    116          /*********************************************************************
    117           * @fn      osalAddTimer
    118           *
    119           * @brief   Add a timer to the timer list.
    120           *          Ints must be disabled.
    121           *
    122           * @param   task_id
    123           * @param   event_flag
    124           * @param   timeout
    125           *
    126           * @return  osalTimerRec_t * - pointer to newly created timer
    127           */

   \                                 In  segment CODE, align 2
    128          osalTimerRec_t * osalAddTimer( uint8 task_id, uint16 event_flag, uint16 timeout )
   \                     osalAddTimer:
    129          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   4A4C         MOV.B   R12, R10
   \   000004   0B4D         MOV.W   R13, R11
   \   000006   084E         MOV.W   R14, R8
    130            osalTimerRec_t *newTimer;
    131            osalTimerRec_t *srchTimer;
    132          
    133            // Look for an existing timer first
    134            newTimer = osalFindTimer( task_id, event_flag );
   \   000008   ........     CALLA   #osalFindTimer
    135            if ( newTimer )
   \   00000C   0C93         CMP.W   #0x0, R12
   \   00000E   0324         JEQ     ??osalAddTimer_5
    136            {
    137              // Timer is found - update it.
    138              newTimer->timeout = timeout;
   \   000010   8C4E0200     MOV.W   R14, 0x2(R12)
    139          
    140              return ( newTimer );
   \   000014   1F3C         JMP     ??osalAddTimer_4
    141            }
    142            else
    143            {
    144              // New Timer
    145              newTimer = osal_mem_alloc( sizeof( osalTimerRec_t ) );
   \                     ??osalAddTimer_5:
   \   000016   3C400A00     MOV.W   #0xa, R12
   \   00001A   ........     CALLA   #osal_mem_alloc
    146          
    147              if ( newTimer )
   \   00001E   0C93         CMP.W   #0x0, R12
   \   000020   1824         JEQ     ??osalAddTimer_6
    148              {
    149                // Fill in new timer
    150                newTimer->task_id = task_id;
   \   000022   CC4A0600     MOV.B   R10, 0x6(R12)
    151                newTimer->event_flag = event_flag;
   \   000026   8C4B0400     MOV.W   R11, 0x4(R12)
    152                newTimer->timeout = timeout;
   \   00002A   8C480200     MOV.W   R8, 0x2(R12)
    153                newTimer->next = (void *)NULL;
   \   00002E   8C430000     MOV.W   #0x0, 0(R12)
    154                newTimer->reloadTimeout = 0;
   \   000032   8C430800     MOV.W   #0x0, 0x8(R12)
    155          
    156                // Does the timer list already exist
    157                if ( timerHead == NULL )
   \   000036   1F42....     MOV.W   &timerHead, R15
   \   00003A   0F93         CMP.W   #0x0, R15
   \   00003C   0420         JNE     ??osalAddTimer_2
    158                {
    159                  // Start task list
    160                  timerHead = newTimer;
   \   00003E   824C....     MOV.W   R12, &timerHead
   \   000042   083C         JMP     ??osalAddTimer_4
    161                }
    162                else
    163                {
    164                  // Add it to the end of the timer list
    165                  srchTimer = timerHead;
    166          
    167                  // Stop at the last record
    168                  while ( srchTimer->next )
    169                    srchTimer = srchTimer->next;
   \                     ??osalAddTimer_0:
   \   000044   0F4B         MOV.W   R11, R15
   \                     ??osalAddTimer_2:
   \   000046   2B4F         MOV.W   @R15, R11
   \   000048   0B93         CMP.W   #0x0, R11
   \   00004A   FC23         JNE     ??osalAddTimer_0
    170          
    171                  // Add to the list
    172                  srchTimer->next = newTimer;
   \   00004C   8F4C0000     MOV.W   R12, 0(R15)
    173                }
    174          
    175                return ( newTimer );
   \   000050   013C         JMP     ??osalAddTimer_4
    176              }
    177              else
    178                return ( (osalTimerRec_t *)NULL );
   \                     ??osalAddTimer_6:
   \   000052   0C43         MOV.W   #0x0, R12
   \                     ??osalAddTimer_4:
   \   000054   3817         POPM.W  #0x4, R11
   \   000056   1001         RETA
    179            }
    180          }
    181          
    182          /*********************************************************************
    183           * @fn      osalFindTimer
    184           *
    185           * @brief   Find a timer in a timer list.
    186           *          Ints must be disabled.
    187           *
    188           * @param   task_id
    189           * @param   event_flag
    190           *
    191           * @return  osalTimerRec_t *
    192           */

   \                                 In  segment CODE, align 2
    193          osalTimerRec_t *osalFindTimer( uint8 task_id, uint16 event_flag )
   \                     osalFindTimer:
    194          {
    195            osalTimerRec_t *srchTimer;
    196          
    197            // Head of the timer list
    198            srchTimer = timerHead;
   \   000000   1F42....     MOV.W   &timerHead, R15
   \   000004   013C         JMP     ??osalFindTimer_1
    199          
    200            // Stop when found or at the end
    201            while ( srchTimer )
    202            {
    203              if ( srchTimer->event_flag == event_flag &&
    204                   srchTimer->task_id == task_id )
    205                break;
    206          
    207              // Not this one, check another
    208              srchTimer = srchTimer->next;
   \                     ??osalFindTimer_0:
   \   000006   2F4F         MOV.W   @R15, R15
   \                     ??osalFindTimer_1:
   \   000008   0F93         CMP.W   #0x0, R15
   \   00000A   0624         JEQ     ??osalFindTimer_2
   \   00000C   8F9D0400     CMP.W   R13, 0x4(R15)
   \   000010   FA23         JNE     ??osalFindTimer_0
   \   000012   CF9C0600     CMP.B   R12, 0x6(R15)
   \   000016   F723         JNE     ??osalFindTimer_0
    209            }
    210          
    211            return ( srchTimer );
   \                     ??osalFindTimer_2:
   \   000018   0C4F         MOV.W   R15, R12
   \   00001A   1001         RETA
    212          }
    213          
    214          /*********************************************************************
    215           * @fn      osalDeleteTimer
    216           *
    217           * @brief   Delete a timer from a timer list.
    218           *
    219           * @param   table
    220           * @param   rmTimer
    221           *
    222           * @return  none
    223           */

   \                                 In  segment CODE, align 2
    224          void osalDeleteTimer( osalTimerRec_t *rmTimer )
   \                     osalDeleteTimer:
    225          {
    226            // Does the timer list really exist
    227            if ( rmTimer )
   \   000000   0C93         CMP.W   #0x0, R12
   \   000002   0224         JEQ     ??osalDeleteTimer_0
    228            {
    229              // Clear the event flag and osalTimerUpdate() will delete 
    230              // the timer from the list.
    231              rmTimer->event_flag = 0;
   \   000004   8C430400     MOV.W   #0x0, 0x4(R12)
    232            }
    233          }
   \                     ??osalDeleteTimer_0:
   \   000008   1001         RETA
    234          
    235          /*********************************************************************
    236           * @fn      osal_start_timerEx
    237           *
    238           * @brief
    239           *
    240           *   This function is called to start a timer to expire in n mSecs.
    241           *   When the timer expires, the calling task will get the specified event.
    242           *
    243           * @param   uint8 taskID - task id to set timer for
    244           * @param   uint16 event_id - event to be notified with
    245           * @param   UNINT16 timeout_value - in milliseconds.
    246           *
    247           * @return  SUCCESS, or NO_TIMER_AVAIL.
    248           */

   \                                 In  segment CODE, align 2
    249          uint8 osal_start_timerEx( uint8 taskID, uint16 event_id, uint16 timeout_value )
   \                     osal_start_timerEx:
    250          {
   \   000000   0A12         PUSH.W  R10
    251            halIntState_t intState;
    252            osalTimerRec_t *newTimer;
    253          
    254            HAL_ENTER_CRITICAL_SECTION( intState );  // Hold off interrupts.
   \   000002   0A42         MOV.W   SR, R10
   \   000004   32C2         dint
   \   000006   0343         nop
    255          
    256            // Add timer
    257            newTimer = osalAddTimer( taskID, event_id, timeout_value );
   \   000008   ........     CALLA   #osalAddTimer
    258          
    259            HAL_EXIT_CRITICAL_SECTION( intState );   // Re-enable interrupts.
   \   00000C   024A         MOV.W   R10, SR
    260          
    261            return ( (newTimer != NULL) ? SUCCESS : NO_TIMER_AVAIL );
   \   00000E   0C93         CMP.W   #0x0, R12
   \   000010   0220         JNE     ??osal_start_timerEx_0
   \   000012   7C42         MOV.B   #0x8, R12
   \   000014   013C         JMP     ??osal_start_timerEx_1
   \                     ??osal_start_timerEx_0:
   \   000016   4C43         MOV.B   #0x0, R12
   \                     ??osal_start_timerEx_1:
   \   000018   3A41         POP.W   R10
   \   00001A   1001         RETA
    262          }
    263          
    264          /*********************************************************************
    265           * @fn      osal_start_reload_timer
    266           *
    267           * @brief
    268           *
    269           *   This function is called to start a timer to expire in n mSecs.
    270           *   When the timer expires, the calling task will get the specified event
    271           *   and the timer will be reloaded with the timeout value.
    272           *
    273           * @param   uint8 taskID - task id to set timer for
    274           * @param   uint16 event_id - event to be notified with
    275           * @param   UNINT16 timeout_value - in milliseconds.
    276           *
    277           * @return  SUCCESS, or NO_TIMER_AVAIL.
    278           */

   \                                 In  segment CODE, align 2
    279          uint8 osal_start_reload_timer( uint8 taskID, uint16 event_id, uint16 timeout_value )
   \                     osal_start_reload_timer:
    280          {
   \   000000   1B15         PUSHM.W #0x2, R11
   \   000002   0A4E         MOV.W   R14, R10
    281            halIntState_t intState;
    282            osalTimerRec_t *newTimer;
    283          
    284            HAL_ENTER_CRITICAL_SECTION( intState );  // Hold off interrupts.
   \   000004   0B42         MOV.W   SR, R11
   \   000006   32C2         dint
   \   000008   0343         nop
    285          
    286            // Add timer
    287            newTimer = osalAddTimer( taskID, event_id, timeout_value );
   \   00000A   0E4A         MOV.W   R10, R14
   \   00000C   ........     CALLA   #osalAddTimer
    288            if ( newTimer )
   \   000010   0C93         CMP.W   #0x0, R12
   \   000012   0224         JEQ     ??osal_start_reload_timer_0
    289            {
    290              // Load the reload timeout value
    291              newTimer->reloadTimeout = timeout_value;
   \   000014   8C4A0800     MOV.W   R10, 0x8(R12)
    292            }
    293          
    294            HAL_EXIT_CRITICAL_SECTION( intState );   // Re-enable interrupts.
   \                     ??osal_start_reload_timer_0:
   \   000018   024B         MOV.W   R11, SR
    295          
    296            return ( (newTimer != NULL) ? SUCCESS : NO_TIMER_AVAIL );
   \   00001A   0C93         CMP.W   #0x0, R12
   \   00001C   0220         JNE     ??osal_start_reload_timer_1
   \   00001E   7C42         MOV.B   #0x8, R12
   \   000020   013C         JMP     ??osal_start_reload_timer_2
   \                     ??osal_start_reload_timer_1:
   \   000022   4C43         MOV.B   #0x0, R12
   \                     ??osal_start_reload_timer_2:
   \   000024   1A17         POPM.W  #0x2, R11
   \   000026   1001         RETA
    297          }
    298          
    299          /*********************************************************************
    300           * @fn      osal_stop_timerEx
    301           *
    302           * @brief
    303           *
    304           *   This function is called to stop a timer that has already been started.
    305           *   If ZSUCCESS, the function will cancel the timer and prevent the event
    306           *   associated with the timer from being set for the calling task.
    307           *
    308           * @param   uint8 task_id - task id of timer to stop
    309           * @param   uint16 event_id - identifier of the timer that is to be stopped
    310           *
    311           * @return  SUCCESS or INVALID_EVENT_ID
    312           */

   \                                 In  segment CODE, align 2
    313          uint8 osal_stop_timerEx( uint8 task_id, uint16 event_id )
   \                     osal_stop_timerEx:
    314          {
    315            halIntState_t intState;
    316            osalTimerRec_t *foundTimer;
    317          
    318            HAL_ENTER_CRITICAL_SECTION( intState );  // Hold off interrupts.
   \   000000   0E42         MOV.W   SR, R14
   \   000002   32C2         dint
   \   000004   0343         nop
    319          
    320            // Find the timer to stop
    321            foundTimer = osalFindTimer( task_id, event_id );
   \   000006   ........     CALLA   #osalFindTimer
   \   00000A   0F4C         MOV.W   R12, R15
    322            if ( foundTimer )
   \   00000C   0C93         CMP.W   #0x0, R12
   \   00000E   0224         JEQ     ??osal_stop_timerEx_0
    323            {
    324              osalDeleteTimer( foundTimer );
   \   000010   ........     CALLA   #osalDeleteTimer
    325            }
    326          
    327            HAL_EXIT_CRITICAL_SECTION( intState );   // Re-enable interrupts.
   \                     ??osal_stop_timerEx_0:
   \   000014   024E         MOV.W   R14, SR
    328          
    329            return ( (foundTimer != NULL) ? SUCCESS : INVALID_EVENT_ID );
   \   000016   0F93         CMP.W   #0x0, R15
   \   000018   0320         JNE     ??osal_stop_timerEx_1
   \   00001A   7C400600     MOV.B   #0x6, R12
   \   00001E   1001         RETA
   \                     ??osal_stop_timerEx_1:
   \   000020   4C43         MOV.B   #0x0, R12
   \   000022   1001         RETA
    330          }
    331          
    332          /*********************************************************************
    333           * @fn      osal_get_timeoutEx
    334           *
    335           * @brief
    336           *
    337           * @param   uint8 task_id - task id of timer to check
    338           * @param   uint16 event_id - identifier of timer to be checked
    339           *
    340           * @return  Return the timer's tick count if found, zero otherwise.
    341           */

   \                                 In  segment CODE, align 2
    342          uint16 osal_get_timeoutEx( uint8 task_id, uint16 event_id )
   \                     osal_get_timeoutEx:
    343          {
   \   000000   0A12         PUSH.W  R10
    344            halIntState_t intState;
    345            uint16 rtrn = 0;
   \   000002   0E43         MOV.W   #0x0, R14
    346            osalTimerRec_t *tmr;
    347          
    348            HAL_ENTER_CRITICAL_SECTION( intState );  // Hold off interrupts.
   \   000004   0A42         MOV.W   SR, R10
   \   000006   32C2         dint
   \   000008   0343         nop
    349          
    350            tmr = osalFindTimer( task_id, event_id );
   \   00000A   ........     CALLA   #osalFindTimer
    351          
    352            if ( tmr )
   \   00000E   0C93         CMP.W   #0x0, R12
   \   000010   0224         JEQ     ??osal_get_timeoutEx_0
    353            {
    354              rtrn = tmr->timeout;
   \   000012   1E4C0200     MOV.W   0x2(R12), R14
    355            }
    356          
    357            HAL_EXIT_CRITICAL_SECTION( intState );   // Re-enable interrupts.
   \                     ??osal_get_timeoutEx_0:
   \   000016   024A         MOV.W   R10, SR
    358          
    359            return rtrn;
   \   000018   0C4E         MOV.W   R14, R12
   \   00001A   3A41         POP.W   R10
   \   00001C   1001         RETA
    360          }
    361          
    362          /*********************************************************************
    363           * @fn      osal_timer_num_active
    364           *
    365           * @brief
    366           *
    367           *   This function counts the number of active timers.
    368           *
    369           * @return  uint8 - number of timers
    370           */

   \                                 In  segment CODE, align 2
    371          uint8 osal_timer_num_active( void )
   \                     osal_timer_num_active:
    372          {
    373            halIntState_t intState;
    374            uint8 num_timers = 0;
   \   000000   4C43         MOV.B   #0x0, R12
    375            osalTimerRec_t *srchTimer;
    376          
    377            HAL_ENTER_CRITICAL_SECTION( intState );  // Hold off interrupts.
   \   000002   0F42         MOV.W   SR, R15
   \   000004   32C2         dint
   \   000006   0343         nop
    378          
    379            // Head of the timer list
    380            srchTimer = timerHead;
   \   000008   1E42....     MOV.W   &timerHead, R14
   \   00000C   023C         JMP     ??osal_timer_num_active_1
    381          
    382            // Count timers in the list
    383            while ( srchTimer != NULL )
    384            {
    385              num_timers++;
   \                     ??osal_timer_num_active_0:
   \   00000E   5C53         ADD.B   #0x1, R12
    386              srchTimer = srchTimer->next;
   \   000010   2E4E         MOV.W   @R14, R14
    387            }
   \                     ??osal_timer_num_active_1:
   \   000012   0E93         CMP.W   #0x0, R14
   \   000014   FC23         JNE     ??osal_timer_num_active_0
    388          
    389            HAL_EXIT_CRITICAL_SECTION( intState );   // Re-enable interrupts.
   \   000016   024F         MOV.W   R15, SR
    390          
    391            return num_timers;
   \   000018   1001         RETA
    392          }
    393          
    394          /*********************************************************************
    395           * @fn      osalTimerUpdate
    396           *
    397           * @brief   Update the timer structures for a timer tick.
    398           *
    399           * @param   none
    400           *
    401           * @return  none
    402           *********************************************************************/

   \                                 In  segment CODE, align 2
    403          void osalTimerUpdate( uint16 updateTime )
   \                     osalTimerUpdate:
    404          {
   \   000000   5B15         PUSHM.W #0x6, R11
   \   000002   0A4C         MOV.W   R12, R10
    405            halIntState_t intState;
    406            osalTimerRec_t *srchTimer;
    407            osalTimerRec_t *prevTimer;
    408          
    409            HAL_ENTER_CRITICAL_SECTION( intState );  // Hold off interrupts.
   \   000004   0B42         MOV.W   SR, R11
   \   000006   32C2         dint
   \   000008   0343         nop
    410            // Update the system time
    411            osal_systemClock += updateTime;
   \   00000A   0E4A         MOV.W   R10, R14
   \   00000C   0F43         MOV.W   #0x0, R15
   \   00000E   825A....     ADD.W   R10, &osal_systemClock
   \   000012   8263....     ADDC.W  #0x0, &osal_systemClock + 2
    412            HAL_EXIT_CRITICAL_SECTION( intState );   // Re-enable interrupts.
   \   000016   024B         MOV.W   R11, SR
    413          
    414            // Look for open timer slot
    415            if ( timerHead != NULL )
   \   000018   1842....     MOV.W   &timerHead, R8
   \   00001C   0893         CMP.W   #0x0, R8
   \   00001E   4124         JEQ     ??osalTimerUpdate_1
    416            {
    417              // Add it to the end of the timer list
    418              srchTimer = timerHead;
    419              prevTimer = (void *)NULL;
   \   000020   0943         MOV.W   #0x0, R9
    420          
    421              // Look for open timer slot
    422              while ( srchTimer )
    423              {
    424                osalTimerRec_t *freeTimer = NULL;
   \                     ??osalTimerUpdate_0:
   \   000022   0643         MOV.W   #0x0, R6
    425               
    426                HAL_ENTER_CRITICAL_SECTION( intState );  // Hold off interrupts.
   \   000024   0B42         MOV.W   SR, R11
   \   000026   32C2         dint
   \   000028   0343         nop
    427                
    428                if (srchTimer->timeout <= updateTime)
   \   00002A   1F480200     MOV.W   0x2(R8), R15
   \   00002E   0A9F         CMP.W   R15, R10
   \   000030   0228         JNC     ??osalTimerUpdate_2
    429                {
    430                  srchTimer->timeout = 0;
   \   000032   0F43         MOV.W   #0x0, R15
   \   000034   013C         JMP     ??osalTimerUpdate_3
    431                }
    432                else
    433                {
    434                  srchTimer->timeout = srchTimer->timeout - updateTime;
   \                     ??osalTimerUpdate_2:
   \   000036   0F8A         SUB.W   R10, R15
   \                     ??osalTimerUpdate_3:
   \   000038   884F0200     MOV.W   R15, 0x2(R8)
    435                }
    436                
    437                // Check for reloading
    438                if ( (srchTimer->timeout == 0) && (srchTimer->reloadTimeout) && (srchTimer->event_flag) )
   \   00003C   0F93         CMP.W   #0x0, R15
   \   00003E   0E20         JNE     ??osalTimerUpdate_4
   \   000040   88930800     CMP.W   #0x0, 0x8(R8)
   \   000044   1124         JEQ     ??osalTimerUpdate_5
   \   000046   1D480400     MOV.W   0x4(R8), R13
   \   00004A   0D93         CMP.W   #0x0, R13
   \   00004C   0D24         JEQ     ??osalTimerUpdate_5
    439                {
    440                  // Notify the task of a timeout
    441                  osal_set_event( srchTimer->task_id, srchTimer->event_flag );
   \   00004E   5C480600     MOV.B   0x6(R8), R12
   \   000052   ........     CALLA   #osal_set_event
    442                  
    443                  // Reload the timer timeout value
    444                  srchTimer->timeout = srchTimer->reloadTimeout;
   \   000056   984808000200 MOV.W   0x8(R8), 0x2(R8)
    445                }
    446                
    447                // When timeout or delete (event_flag == 0)
    448                if ( srchTimer->timeout == 0 || srchTimer->event_flag == 0 )
   \                     ??osalTimerUpdate_4:
   \   00005C   88930200     CMP.W   #0x0, 0x2(R8)
   \   000060   0324         JEQ     ??osalTimerUpdate_5
   \   000062   88930400     CMP.W   #0x0, 0x4(R8)
   \   000066   0A20         JNE     ??osalTimerUpdate_6
    449                {
    450                  // Take out of list
    451                  if ( prevTimer == NULL )
   \                     ??osalTimerUpdate_5:
   \   000068   2F48         MOV.W   @R8, R15
   \   00006A   0993         CMP.W   #0x0, R9
   \   00006C   0320         JNE     ??osalTimerUpdate_7
    452                    timerHead = srchTimer->next;
   \   00006E   824F....     MOV.W   R15, &timerHead
   \   000072   023C         JMP     ??osalTimerUpdate_8
    453                  else
    454                    prevTimer->next = srchTimer->next;
   \                     ??osalTimerUpdate_7:
   \   000074   894F0000     MOV.W   R15, 0(R9)
    455          
    456                  // Setup to free memory
    457                  freeTimer = srchTimer;
   \                     ??osalTimerUpdate_8:
   \   000078   0648         MOV.W   R8, R6
    458          
    459                  // Next
    460                  srchTimer = srchTimer->next;
   \   00007A   013C         JMP     ??osalTimerUpdate_9
    461                }
    462                else
    463                {
    464                  // Get next
    465                  prevTimer = srchTimer;
   \                     ??osalTimerUpdate_6:
   \   00007C   0948         MOV.W   R8, R9
    466                  srchTimer = srchTimer->next;
   \                     ??osalTimerUpdate_9:
   \   00007E   2848         MOV.W   @R8, R8
    467                }
    468                
    469                HAL_EXIT_CRITICAL_SECTION( intState );   // Re-enable interrupts.
   \   000080   024B         MOV.W   R11, SR
    470                
    471                if ( freeTimer )
   \   000082   0693         CMP.W   #0x0, R6
   \   000084   0C24         JEQ     ??osalTimerUpdate_10
    472                {
    473                  if ( freeTimer->timeout == 0 )
   \   000086   86930200     CMP.W   #0x0, 0x2(R6)
   \   00008A   0620         JNE     ??osalTimerUpdate_11
    474                  {
    475                    osal_set_event( freeTimer->task_id, freeTimer->event_flag );
   \   00008C   1D460400     MOV.W   0x4(R6), R13
   \   000090   5C460600     MOV.B   0x6(R6), R12
   \   000094   ........     CALLA   #osal_set_event
    476                  }
    477                  osal_mem_free( freeTimer );
   \                     ??osalTimerUpdate_11:
   \   000098   0C46         MOV.W   R6, R12
   \   00009A   ........     CALLA   #osal_mem_free
    478                }
    479              }
   \                     ??osalTimerUpdate_10:
   \   00009E   0893         CMP.W   #0x0, R8
   \   0000A0   C023         JNE     ??osalTimerUpdate_0
    480            }
    481          }
   \                     ??osalTimerUpdate_1:
   \   0000A2   5617         POPM.W  #0x6, R11
   \   0000A4   1001         RETA
    482          
    483          #ifdef POWER_SAVING
    484          /*********************************************************************
    485           * @fn      osal_adjust_timers
    486           *
    487           * @brief   Update the timer structures for elapsed ticks.
    488           *
    489           * @param   none
    490           *
    491           * @return  none
    492           *********************************************************************/
    493          void osal_adjust_timers( void )
    494          {
    495            uint16 eTime;
    496          
    497            if ( timerHead != NULL )
    498            {
    499              // Compute elapsed time (msec)
    500              eTime = TimerElapsed() /  TICK_COUNT;
    501          
    502              if ( eTime )
    503                osalTimerUpdate( eTime );
    504            }
    505          }
    506          
    507          /*********************************************************************
    508           * @fn      osal_next_timeout
    509           *
    510           * @brief
    511           *
    512           *   Search timer table to return the lowest timeout value. If the
    513           *   timer list is empty, then the returned timeout will be zero.
    514           *
    515           * @param   none
    516           *
    517           * @return  none
    518           *********************************************************************/
    519          uint16 osal_next_timeout( void )
    520          {
    521            uint16 nextTimeout;
    522            osalTimerRec_t *srchTimer;
    523          
    524            if ( timerHead != NULL )
    525            {
    526              // Head of the timer list
    527              srchTimer = timerHead;
    528              nextTimeout = OSAL_TIMERS_MAX_TIMEOUT;
    529          
    530              // Look for the next timeout timer
    531              while ( srchTimer != NULL )
    532              {
    533                if (srchTimer->timeout < nextTimeout)
    534                {
    535                  nextTimeout = srchTimer->timeout;
    536                }
    537                // Check next timer
    538                srchTimer = srchTimer->next;
    539              }
    540            }
    541            else
    542            {
    543              // No timers
    544              nextTimeout = 0;
    545            }
    546          
    547            return ( nextTimeout );
    548          }
    549          #endif // POWER_SAVING
    550          
    551          /*********************************************************************
    552           * @fn      osal_GetSystemClock()
    553           *
    554           * @brief   Read the local system clock.
    555           *
    556           * @param   none
    557           *
    558           * @return  local clock in milliseconds
    559           */

   \                                 In  segment CODE, align 2
    560          uint32 osal_GetSystemClock( void )
   \                     osal_GetSystemClock:
    561          {
    562            return ( osal_systemClock );
   \   000000   1C42....     MOV.W   &osal_systemClock, R12
   \   000004   1D42....     MOV.W   &osal_systemClock + 2, R13
   \   000008   1001         RETA
    563          }
    564          
    565          /*********************************************************************
    566          *********************************************************************/

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      12  osalAddTimer
            12 -> osalFindTimer
            12 -> osal_mem_alloc
       4  osalDeleteTimer
       4  osalFindTimer
       4  osalTimerInit
      16  osalTimerUpdate
            16 -> osal_mem_free
            16 -> osal_set_event
       4  osal_GetSystemClock
       6  osal_get_timeoutEx
             6 -> osalFindTimer
       8  osal_start_reload_timer
             8 -> osalAddTimer
       6  osal_start_timerEx
             6 -> osalAddTimer
       4  osal_stop_timerEx
             4 -> osalDeleteTimer
             4 -> osalFindTimer
       4  osal_timer_num_active


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      88  osalAddTimer
      10  osalDeleteTimer
      28  osalFindTimer
      10  osalTimerInit
     166  osalTimerUpdate
      10  osal_GetSystemClock
      30  osal_get_timeoutEx
      40  osal_start_reload_timer
      28  osal_start_timerEx
      36  osal_stop_timerEx
       4  osal_systemClock
      26  osal_timer_num_active
       2  timerHead

 
 472 bytes in segment CODE
   6 bytes in segment DATA16_Z
 
 472 bytes of CODE memory
   6 bytes of DATA memory

Errors: none
Warnings: none
