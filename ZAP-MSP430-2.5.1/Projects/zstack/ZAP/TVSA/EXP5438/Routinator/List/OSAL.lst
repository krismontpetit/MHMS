###############################################################################
#                                                                             #
# IAR C/C++ Compiler V5.51.2.50607/W32 for MSP430       26/Apr/2013  14:00:05 #
# Copyright 1996-2012 IAR Systems AB.                                         #
#                                                                             #
#    __rt_version  =  3                                                       #
#    __double_size =  32                                                      #
#    __reg_r4      =  free                                                    #
#    __reg_r5      =  free                                                    #
#    __pic         =  no                                                      #
#    __core        =  430X                                                    #
#    __data_model  =  small                                                   #
#    Source file   =  C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Components\osal\common\OSAL.c                          #
#    Command line  =  -f C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2. #
#                     5.1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\Source\zap.c #
#                     fg (-DTVSA_DEVICE_ID=0x0016 -DTVSA_DONGLE=1             #
#                     -DHAL_UART=1 -DZAP_PHY_SPI=1                            #
#                     -DZAP_PHY_UART=!ZAP_PHY_SPI -DZAP_PHY_RESET_ZNP=TRUE    #
#                     -DZAP_ZNP_MT=FALSE -DZAP_APP_MSG=FALSE                  #
#                     -DZAP_SBL_PROXY=FALSE -DZAP_AUTO_CFG=TRUE               #
#                     -DZAP_AUTO_START=TRUE -DZAP_NV_RESTORE=FALSE            #
#                     -DLCD_SUPPORTED -DZAP_AF_DATA_REQ_FRAG=FALSE            #
#                     -DZAP_AF_DATA_REQ_AREQ=!ZAP_AF_DATA_REQ_FRAG            #
#                     -DZAP_ZDO_STARTUP_AREQ=TRUE -DZAP_AF_FUNC               #
#                     -DZAP_SAPI_FUNC -DZAP_SYS_FUNC -DZAP_UTIL_FUNC          #
#                     -DZAP_ZDO_FUNC -DSECURE=0 -DZG_SECURE_DYNAMIC=0         #
#                     "-DDEFAULT_CHANLIST=(uint32)0x00000800"                 #
#                     -DZDAPP_CONFIG_PAN_ID=0xFFFF -DPOLL_RATE=1000           #
#                     -DNWK_START_DELAY=100 -DMAX_BINDING_CLUSTER_IDS=4)      #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Components\osal\common\OSAL.c -lC                      #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\Routinator\List\ -lA  #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\Routinator\List\      #
#                     --remarks --diag_suppress Pe001,Pe193,Pe236,Pe826 -o    #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\Routinator\Obj\       #
#                     --debug -D__MSP430F5438A__ -e --double=32 --clib -I     #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\ -I                   #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\Source\ -I         #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\Source\ -I      #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\hal\target\MSP5438ZAP\ -I                          #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\hal\include\ -I C:\Users\student\Documents\GitHub\ #
#                     MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\ #
#                     ..\..\..\..\..\Components\mac\include\ -I               #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\mt\ -I C:\Users\student\Documents\GitHub\MHMS\ZAP- #
#                     MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\ #
#                     ..\..\Components\osal\include\ -I                       #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\osal\mcu\msp430\ -I C:\Users\student\Documents\Git #
#                     Hub\MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5 #
#                     438\..\..\..\..\..\Components\services\saddr\ -I        #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\services\sdata\ -I C:\Users\student\Documents\GitH #
#                     ub\MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP54 #
#                     38\..\..\..\..\..\Components\stack\af\ -I               #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\stack\nwk\ -I C:\Users\student\Documents\GitHub\MH #
#                     MS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\.. #
#                     \..\..\..\..\Components\stack\sapi\ -I                  #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\stack\sec\ -I C:\Users\student\Documents\GitHub\MH #
#                     MS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\.. #
#                     \..\..\..\..\Components\stack\sys\ -I                   #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\stack\zdo\ -I C:\Users\student\Documents\GitHub\MH #
#                     MS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\.. #
#                     \..\..\..\..\Components\zmac\ -I                        #
#                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Compon #
#                     ents\zmac\f8w\ --core=430X --data_model=small -Ohz      #
#                     --multiplier=32 --multiplier_location=4C0               #
#                     --require_prototypes --hw_workaround=CPU40              #
#                     --hw_workaround=CPU42                                   #
#    List file     =  C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\Routinator\List\OSAL. #
#                     lst                                                     #
#    Object file   =  C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1 #
#                     \Projects\zstack\ZAP\TVSA\EXP5438\Routinator\Obj\OSAL.r #
#                     43                                                      #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1\Components\osal\common\OSAL.c
      1          /**************************************************************************************************
      2            Filename:       OSAL.c
      3            Revised:        $Date: 2011-05-27 09:03:48 -0700 (Fri, 27 May 2011) $
      4            Revision:       $Revision: 26134 $
      5          
      6            Description:    This API allows the software components in the Z-stack to be written
      7                            independently of the specifics of the operating system, kernel or tasking
      8                            environment (including control loops or connect-to-interrupt systems).
      9          
     10          
     11            Copyright 2004-2011 Texas Instruments Incorporated. All rights reserved.
     12          
     13            IMPORTANT: Your use of this Software is limited to those specific rights
     14            granted under the terms of a software license agreement between the user
     15            who downloaded the software, his/her employer (which must be your employer)
     16            and Texas Instruments Incorporated (the "License"). You may not use this
     17            Software unless you agree to abide by the terms of the License. The License
     18            limits your use, and you acknowledge, that the Software may not be modified,
     19            copied or distributed unless embedded on a Texas Instruments microcontroller
     20            or used solely and exclusively in conjunction with a Texas Instruments radio
     21            frequency transceiver, which is integrated into your product. Other than for
     22            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     23            works of, modify, distribute, perform, display or sell this Software and/or
     24            its documentation for any purpose.
     25          
     26            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     27            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     28            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     29            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     30            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     31            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     32            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     33            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     34            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     35            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     36            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     37          
     38            Should you have any questions regarding your right to use this Software,
     39            contact Texas Instruments Incorporated at www.TI.com.
     40          **************************************************************************************************/
     41          
     42          /*********************************************************************
     43           * INCLUDES
     44           */
     45          
     46          #include <string.h>
     47          
     48          #include "comdef.h"
     49          #include "OSAL.h"
     50          #include "OSAL_Tasks.h"
     51          #include "OSAL_Memory.h"
     52          #include "OSAL_PwrMgr.h"
     53          #include "OSAL_Clock.h"
     54          
     55          #include "OnBoard.h"
     56          
     57          /* HAL */
     58          #include "hal_drivers.h"
     59          
     60          #ifdef IAR_ARMCM3_LM
     61            #include "FreeRTOSConfig.h"
     62            #include "osal_task.h"
     63          #endif
     64          
     65          /*********************************************************************
     66           * MACROS
     67           */
     68          
     69          /*********************************************************************
     70           * CONSTANTS
     71           */
     72          
     73          /*********************************************************************
     74           * TYPEDEFS
     75           */
     76          
     77          /*********************************************************************
     78           * GLOBAL VARIABLES
     79           */
     80          
     81          // Message Pool Definitions

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     82          osal_msg_q_t osal_qHead;
   \                     osal_qHead:
   \   000000                DS8 2
     83          
     84          /*********************************************************************
     85           * EXTERNAL VARIABLES
     86           */
     87          
     88          /*********************************************************************
     89           * EXTERNAL FUNCTIONS
     90           */
     91          
     92          /*********************************************************************
     93           * LOCAL VARIABLES
     94           */
     95          
     96          // Index of active task

   \                                 In  segment DATA16_I, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
     97          static uint8 activeTaskID = TASK_NO_TASK;
   \                     activeTaskID:
   \   000000                DS8 1
   \   000001                REQUIRE `?<Initializer for activeTaskID>`
     98          
     99          /*********************************************************************
    100           * LOCAL FUNCTION PROTOTYPES
    101           */
    102          
    103          /*********************************************************************
    104           * HELPER FUNCTIONS
    105           */
    106          /* very ugly stub so Keil can compile */
    107          #ifdef __KEIL__
    108          char *  itoa ( int value, char * buffer, int radix )
    109          {
    110            return(buffer);
    111          }
    112          #endif
    113          
    114          /*********************************************************************
    115           * @fn      osal_strlen
    116           *
    117           * @brief
    118           *
    119           *   Calculates the length of a string.  The string must be null
    120           *   terminated.
    121           *
    122           * @param   char *pString - pointer to text string
    123           *
    124           * @return  int - number of characters
    125           */

   \                                 In  segment CODE, align 2
    126          int osal_strlen( char *pString )
   \                     osal_strlen:
    127          {
    128            return (int)( strlen( pString ) );
   \   000000   ........     BRA     #strlen
    129          }
    130          
    131          /*********************************************************************
    132           * @fn      osal_memcpy
    133           *
    134           * @brief
    135           *
    136           *   Generic memory copy.
    137           *
    138           *   Note: This function differs from the standard memcpy(), since
    139           *         it returns the pointer to the next destination uint8. The
    140           *         standard memcpy() returns the original destination address.
    141           *
    142           * @param   dst - destination address
    143           * @param   src - source address
    144           * @param   len - number of bytes to copy
    145           *
    146           * @return  pointer to end of destination buffer
    147           */

   \                                 In  segment CODE, align 2
    148          void *osal_memcpy( void *dst, const void GENERIC *src, unsigned int len )
   \                     osal_memcpy:
    149          {
    150            uint8 *pDst;
    151            const uint8 GENERIC *pSrc;
    152          
    153            pSrc = src;
    154            pDst = dst;
   \   000000   033C         JMP     ??osal_memcpy_1
    155          
    156            while ( len-- )
    157              *pDst++ = *pSrc++;
   \                     ??osal_memcpy_0:
   \   000002   FC4D0000     MOV.B   @R13+, 0(R12)
   \   000006   1C53         ADD.W   #0x1, R12
   \                     ??osal_memcpy_1:
   \   000008   0F4E         MOV.W   R14, R15
   \   00000A   3E53         ADD.W   #0xffff, R14
   \   00000C   0F93         CMP.W   #0x0, R15
   \   00000E   F923         JNE     ??osal_memcpy_0
    158          
    159            return ( pDst );
   \   000010   1001         RETA
    160          }
    161          
    162          /*********************************************************************
    163           * @fn      osal_revmemcpy
    164           *
    165           * @brief   Generic reverse memory copy.  Starts at the end of the
    166           *   source buffer, by taking the source address pointer and moving
    167           *   pointer ahead "len" bytes, then decrementing the pointer.
    168           *
    169           *   Note: This function differs from the standard memcpy(), since
    170           *         it returns the pointer to the next destination uint8. The
    171           *         standard memcpy() returns the original destination address.
    172           *
    173           * @param   dst - destination address
    174           * @param   src - source address
    175           * @param   len - number of bytes to copy
    176           *
    177           * @return  pointer to end of destination buffer
    178           */

   \                                 In  segment CODE, align 2
    179          void *osal_revmemcpy( void *dst, const void GENERIC *src, unsigned int len )
   \                     osal_revmemcpy:
    180          {
    181            uint8 *pDst;
    182            const uint8 GENERIC *pSrc;
    183          
    184            pSrc = src;
    185            pSrc += (len-1);
   \   000000   0D5E         ADD.W   R14, R13
   \   000002   3D53         ADD.W   #0xffff, R13
    186            pDst = dst;
   \   000004   043C         JMP     ??osal_revmemcpy_1
    187          
    188            while ( len-- )
    189              *pDst++ = *pSrc--;
   \                     ??osal_revmemcpy_0:
   \   000006   EC4D0000     MOV.B   @R13, 0(R12)
   \   00000A   3D53         ADD.W   #0xffff, R13
   \   00000C   1C53         ADD.W   #0x1, R12
   \                     ??osal_revmemcpy_1:
   \   00000E   0F4E         MOV.W   R14, R15
   \   000010   3E53         ADD.W   #0xffff, R14
   \   000012   0F93         CMP.W   #0x0, R15
   \   000014   F823         JNE     ??osal_revmemcpy_0
    190          
    191            return ( pDst );
   \   000016   1001         RETA
    192          }
    193          
    194          /*********************************************************************
    195           * @fn      osal_memdup
    196           *
    197           * @brief   Allocates a buffer [with osal_mem_alloc()] and copies
    198           *          the src buffer into the newly allocated space.
    199           *
    200           * @param   src - source address
    201           * @param   len - number of bytes to copy
    202           *
    203           * @return  pointer to the new allocated buffer, or NULL if
    204           *          allocation problem.
    205           */

   \                                 In  segment CODE, align 2
    206          void *osal_memdup( const void GENERIC *src, unsigned int len )
   \                     osal_memdup:
    207          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   0A4C         MOV.W   R12, R10
   \   000004   0B4D         MOV.W   R13, R11
    208            uint8 *pDst;
    209          
    210            pDst = osal_mem_alloc( len );
   \   000006   0C4D         MOV.W   R13, R12
   \   000008   ........     CALLA   #osal_mem_alloc
   \   00000C   084C         MOV.W   R12, R8
    211            if ( pDst )
   \   00000E   0C93         CMP.W   #0x0, R12
   \   000010   0424         JEQ     ??osal_memdup_0
    212            {
    213              VOID osal_memcpy( pDst, src, len );
   \   000012   0E4B         MOV.W   R11, R14
   \   000014   0D4A         MOV.W   R10, R13
   \   000016   ........     CALLA   #osal_memcpy
    214            }
    215          
    216            return ( (void *)pDst );
   \                     ??osal_memdup_0:
   \   00001A   0C48         MOV.W   R8, R12
   \   00001C   3817         POPM.W  #0x4, R11
   \   00001E   1001         RETA
    217          }
    218          
    219          /*********************************************************************
    220           * @fn      osal_memcmp
    221           *
    222           * @brief
    223           *
    224           *   Generic memory compare.
    225           *
    226           * @param   src1 - source 1 addrexx
    227           * @param   src2 - source 2 address
    228           * @param   len - number of bytes to compare
    229           *
    230           * @return  TRUE - same, FALSE - different
    231           */

   \                                 In  segment CODE, align 2
    232          uint8 osal_memcmp( const void GENERIC *src1, const void GENERIC *src2, unsigned int len )
   \                     osal_memcmp:
   \                     ??osal_memcmp_0:
    233          {
    234            const uint8 GENERIC *pSrc1;
    235            const uint8 GENERIC *pSrc2;
    236          
    237            pSrc1 = src1;
    238            pSrc2 = src2;
    239          
    240            while ( len-- )
   \   000000   0F4E         MOV.W   R14, R15
   \   000002   3E53         ADD.W   #0xffff, R14
   \   000004   0F93         CMP.W   #0x0, R15
   \   000006   0524         JEQ     ??osal_memcmp_1
    241            {
    242              if( *pSrc1++ != *pSrc2++ )
   \   000008   7F4C         MOV.B   @R12+, R15
   \   00000A   7F9D         CMP.B   @R13+, R15
   \   00000C   F927         JEQ     ??osal_memcmp_0
    243                return FALSE;
   \   00000E   4C43         MOV.B   #0x0, R12
   \   000010   1001         RETA
    244            }
    245            return TRUE;
   \                     ??osal_memcmp_1:
   \   000012   5C43         MOV.B   #0x1, R12
   \   000014   1001         RETA
    246          }
    247          
    248          
    249          /*********************************************************************
    250           * @fn      osal_memset
    251           *
    252           * @brief
    253           *
    254           *   Set memory buffer to value.
    255           *
    256           * @param   dest - pointer to buffer
    257           * @param   value - what to set each uint8 of the message
    258           * @param   size - how big
    259           *
    260           * @return  pointer to destination buffer
    261           */

   \                                 In  segment CODE, align 2
    262          void *osal_memset( void *dest, uint8 value, int len )
   \                     osal_memset:
    263          {
    264            return memset( dest, value, len );
   \   000000   4D4D         MOV.B   R13, R13
   \   000002   ........     BRA     #memset
    265          }
    266          
    267          /*********************************************************************
    268           * @fn      osal_build_uint16
    269           *
    270           * @brief
    271           *
    272           *   Build a uint16 out of 2 bytes (0 then 1).
    273           *
    274           * @param   swapped - 0 then 1
    275           *
    276           * @return  uint16
    277           */

   \                                 In  segment CODE, align 2
    278          uint16 osal_build_uint16( uint8 *swapped )
   \                     osal_build_uint16:
    279          {
    280            return ( BUILD_UINT16( swapped[0], swapped[1] ) );
   \   000000   6F4C         MOV.B   @R12, R15
   \   000002   5E4C0100     MOV.B   0x1(R12), R14
   \   000006                RPT     #0x8
   \   000006   47180E5E     RLAX.W  R14
   \   00000A   0F5E         ADD.W   R14, R15
   \   00000C   0C4F         MOV.W   R15, R12
   \   00000E   1001         RETA
    281          }
    282          
    283          /*********************************************************************
    284           * @fn      osal_build_uint32
    285           *
    286           * @brief
    287           *
    288           *   Build a uint32 out of sequential bytes.
    289           *
    290           * @param   swapped - sequential bytes
    291           * @param   len - number of bytes in the uint8 array
    292           *
    293           * @return  uint32
    294           */

   \                                 In  segment CODE, align 2
    295          uint32 osal_build_uint32( uint8 *swapped, uint8 len )
   \                     osal_build_uint32:
    296          {
   \   000000   1B15         PUSHM.W #0x2, R11
   \   000002   0F4C         MOV.W   R12, R15
    297            if ( len == 2 )
   \   000004   6A4C         MOV.B   @R12, R10
   \   000006   0B43         MOV.W   #0x0, R11
   \   000008   6D93         CMP.B   #0x2, R13
   \   00000A   0520         JNE     ??osal_build_uint32_0
    298              return ( BUILD_UINT32( swapped[0], swapped[1], 0L, 0L ) );
   \   00000C   ........     CALLA   #?Subroutine11
   \                     ??CrossCallReturnLabel_10:
   \   000010   0C4A         MOV.W   R10, R12
   \   000012   0D63         ADDC.W  #0x0, R13
   \   000014   193C         JMP     ??osal_build_uint32_1
    299            else if ( len == 3 )
   \                     ??osal_build_uint32_0:
   \   000016   7D900300     CMP.B   #0x3, R13
   \   00001A   0520         JNE     ??osal_build_uint32_2
    300              return ( BUILD_UINT32( swapped[0], swapped[1], swapped[2], 0L ) );
   \   00001C   ........     CALLA   #?Subroutine9
   \                     ??CrossCallReturnLabel_8:
   \   000020   5F4F0200     MOV.B   0x2(R15), R15
   \   000024   0B3C         JMP     ??osal_build_uint32_3
    301            else if ( len == 4 )
   \                     ??osal_build_uint32_2:
   \   000026   6D92         CMP.B   #0x4, R13
   \   000028   0D20         JNE     ??osal_build_uint32_4
    302              return ( BUILD_UINT32( swapped[0], swapped[1], swapped[2], swapped[3] ) );
   \   00002A   ........     CALLA   #?Subroutine9
   \                     ??CrossCallReturnLabel_9:
   \   00002E   5D4F0200     MOV.B   0x2(R15), R13
   \   000032   0B5D         ADD.W   R13, R11
   \   000034   5F4F0300     MOV.B   0x3(R15), R15
   \   000038                RPT     #0x8
   \   000038   47180F5F     RLAX.W  R15
   \                     ??osal_build_uint32_3:
   \   00003C   0B5F         ADD.W   R15, R11
   \   00003E   0C4A         MOV.W   R10, R12
   \   000040   0D4B         MOV.W   R11, R13
   \   000042   023C         JMP     ??osal_build_uint32_1
    303            else
    304              return ( (uint32)swapped[0] );
   \                     ??osal_build_uint32_4:
   \   000044   0C4A         MOV.W   R10, R12
   \   000046   0D43         MOV.W   #0x0, R13
   \                     ??osal_build_uint32_1:
   \   000048   1A17         POPM.W  #0x2, R11
   \   00004A   1001         RETA
    305          }

   \                                 In  segment CODE, align 2
   \                     ?Subroutine9:
   \   000000   ........     CALLA   #?Subroutine11
   \                     ??CrossCallReturnLabel_11:
   \   000004   0B6D         ADDC.W  R13, R11
   \   000006   1001         RETA

   \                                 In  segment CODE, align 2
   \                     ?Subroutine11:
   \   000000   5C4F0100     MOV.B   0x1(R15), R12
   \   000004   0D43         MOV.W   #0x0, R13
   \   000006   ........     CALLA   #?ShiftLeft32_8
   \   00000A   0A5C         ADD.W   R12, R10
   \   00000C   1001         RETA
    306          
    307          #if !defined ( ZBIT ) && !defined ( ZBIT2 ) && !defined (UBIT)
    308          /*********************************************************************
    309           * @fn      _ltoa
    310           *
    311           * @brief
    312           *
    313           *   convert a long unsigned int to a string.
    314           *
    315           * @param  l - long to convert
    316           * @param  buf - buffer to convert to
    317           * @param  radix - 10 dec, 16 hex
    318           *
    319           * @return  pointer to buffer
    320           */

   \                                 In  segment CODE, align 2
    321          unsigned char * _ltoa(unsigned long l, unsigned char *buf, unsigned char radix)
   \                     _ltoa:
    322          {
   \   000000   7B15         PUSHM.W #0x8, R11
   \   000002   31801E00     SUB.W   #0x1e, SP
   \   000006   0A4C         MOV.W   R12, R10
   \   000008   0B4D         MOV.W   R13, R11
   \   00000A   094E         MOV.W   R14, R9
    323          #if defined( __GNUC__ )
    324            return ( (char*)ltoa( l, buf, radix ) );
    325          #else
    326            unsigned char tmp1[10] = "", tmp2[10] = "", tmp3[10] = "";
   \   00000C   0C41         MOV.W   SP, R12
   \   00000E   3C501400     ADD.W   #0x14, R12
   \   000012   ........     CALLA   #?Subroutine7
   \                     ??CrossCallReturnLabel_5:
   \   000016   0C41         MOV.W   SP, R12
   \   000018   3C500A00     ADD.W   #0xa, R12
   \   00001C   ........     CALLA   #?Subroutine7
   \                     ??CrossCallReturnLabel_6:
   \   000020   0C41         MOV.W   SP, R12
   \   000022   0C53         ADD.W   #0x0, R12
   \   000024   ........     CALLA   #?Subroutine7
    327            unsigned short num1, num2, num3;
    328            unsigned char i;
    329          
    330            buf[0] = '\0';
   \                     ??CrossCallReturnLabel_7:
   \   000028   C9430000     MOV.B   #0x0, 0(R9)
   \   00002C   75400A00     MOV.B   #0xa, R5
   \   000030   0441         MOV.W   SP, R4
   \   000032   34500A00     ADD.W   #0xa, R4
   \   000036   0741         MOV.W   SP, R7
   \   000038   37501400     ADD.W   #0x14, R7
   \   00003C   4F95         CMP.B   R5, R15
   \   00003E   5820         JNE     ??_ltoa_5
    331          
    332            if ( radix == 10 )
    333            {
    334              num1 = l % 10000;
   \   000040   0C4A         MOV.W   R10, R12
   \   000042   ........     CALLA   #?Subroutine6
   \                     ??CrossCallReturnLabel_2:
   \   000046   064E         MOV.W   R14, R6
    335              num2 = (l / 10000) % 10000;
   \   000048   0C4A         MOV.W   R10, R12
   \   00004A   0D4B         MOV.W   R11, R13
   \   00004C   ........     CALLA   #?Subroutine6
   \                     ??CrossCallReturnLabel_3:
   \   000050   ........     CALLA   #?Subroutine6
   \                     ??CrossCallReturnLabel_4:
   \   000054   084E         MOV.W   R14, R8
    336              num3 = (unsigned short)(l / 100000000);
   \   000056   0C4A         MOV.W   R10, R12
   \   000058   0D4B         MOV.W   R11, R13
   \   00005A   3E4000E1     MOV.W   #0xe100, R14
   \   00005E   3F40F505     MOV.W   #0x5f5, R15
   \   000062   ........     CALLA   #?DivMod32u
   \   000066   0B4C         MOV.W   R12, R11
    337          
    338              if (num3) _itoa(num3, tmp3, 10);
   \   000068   0C93         CMP.W   #0x0, R12
   \   00006A   0524         JEQ     ??_ltoa_6
   \   00006C   4E45         MOV.B   R5, R14
   \   00006E   0D41         MOV.W   SP, R13
   \   000070   0D53         ADD.W   #0x0, R13
   \   000072   ........     CALLA   #_itoa
    339              if (num2) _itoa(num2, tmp2, 10);
   \                     ??_ltoa_6:
   \   000076   0893         CMP.W   #0x0, R8
   \   000078   0524         JEQ     ??_ltoa_7
   \   00007A   4E45         MOV.B   R5, R14
   \   00007C   0D44         MOV.W   R4, R13
   \   00007E   0C48         MOV.W   R8, R12
   \   000080   ........     CALLA   #_itoa
    340              if (num1) _itoa(num1, tmp1, 10);
   \                     ??_ltoa_7:
   \   000084   0693         CMP.W   #0x0, R6
   \   000086   0524         JEQ     ??_ltoa_8
   \   000088   4E45         MOV.B   R5, R14
   \   00008A   0D47         MOV.W   R7, R13
   \   00008C   0C46         MOV.W   R6, R12
   \   00008E   ........     CALLA   #_itoa
    341          
    342              if (num3)
   \                     ??_ltoa_8:
   \   000092   0B93         CMP.W   #0x0, R11
   \   000094   1024         JEQ     ??_ltoa_9
    343              {
    344                strcpy((char*)buf, (char const*)tmp3);
   \   000096   0D41         MOV.W   SP, R13
   \   000098   0D53         ADD.W   #0x0, R13
   \   00009A   0C49         MOV.W   R9, R12
   \   00009C   ........     CALLA   #strcpy
    345                for (i = 0; i < 4 - strlen((char const*)tmp2); i++)
   \   0000A0   4A43         MOV.B   #0x0, R10
   \   0000A2   023C         JMP     ??_ltoa_10
    346                  strcat((char*)buf, "0");
   \                     ??_ltoa_0:
   \   0000A4   ........     CALLA   #?Subroutine8
   \                     ??_ltoa_10:
   \   0000A8   2542         MOV.W   #0x4, R5
   \   0000AA   0C44         MOV.W   R4, R12
   \   0000AC   ........     CALLA   #strlen
   \   0000B0   058C         SUB.W   R12, R5
   \   0000B2   0A95         CMP.W   R5, R10
   \   0000B4   F72B         JNC     ??_ltoa_0
    347              }
    348              strcat((char*)buf, (char const*)tmp2);
   \                     ??_ltoa_9:
   \   0000B6   0D44         MOV.W   R4, R13
   \   0000B8   ........     CALLA   #??Subroutine12_0
    349              if (num3 || num2)
   \                     ??CrossCallReturnLabel_12:
   \   0000BC   0B93         CMP.W   #0x0, R11
   \   0000BE   0220         JNE     ??_ltoa_11
   \   0000C0   0893         CMP.W   #0x0, R8
   \   0000C2   0B24         JEQ     ??_ltoa_12
    350              {
    351                for (i = 0; i < 4 - strlen((char const*)tmp1); i++)
   \                     ??_ltoa_11:
   \   0000C4   4A43         MOV.B   #0x0, R10
   \   0000C6   023C         JMP     ??_ltoa_13
    352                  strcat((char*)buf, "0");
   \                     ??_ltoa_1:
   \   0000C8   ........     CALLA   #?Subroutine8
   \                     ??_ltoa_13:
   \   0000CC   2442         MOV.W   #0x4, R4
   \   0000CE   0C47         MOV.W   R7, R12
   \   0000D0   ........     CALLA   #strlen
   \   0000D4   048C         SUB.W   R12, R4
   \   0000D6   0A94         CMP.W   R4, R10
   \   0000D8   F72B         JNC     ??_ltoa_1
    353              }
    354              strcat((char*)buf, (char const*)tmp1);
   \                     ??_ltoa_12:
   \   0000DA   ........     CALLA   #?Subroutine10
    355              if (!num3 && !num2 && !num1)
   \                     ??CrossCallReturnLabel_14:
   \   0000DE   0B93         CMP.W   #0x0, R11
   \   0000E0   0220         JNE     ??_ltoa_3
   \   0000E2   0893         CMP.W   #0x0, R8
   \   0000E4   2F24         JEQ     ??_ltoa_14
    356                strcpy((char*)buf, "0");
    357            }
    358            else if ( radix == 16 )
    359            {
    360              num1 = l & 0x0000FFFF;
    361              num2 = l >> 16;
    362          
    363              if (num2) _itoa(num2, tmp2, 16);
    364              if (num1) _itoa(num1, tmp1, 16);
    365          
    366              if (num2)
    367              {
    368                strcpy((char*)buf,(char const*)tmp2);
    369                for (i = 0; i < 4 - strlen((char const*)tmp1); i++)
    370                  strcat((char*)buf, "0");
    371              }
    372              strcat((char*)buf, (char const*)tmp1);
    373              if (!num2 && !num1)
    374                strcpy((char*)buf, "0");
    375            }
    376            else
    377              return NULL;
    378          
    379            return buf;
   \                     ??_ltoa_3:
   \   0000E6   0C49         MOV.W   R9, R12
   \                     ??_ltoa_4:
   \   0000E8   31501E00     ADD.W   #0x1e, SP
   \   0000EC   7417         POPM.W  #0x8, R11
   \   0000EE   1001         RETA
   \                     ??_ltoa_5:
   \   0000F0   7F901000     CMP.B   #0x10, R15
   \   0000F4   2F20         JNE     ??_ltoa_15
   \   0000F6   064A         MOV.W   R10, R6
   \   0000F8   084D         MOV.W   R13, R8
   \   0000FA   0D93         CMP.W   #0x0, R13
   \   0000FC   0624         JEQ     ??_ltoa_16
   \   0000FE   7E401000     MOV.B   #0x10, R14
   \   000102   0D44         MOV.W   R4, R13
   \   000104   0C48         MOV.W   R8, R12
   \   000106   ........     CALLA   #_itoa
   \                     ??_ltoa_16:
   \   00010A   0A93         CMP.W   #0x0, R10
   \   00010C   0624         JEQ     ??_ltoa_17
   \   00010E   7E401000     MOV.B   #0x10, R14
   \   000112   0D47         MOV.W   R7, R13
   \   000114   0C4A         MOV.W   R10, R12
   \   000116   ........     CALLA   #_itoa
   \                     ??_ltoa_17:
   \   00011A   0893         CMP.W   #0x0, R8
   \   00011C   0F24         JEQ     ??_ltoa_18
   \   00011E   0D44         MOV.W   R4, R13
   \   000120   0C49         MOV.W   R9, R12
   \   000122   ........     CALLA   #strcpy
   \   000126   4A43         MOV.B   #0x0, R10
   \   000128   023C         JMP     ??_ltoa_19
   \                     ??_ltoa_2:
   \   00012A   ........     CALLA   #?Subroutine8
   \                     ??_ltoa_19:
   \   00012E   2B42         MOV.W   #0x4, R11
   \   000130   0C47         MOV.W   R7, R12
   \   000132   ........     CALLA   #strlen
   \   000136   0B8C         SUB.W   R12, R11
   \   000138   0A9B         CMP.W   R11, R10
   \   00013A   F72B         JNC     ??_ltoa_2
   \                     ??_ltoa_18:
   \   00013C   ........     CALLA   #?Subroutine10
   \                     ??CrossCallReturnLabel_13:
   \   000140   0893         CMP.W   #0x0, R8
   \   000142   D123         JNE     ??_ltoa_3
   \                     ??_ltoa_14:
   \   000144   0693         CMP.W   #0x0, R6
   \   000146   CF23         JNE     ??_ltoa_3
   \   000148   3D40....     MOV.W   #`?<Constant "0">`, R13
   \   00014C   0C49         MOV.W   R9, R12
   \   00014E   ........     CALLA   #strcpy
   \   000152   C93F         JMP     ??_ltoa_3
   \                     ??_ltoa_15:
   \   000154   0C43         MOV.W   #0x0, R12
   \   000156   C83F         JMP     ??_ltoa_4
   \   000158   0343         NOP
    380          #endif
    381          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine10:
   \   000000   0D47         MOV.W   R7, R13
   \   000002                REQUIRE ??Subroutine12_0
   \   000002                // Fall through to label ??Subroutine12_0

   \                                 In  segment CODE, align 2
   \                     ??Subroutine12_0:
   \   000000   0C49         MOV.W   R9, R12
   \   000002   ........     BRA     #strcat

   \                                 In  segment CODE, align 2
   \                     ?Subroutine8:
   \   000000   3D40....     MOV.W   #`?<Constant "0">`, R13
   \   000004   0C49         MOV.W   R9, R12
   \   000006   ........     CALLA   #strcat
   \   00000A   5A53         ADD.B   #0x1, R10
   \   00000C   1001         RETA

   \                                 In  segment CODE, align 2
   \                     ?Subroutine7:
   \   000000   3E400A00     MOV.W   #0xa, R14
   \   000004   ........     BRA     #?ClearMemoryBytes

   \                                 In  segment CODE, align 2
   \                     ?Subroutine6:
   \   000000   3E401027     MOV.W   #0x2710, R14
   \   000004   0F43         MOV.W   #0x0, R15
   \   000006   ........     BRA     #?DivMod32u
    382          #endif // !defined(ZBIT) && !defined(ZBIT2)
    383          
    384          /*********************************************************************
    385           * @fn        osal_rand
    386           *
    387           * @brief    Random number generator
    388           *
    389           * @param   none
    390           *
    391           * @return  uint16 - new random number
    392           */

   \                                 In  segment CODE, align 2
    393          uint16 osal_rand( void )
   \                     osal_rand:
    394          {
    395            return ( Onboard_rand() );
   \   000000   ........     BRA     #Onboard_rand
    396          }
    397          
    398          /*********************************************************************
    399           * API FUNCTIONS
    400           *********************************************************************/
    401          
    402          /*********************************************************************
    403           * @fn      osal_msg_allocate
    404           *
    405           * @brief
    406           *
    407           *    This function is called by a task to allocate a message buffer
    408           *    into which the task will encode the particular message it wishes
    409           *    to send.  This common buffer scheme is used to strictly limit the
    410           *    creation of message buffers within the system due to RAM size
    411           *    limitations on the microprocessor.   Note that all message buffers
    412           *    are a fixed size (at least initially).  The parameter len is kept
    413           *    in case a message pool with varying fixed message sizes is later
    414           *    created (for example, a pool of message buffers of size LARGE,
    415           *    MEDIUM and SMALL could be maintained and allocated based on request
    416           *    from the tasks).
    417           *
    418           *
    419           * @param   uint8 len  - wanted buffer length
    420           *
    421           *
    422           * @return  pointer to allocated buffer or NULL if allocation failed.
    423           */

   \                                 In  segment CODE, align 2
    424          uint8 * osal_msg_allocate( uint16 len )
   \                     osal_msg_allocate:
    425          {
   \   000000   0A12         PUSH.W  R10
   \   000002   0A4C         MOV.W   R12, R10
    426            osal_msg_hdr_t *hdr;
    427          
    428            if ( len == 0 )
   \   000004   0C93         CMP.W   #0x0, R12
   \   000006   0F24         JEQ     ??osal_msg_allocate_0
    429              return ( NULL );
    430          
    431            hdr = (osal_msg_hdr_t *) osal_mem_alloc( (short)(len + sizeof( osal_msg_hdr_t )) );
   \   000008   3C500600     ADD.W   #0x6, R12
   \   00000C   ........     CALLA   #osal_mem_alloc
    432            if ( hdr )
   \   000010   0C93         CMP.W   #0x0, R12
   \   000012   0924         JEQ     ??osal_msg_allocate_0
    433            {
    434              hdr->next = NULL;
   \   000014   8C430000     MOV.W   #0x0, 0(R12)
    435              hdr->len = len;
   \   000018   8C4A0200     MOV.W   R10, 0x2(R12)
    436              hdr->dest_id = TASK_NO_TASK;
   \   00001C   FC430400     MOV.B   #0xff, 0x4(R12)
    437              return ( (uint8 *) (hdr + 1) );
   \   000020   3C500600     ADD.W   #0x6, R12
   \   000024   013C         JMP     ??osal_msg_allocate_1
    438            }
    439            else
    440              return ( NULL );
   \                     ??osal_msg_allocate_0:
   \   000026   0C43         MOV.W   #0x0, R12
   \                     ??osal_msg_allocate_1:
   \   000028   3A41         POP.W   R10
   \   00002A   1001         RETA
    441          }
    442          
    443          /*********************************************************************
    444           * @fn      osal_msg_deallocate
    445           *
    446           * @brief
    447           *
    448           *    This function is used to deallocate a message buffer. This function
    449           *    is called by a task (or processing element) after it has finished
    450           *    processing a received message.
    451           *
    452           *
    453           * @param   uint8 *msg_ptr - pointer to new message buffer
    454           *
    455           * @return  SUCCESS, INVALID_MSG_POINTER
    456           */

   \                                 In  segment CODE, align 2
    457          uint8 osal_msg_deallocate( uint8 *msg_ptr )
   \                     osal_msg_deallocate:
    458          {
    459            uint8 *x;
    460          
    461            if ( msg_ptr == NULL )
   \   000000   0C93         CMP.W   #0x0, R12
   \   000002   0320         JNE     ??osal_msg_deallocate_0
    462              return ( INVALID_MSG_POINTER );
   \   000004   7C400500     MOV.B   #0x5, R12
   \   000008   1001         RETA
    463          
    464            // don't deallocate queued buffer
    465            if ( OSAL_MSG_ID( msg_ptr ) != TASK_NO_TASK )
   \                     ??osal_msg_deallocate_0:
   \   00000A   FC93FEFF     CMP.B   #0xff, 0xfffe(R12)
   \   00000E   0224         JEQ     ??osal_msg_deallocate_1
    466              return ( MSG_BUFFER_NOT_AVAIL );
   \   000010   6C42         MOV.B   #0x4, R12
   \   000012   1001         RETA
    467          
    468            x = (uint8 *)((uint8 *)msg_ptr - sizeof( osal_msg_hdr_t ));
    469          
    470            osal_mem_free( (void *)x );
   \                     ??osal_msg_deallocate_1:
   \   000014   3C50FAFF     ADD.W   #0xfffa, R12
   \   000018   ........     CALLA   #osal_mem_free
    471          
    472            return ( SUCCESS );
   \   00001C   4C43         MOV.B   #0x0, R12
   \   00001E   1001         RETA
    473          }
    474          
    475          /*********************************************************************
    476           * @fn      osal_msg_send
    477           *
    478           * @brief
    479           *
    480           *    This function is called by a task to send a command message to
    481           *    another task or processing element.  The sending_task field must
    482           *    refer to a valid task, since the task ID will be used
    483           *    for the response message.  This function will also set a message
    484           *    ready event in the destination tasks event list.
    485           *
    486           *
    487           * @param   uint8 destination task - Send msg to?  Task ID
    488           * @param   uint8 *msg_ptr - pointer to new message buffer
    489           * @param   uint8 len - length of data in message
    490           *
    491           * @return  SUCCESS, INVALID_TASK, INVALID_MSG_POINTER
    492           */

   \                                 In  segment CODE, align 2
    493          uint8 osal_msg_send( uint8 destination_task, uint8 *msg_ptr )
   \                     osal_msg_send:
    494          {
   \   000000   0A12         PUSH.W  R10
   \   000002   4A4C         MOV.B   R12, R10
    495            if ( msg_ptr == NULL )
   \   000004   0D93         CMP.W   #0x0, R13
   \   000006   1224         JEQ     ??osal_msg_send_1
    496              return ( INVALID_MSG_POINTER );
    497          
    498            if ( destination_task >= tasksCnt )
   \   000008   5C92....     CMP.B   &tasksCnt, R12
   \   00000C   0628         JNC     ??osal_msg_send_2
    499            {
    500              osal_msg_deallocate( msg_ptr );
   \   00000E   0C4D         MOV.W   R13, R12
   \   000010   ........     CALLA   #osal_msg_deallocate
    501              return ( INVALID_TASK );
   \   000014   7C400300     MOV.B   #0x3, R12
   \   000018   183C         JMP     ??osal_msg_send_3
    502            }
    503          
    504            // Check the message header
    505            if ( OSAL_MSG_NEXT( msg_ptr ) != NULL ||
    506                 OSAL_MSG_ID( msg_ptr ) != TASK_NO_TASK )
   \                     ??osal_msg_send_2:
   \   00001A   8D93FAFF     CMP.W   #0x0, 0xfffa(R13)
   \   00001E   0320         JNE     ??osal_msg_send_4
   \   000020   FD93FEFF     CMP.B   #0xff, 0xfffe(R13)
   \   000024   0624         JEQ     ??osal_msg_send_5
    507            {
    508              osal_msg_deallocate( msg_ptr );
   \                     ??osal_msg_send_4:
   \   000026   0C4D         MOV.W   R13, R12
   \   000028   ........     CALLA   #osal_msg_deallocate
    509              return ( INVALID_MSG_POINTER );
   \                     ??osal_msg_send_1:
   \   00002C   7C400500     MOV.B   #0x5, R12
   \   000030   0C3C         JMP     ??osal_msg_send_3
    510            }
    511          
    512            OSAL_MSG_ID( msg_ptr ) = destination_task;
   \                     ??osal_msg_send_5:
   \   000032   CD4CFEFF     MOV.B   R12, 0xfffe(R13)
    513          
    514            // queue message
    515            osal_msg_enqueue( &osal_qHead, msg_ptr );
   \   000036   3C40....     MOV.W   #osal_qHead, R12
   \   00003A   ........     CALLA   #osal_msg_enqueue
    516          
    517            // Signal the task that a message is waiting
    518            osal_set_event( destination_task, SYS_EVENT_MSG );
   \   00003E   3D400080     MOV.W   #0x8000, R13
   \   000042   4C4A         MOV.B   R10, R12
   \   000044   ........     CALLA   #osal_set_event
    519          
    520            return ( SUCCESS );
   \   000048   4C43         MOV.B   #0x0, R12
   \                     ??osal_msg_send_3:
   \   00004A   3A41         POP.W   R10
   \   00004C   1001         RETA
    521          }
    522          
    523          /*********************************************************************
    524           * @fn      osal_msg_receive
    525           *
    526           * @brief
    527           *
    528           *    This function is called by a task to retrieve a received command
    529           *    message. The calling task must deallocate the message buffer after
    530           *    processing the message using the osal_msg_deallocate() call.
    531           *
    532           * @param   uint8 task_id - receiving tasks ID
    533           *
    534           * @return  *uint8 - message information or NULL if no message
    535           */

   \                                 In  segment CODE, align 2
    536          uint8 *osal_msg_receive( uint8 task_id )
   \                     osal_msg_receive:
    537          {
   \   000000   3B15         PUSHM.W #0x4, R11
    538            osal_msg_hdr_t *listHdr;
    539            osal_msg_hdr_t *prevHdr = NULL;
   \   000002   0A43         MOV.W   #0x0, R10
    540            osal_msg_hdr_t *foundHdr = NULL;
   \   000004   0B43         MOV.W   #0x0, R11
    541            halIntState_t   intState;
    542          
    543            // Hold off interrupts
    544            HAL_ENTER_CRITICAL_SECTION(intState);
   \   000006   0842         MOV.W   SR, R8
   \   000008   32C2         dint
   \   00000A   0343         nop
    545          
    546            // Point to the top of the queue
    547            listHdr = osal_qHead;
   \   00000C   1F42....     MOV.W   &osal_qHead, R15
   \   000010   053C         JMP     ??osal_msg_receive_2
    548          
    549            // Look through the queue for a message that belongs to the asking task
    550            while ( listHdr != NULL )
    551            {
    552              if ( (listHdr - 1)->dest_id == task_id )
    553              {
    554                if ( foundHdr == NULL )
    555                {
    556                  // Save the first one
    557                  foundHdr = listHdr;
    558                }
    559                else
    560                {
    561                  // Second msg found, stop looking
    562                  break;
    563                }
    564              }
    565              if ( foundHdr == NULL )
   \                     ??osal_msg_receive_0:
   \   000012   0B93         CMP.W   #0x0, R11
   \   000014   0120         JNE     ??osal_msg_receive_1
    566              {
    567                prevHdr = listHdr;
   \   000016   0A4F         MOV.W   R15, R10
    568              }
    569              listHdr = OSAL_MSG_NEXT( listHdr );
   \                     ??osal_msg_receive_1:
   \   000018   1F4FFAFF     MOV.W   0xfffa(R15), R15
   \                     ??osal_msg_receive_2:
   \   00001C   0F93         CMP.W   #0x0, R15
   \   00001E   0C24         JEQ     ??osal_msg_receive_3
   \   000020   CF9CFEFF     CMP.B   R12, 0xfffe(R15)
   \   000024   F623         JNE     ??osal_msg_receive_0
   \   000026   0B93         CMP.W   #0x0, R11
   \   000028   0220         JNE     ??osal_msg_receive_4
   \   00002A   0B4F         MOV.W   R15, R11
   \   00002C   F53F         JMP     ??osal_msg_receive_1
    570            }
    571          
    572            // Is there more than one?
    573            if ( listHdr != NULL )
    574            {
    575              // Yes, Signal the task that a message is waiting
    576              osal_set_event( task_id, SYS_EVENT_MSG );
   \                     ??osal_msg_receive_4:
   \   00002E   3D400080     MOV.W   #0x8000, R13
   \   000032   ........     CALLA   #osal_set_event
   \   000036   063C         JMP     ??osal_msg_receive_5
    577            }
    578            else
    579            {
    580              // No more
    581              osal_clear_event( task_id, SYS_EVENT_MSG );
   \                     ??osal_msg_receive_3:
   \   000038   3D400080     MOV.W   #0x8000, R13
   \   00003C   ........     CALLA   #osal_clear_event
    582            }
    583          
    584            // Did we find a message?
    585            if ( foundHdr != NULL )
   \   000040   0B93         CMP.W   #0x0, R11
   \   000042   0624         JEQ     ??osal_msg_receive_6
    586            {
    587              // Take out of the link list
    588              osal_msg_extract( &osal_qHead, foundHdr, prevHdr );
   \                     ??osal_msg_receive_5:
   \   000044   0E4A         MOV.W   R10, R14
   \   000046   0D4B         MOV.W   R11, R13
   \   000048   3C40....     MOV.W   #osal_qHead, R12
   \   00004C   ........     CALLA   #osal_msg_extract
    589            }
    590          
    591            // Release interrupts
    592            HAL_EXIT_CRITICAL_SECTION(intState);
   \                     ??osal_msg_receive_6:
   \   000050   0248         MOV.W   R8, SR
    593          
    594            return ( (uint8*) foundHdr );
   \   000052   0C4B         MOV.W   R11, R12
   \   000054   3817         POPM.W  #0x4, R11
   \   000056   1001         RETA
    595          }
    596          
    597          /**************************************************************************************************
    598           * @fn          osal_msg_find
    599           *
    600           * @brief       This function finds in place an OSAL message matching the task_id and event
    601           *              parameters.
    602           *
    603           * input parameters
    604           *
    605           * @param       task_id - The OSAL task id that the enqueued OSAL message must match.
    606           * @param       event - The OSAL event id that the enqueued OSAL message must match.
    607           *
    608           * output parameters
    609           *
    610           * None.
    611           *
    612           * @return      NULL if no match, otherwise an in place pointer to the matching OSAL message.
    613           **************************************************************************************************
    614           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine2:
   \   000000   024E         MOV.W   R14, SR
   \   000002   0C4F         MOV.W   R15, R12
   \   000004   1001         RETA

   \                                 In  segment CODE, align 2
    615          osal_event_hdr_t *osal_msg_find(uint8 task_id, uint8 event)
   \                     osal_msg_find:
    616          {
    617            osal_msg_hdr_t *pHdr;
    618            halIntState_t intState;
    619          
    620            HAL_ENTER_CRITICAL_SECTION(intState);  // Hold off interrupts.
   \   000000   0E42         MOV.W   SR, R14
   \   000002   32C2         dint
   \   000004   0343         nop
    621          
    622            pHdr = osal_qHead;  // Point to the top of the queue.
   \   000006   1F42....     MOV.W   &osal_qHead, R15
   \   00000A   023C         JMP     ??osal_msg_find_1
    623          
    624            // Look through the queue for a message that matches the task_id and event parameters.
    625            while (pHdr != NULL)
    626            {
    627              if (((pHdr-1)->dest_id == task_id) && (((osal_event_hdr_t *)pHdr)->event == event))
    628              {
    629                break;
    630              }
    631          
    632              pHdr = OSAL_MSG_NEXT(pHdr);
   \                     ??osal_msg_find_0:
   \   00000C   1F4FFAFF     MOV.W   0xfffa(R15), R15
   \                     ??osal_msg_find_1:
   \   000010   0F93         CMP.W   #0x0, R15
   \   000012   0624         JEQ     ??osal_msg_find_2
   \   000014   CF9CFEFF     CMP.B   R12, 0xfffe(R15)
   \   000018   F923         JNE     ??osal_msg_find_0
   \   00001A   CF9D0000     CMP.B   R13, 0(R15)
   \   00001E   F623         JNE     ??osal_msg_find_0
    633            }
    634          
    635            HAL_EXIT_CRITICAL_SECTION(intState);  // Release interrupts.
   \                     ??osal_msg_find_2:
   \   000020   ....         JMP     ?Subroutine2
   \   000022   0343         NOP
    636          
    637            return (osal_event_hdr_t *)pHdr;
    638          }
    639          
    640          /*********************************************************************
    641           * @fn      osal_msg_enqueue
    642           *
    643           * @brief
    644           *
    645           *    This function enqueues an OSAL message into an OSAL queue.
    646           *
    647           * @param   osal_msg_q_t *q_ptr - OSAL queue
    648           * @param   void *msg_ptr  - OSAL message
    649           *
    650           * @return  none
    651           */

   \                                 In  segment CODE, align 2, keep-with-next
    652          void osal_msg_enqueue( osal_msg_q_t *q_ptr, void *msg_ptr )
   \                     osal_msg_enqueue:
    653          {
    654            void *list;
    655            halIntState_t intState;
    656          
    657            // Hold off interrupts
    658            HAL_ENTER_CRITICAL_SECTION(intState);
   \   000000   0F42         MOV.W   SR, R15
   \   000002   32C2         dint
   \   000004   0343         nop
    659          
    660            OSAL_MSG_NEXT( msg_ptr ) = NULL;
   \   000006   8D43FAFF     MOV.W   #0x0, 0xfffa(R13)
    661            // If first message in queue
    662            if ( *q_ptr == NULL )
   \   00000A   2E4C         MOV.W   @R12, R14
   \   00000C   0E93         CMP.W   #0x0, R14
   \   00000E   0420         JNE     ??osal_msg_enqueue_2
    663            {
    664              *q_ptr = msg_ptr;
   \   000010   8C4D0000     MOV.W   R13, 0(R12)
   \   000014   073C         JMP     ??osal_msg_enqueue_3
    665            }
    666            else
    667            {
    668              // Find end of queue
    669              for ( list = *q_ptr; OSAL_MSG_NEXT( list ) != NULL; list = OSAL_MSG_NEXT( list ) );
   \                     ??osal_msg_enqueue_0:
   \   000016   0E4C         MOV.W   R12, R14
   \                     ??osal_msg_enqueue_2:
   \   000018   1C4EFAFF     MOV.W   0xfffa(R14), R12
   \   00001C   0C93         CMP.W   #0x0, R12
   \   00001E   FB23         JNE     ??osal_msg_enqueue_0
    670          
    671              // Add message to end of queue
    672              OSAL_MSG_NEXT( list ) = msg_ptr;
   \   000020   8E4DFAFF     MOV.W   R13, 0xfffa(R14)
    673            }
    674          
    675            // Re-enable interrupts
    676            HAL_EXIT_CRITICAL_SECTION(intState);
   \                     ??osal_msg_enqueue_3:
   \   000024   024F         MOV.W   R15, SR
    677          }
   \   000026   1001         RETA
    678          
    679          /*********************************************************************
    680           * @fn      osal_msg_dequeue
    681           *
    682           * @brief
    683           *
    684           *    This function dequeues an OSAL message from an OSAL queue.
    685           *
    686           * @param   osal_msg_q_t *q_ptr - OSAL queue
    687           *
    688           * @return  void * - pointer to OSAL message or NULL of queue is empty.
    689           */

   \                                 In  segment CODE, align 2, keep-with-next
    690          void *osal_msg_dequeue( osal_msg_q_t *q_ptr )
   \                     osal_msg_dequeue:
    691          {
    692            void *msg_ptr = NULL;
   \   000000   0F43         MOV.W   #0x0, R15
    693            halIntState_t intState;
    694          
    695            // Hold off interrupts
    696            HAL_ENTER_CRITICAL_SECTION(intState);
   \   000002   0E42         MOV.W   SR, R14
   \   000004   32C2         dint
   \   000006   0343         nop
    697          
    698            if ( *q_ptr != NULL )
   \   000008   2D4C         MOV.W   @R12, R13
   \   00000A   0D93         CMP.W   #0x0, R13
   \   00000C   0824         JEQ     ??osal_msg_dequeue_0
    699            {
    700              // Dequeue message
    701              msg_ptr = *q_ptr;
   \   00000E   0F4D         MOV.W   R13, R15
    702              *q_ptr = OSAL_MSG_NEXT( msg_ptr );
   \   000010   9C4DFAFF0000 MOV.W   0xfffa(R13), 0(R12)
    703              OSAL_MSG_NEXT( msg_ptr ) = NULL;
   \   000016   8D43FAFF     MOV.W   #0x0, 0xfffa(R13)
    704              OSAL_MSG_ID( msg_ptr ) = TASK_NO_TASK;
   \   00001A   FD43FEFF     MOV.B   #0xff, 0xfffe(R13)
    705            }
    706          
    707            // Re-enable interrupts
    708            HAL_EXIT_CRITICAL_SECTION(intState);
   \                     ??osal_msg_dequeue_0:
   \   00001E                REQUIRE ?Subroutine2
   \   00001E                // Fall through to label ?Subroutine2
    709          
    710            return msg_ptr;
    711          }
    712          
    713          /*********************************************************************
    714           * @fn      osal_msg_push
    715           *
    716           * @brief
    717           *
    718           *    This function pushes an OSAL message to the head of an OSAL
    719           *    queue.
    720           *
    721           * @param   osal_msg_q_t *q_ptr - OSAL queue
    722           * @param   void *msg_ptr  - OSAL message
    723           *
    724           * @return  none
    725           */

   \                                 In  segment CODE, align 2
    726          void osal_msg_push( osal_msg_q_t *q_ptr, void *msg_ptr )
   \                     osal_msg_push:
    727          {
    728            halIntState_t intState;
    729          
    730            // Hold off interrupts
    731            HAL_ENTER_CRITICAL_SECTION(intState);
   \   000000   0F42         MOV.W   SR, R15
   \   000002   32C2         dint
   \   000004   0343         nop
    732          
    733            // Push message to head of queue
    734            OSAL_MSG_NEXT( msg_ptr ) = *q_ptr;
   \   000006   AD4CFAFF     MOV.W   @R12, 0xfffa(R13)
    735            *q_ptr = msg_ptr;
   \   00000A   8C4D0000     MOV.W   R13, 0(R12)
    736          
    737            // Re-enable interrupts
    738            HAL_EXIT_CRITICAL_SECTION(intState);
   \   00000E   024F         MOV.W   R15, SR
    739          }
   \   000010   1001         RETA
    740          
    741          /*********************************************************************
    742           * @fn      osal_msg_extract
    743           *
    744           * @brief
    745           *
    746           *    This function extracts and removes an OSAL message from the
    747           *    middle of an OSAL queue.
    748           *
    749           * @param   osal_msg_q_t *q_ptr - OSAL queue
    750           * @param   void *msg_ptr  - OSAL message to be extracted
    751           * @param   void *prev_ptr  - OSAL message before msg_ptr in queue
    752           *
    753           * @return  none
    754           */

   \                                 In  segment CODE, align 2
    755          void osal_msg_extract( osal_msg_q_t *q_ptr, void *msg_ptr, void *prev_ptr )
   \                     osal_msg_extract:
    756          {
   \   000000   0A12         PUSH.W  R10
    757            halIntState_t intState;
    758          
    759            // Hold off interrupts
    760            HAL_ENTER_CRITICAL_SECTION(intState);
   \   000002   0F42         MOV.W   SR, R15
   \   000004   32C2         dint
   \   000006   0343         nop
    761          
    762            if ( msg_ptr == *q_ptr )
   \   000008   1A4DFAFF     MOV.W   0xfffa(R13), R10
   \   00000C   2D9C         CMP.W   @R12, R13
   \   00000E   0320         JNE     ??osal_msg_extract_0
    763            {
    764              // remove from first
    765              *q_ptr = OSAL_MSG_NEXT( msg_ptr );
   \   000010   8C4A0000     MOV.W   R10, 0(R12)
   \   000014   023C         JMP     ??osal_msg_extract_1
    766            }
    767            else
    768            {
    769              // remove from middle
    770              OSAL_MSG_NEXT( prev_ptr ) = OSAL_MSG_NEXT( msg_ptr );
   \                     ??osal_msg_extract_0:
   \   000016   8E4AFAFF     MOV.W   R10, 0xfffa(R14)
    771            }
    772            OSAL_MSG_NEXT( msg_ptr ) = NULL;
   \                     ??osal_msg_extract_1:
   \   00001A   8D43FAFF     MOV.W   #0x0, 0xfffa(R13)
    773            OSAL_MSG_ID( msg_ptr ) = TASK_NO_TASK;
   \   00001E   FD43FEFF     MOV.B   #0xff, 0xfffe(R13)
    774          
    775            // Re-enable interrupts
    776            HAL_EXIT_CRITICAL_SECTION(intState);
   \   000022   024F         MOV.W   R15, SR
    777          }
   \   000024   3A41         POP.W   R10
   \   000026   1001         RETA
    778          
    779          /*********************************************************************
    780           * @fn      osal_msg_enqueue_max
    781           *
    782           * @brief
    783           *
    784           *    This function enqueues an OSAL message into an OSAL queue if
    785           *    the length of the queue is less than max.
    786           *
    787           * @param   osal_msg_q_t *q_ptr - OSAL queue
    788           * @param   void *msg_ptr  - OSAL message
    789           * @param   uint8 max - maximum length of queue
    790           *
    791           * @return  TRUE if message was enqueued, FALSE otherwise
    792           */

   \                                 In  segment CODE, align 2
    793          uint8 osal_msg_enqueue_max( osal_msg_q_t *q_ptr, void *msg_ptr, uint8 max )
   \                     osal_msg_enqueue_max:
    794          {
   \   000000   1B15         PUSHM.W #0x2, R11
    795            void *list;
    796            uint8 ret = FALSE;
   \   000002   4F43         MOV.B   #0x0, R15
    797            halIntState_t intState;
    798          
    799            // Hold off interrupts
    800            HAL_ENTER_CRITICAL_SECTION(intState);
   \   000004   0A42         MOV.W   SR, R10
   \   000006   32C2         dint
   \   000008   0343         nop
    801          
    802            // If first message in queue
    803            if ( *q_ptr == NULL )
   \   00000A   2B4C         MOV.W   @R12, R11
   \   00000C   0B93         CMP.W   #0x0, R11
   \   00000E   0620         JNE     ??osal_msg_enqueue_max_2
    804            {
    805              *q_ptr = msg_ptr;
   \   000010   8C4D0000     MOV.W   R13, 0(R12)
    806              ret = TRUE;
   \   000014   0C3C         JMP     ??osal_msg_enqueue_max_3
    807            }
    808            else
    809            {
    810              // Find end of queue or max
    811              list = *q_ptr;
    812              max--;
    813              while ( (OSAL_MSG_NEXT( list ) != NULL) && (max > 0) )
   \                     ??osal_msg_enqueue_max_0:
   \   000016   4E93         CMP.B   #0x0, R14
   \   000018   0B24         JEQ     ??osal_msg_enqueue_max_4
    814              {
    815                list = OSAL_MSG_NEXT( list );
   \   00001A   0B4C         MOV.W   R12, R11
    816                max--;
   \                     ??osal_msg_enqueue_max_2:
   \   00001C   7E53         ADD.B   #0xff, R14
    817              }
   \   00001E   1C4BFAFF     MOV.W   0xfffa(R11), R12
   \   000022   0C93         CMP.W   #0x0, R12
   \   000024   F823         JNE     ??osal_msg_enqueue_max_0
    818          
    819              // Add message to end of queue if max not reached
    820              if ( max != 0 )
   \   000026   4E93         CMP.B   #0x0, R14
   \   000028   0324         JEQ     ??osal_msg_enqueue_max_4
    821              {
    822                OSAL_MSG_NEXT( list ) = msg_ptr;
   \   00002A   8B4DFAFF     MOV.W   R13, 0xfffa(R11)
    823                ret = TRUE;
   \                     ??osal_msg_enqueue_max_3:
   \   00002E   5F43         MOV.B   #0x1, R15
    824              }
    825            }
    826          
    827            // Re-enable interrupts
    828            HAL_EXIT_CRITICAL_SECTION(intState);
   \                     ??osal_msg_enqueue_max_4:
   \   000030   024A         MOV.W   R10, SR
    829          
    830            return ret;
   \   000032   4C4F         MOV.B   R15, R12
   \   000034   1A17         POPM.W  #0x2, R11
   \   000036   1001         RETA
    831          }
    832          
    833          /*********************************************************************
    834           * @fn      osal_set_event
    835           *
    836           * @brief
    837           *
    838           *    This function is called to set the event flags for a task. The
    839           *    event passed in is OR'd into the task's event variable.
    840           *
    841           * @param   uint8 task_id - receiving tasks ID
    842           * @param   uint8 event_flag - what event to set
    843           *
    844           * @return  SUCCESS, INVALID_TASK
    845           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine4:
   \   000000   7C400300     MOV.B   #0x3, R12
   \   000004   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine1:
   \   000000   024F         MOV.W   R15, SR
   \   000002   4C43         MOV.B   #0x0, R12
   \   000004   1001         RETA

   \                                 In  segment CODE, align 2
    846          uint8 osal_set_event( uint8 task_id, uint16 event_flag )
   \                     osal_set_event:
    847          {
    848            if ( task_id < tasksCnt )
   \   000000   5C92....     CMP.B   &tasksCnt, R12
   \   000004   0B2C         JC      ??osal_set_event_0
    849            {
    850              halIntState_t   intState;
    851              HAL_ENTER_CRITICAL_SECTION(intState);    // Hold off interrupts
   \   000006   0F42         MOV.W   SR, R15
   \   000008   32C2         dint
   \   00000A   0343         nop
    852              tasksEvents[task_id] |= event_flag;  // Stuff the event bit(s)
   \   00000C   1E42....     MOV.W   &tasksEvents, R14
   \   000010   4C4C         MOV.B   R12, R12
   \   000012   0C5C         RLA.W   R12
   \   000014   0E5C         ADD.W   R12, R14
   \   000016   8EDD0000     BIS.W   R13, 0(R14)
    853              HAL_EXIT_CRITICAL_SECTION(intState);     // Release interrupts
   \   00001A   ....         JMP     ?Subroutine1
    854              return ( SUCCESS );
    855            }
    856             else
    857            {
    858              return ( INVALID_TASK );
   \                     ??osal_set_event_0:
   \   00001C   ....         JMP     ?Subroutine4
   \   00001E   0343         NOP
    859            }
    860          }
    861          
    862          /*********************************************************************
    863           * @fn      osal_clear_event
    864           *
    865           * @brief
    866           *
    867           *    This function is called to clear the event flags for a task. The
    868           *    event passed in is masked out of the task's event variable.
    869           *
    870           * @param   uint8 task_id - receiving tasks ID
    871           * @param   uint8 event_flag - what event to clear
    872           *
    873           * @return  SUCCESS, INVALID_TASK
    874           */

   \                                 In  segment CODE, align 2, keep-with-next
    875          uint8 osal_clear_event( uint8 task_id, uint16 event_flag )
   \                     osal_clear_event:
    876          {
    877            if ( task_id < tasksCnt )
   \   000000   5C92....     CMP.B   &tasksCnt, R12
   \   000004   0B2C         JC      ??osal_clear_event_0
    878            {
    879              halIntState_t   intState;
    880              HAL_ENTER_CRITICAL_SECTION(intState);    // Hold off interrupts
   \   000006   0F42         MOV.W   SR, R15
   \   000008   32C2         dint
   \   00000A   0343         nop
    881              tasksEvents[task_id] &= ~(event_flag);   // Clear the event bit(s)
   \   00000C   1E42....     MOV.W   &tasksEvents, R14
   \   000010   4C4C         MOV.B   R12, R12
   \   000012   0C5C         RLA.W   R12
   \   000014   0E5C         ADD.W   R12, R14
   \   000016   8ECD0000     BIC.W   R13, 0(R14)
    882              HAL_EXIT_CRITICAL_SECTION(intState);     // Release interrupts
   \   00001A   ....         JMP     ?Subroutine1
    883              return ( SUCCESS );
    884            }
    885             else
    886            {
    887              return ( INVALID_TASK );
   \                     ??osal_clear_event_0:
   \   00001C                REQUIRE ?Subroutine4
   \   00001C                // Fall through to label ?Subroutine4
    888            }
    889          }
    890          
    891          /*********************************************************************
    892           * @fn      osal_isr_register
    893           *
    894           * @brief
    895           *
    896           *   This function is called to register a service routine with an
    897           *   interrupt. When the interrupt occurs, this service routine is called.
    898           *
    899           * @param   uint8 interrupt_id - Interrupt number
    900           * @param   void (*isr_ptr)( uint8* ) - function pointer to ISR
    901           *
    902           * @return  SUCCESS, INVALID_INTERRUPT_ID,
    903           */

   \                                 In  segment CODE, align 2
    904          uint8 osal_isr_register( uint8 interrupt_id, void (*isr_ptr)( uint8* ) )
   \                     osal_isr_register:
    905          {
    906            // Remove these statements when functionality is complete
    907            (void)interrupt_id;
    908            (void)isr_ptr;
    909            return ( SUCCESS );
   \   000000   4C43         MOV.B   #0x0, R12
   \   000002   1001         RETA
    910          }
    911          
    912          /*********************************************************************
    913           * @fn      osal_int_enable
    914           *
    915           * @brief
    916           *
    917           *   This function is called to enable an interrupt. Once enabled,
    918           *   occurrence of the interrupt causes the service routine associated
    919           *   with that interrupt to be called.
    920           *
    921           *   If INTS_ALL is the interrupt_id, interrupts (in general) are enabled.
    922           *   If a single interrupt is passed in, then interrupts still have
    923           *   to be enabled with another call to INTS_ALL.
    924           *
    925           * @param   uint8 interrupt_id - Interrupt number
    926           *
    927           * @return  SUCCESS or INVALID_INTERRUPT_ID
    928           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine3:
   \   000000   7C400700     MOV.B   #0x7, R12
   \   000004   1001         RETA

   \                                 In  segment CODE, align 2
    929          uint8 osal_int_enable( uint8 interrupt_id )
   \                     osal_int_enable:
    930          {
    931          
    932            if ( interrupt_id == INTS_ALL )
   \   000000   7C93         CMP.B   #0xff, R12
   \   000002   0320         JNE     ??osal_int_enable_0
    933            {
    934              HAL_ENABLE_INTERRUPTS();
   \   000004   32D2         eint
    935              return ( SUCCESS );
   \   000006   4C43         MOV.B   #0x0, R12
   \   000008   1001         RETA
    936            }
    937            else
    938            {
    939              return ( INVALID_INTERRUPT_ID );
   \                     ??osal_int_enable_0:
   \   00000A   ....         JMP     ?Subroutine3
   \   00000C   0343         NOP
    940            }
    941          }
    942          
    943          /*********************************************************************
    944           * @fn      osal_int_disable
    945           *
    946           * @brief
    947           *
    948           *   This function is called to disable an interrupt. When a disabled
    949           *   interrupt occurs, the service routine associated with that
    950           *   interrupt is not called.
    951           *
    952           *   If INTS_ALL is the interrupt_id, interrupts (in general) are disabled.
    953           *   If a single interrupt is passed in, then just that interrupt is disabled.
    954           *
    955           * @param   uint8 interrupt_id - Interrupt number
    956           *
    957           * @return  SUCCESS or INVALID_INTERRUPT_ID
    958           */

   \                                 In  segment CODE, align 2, keep-with-next
    959          uint8 osal_int_disable( uint8 interrupt_id )
   \                     osal_int_disable:
    960          {
    961          
    962            if ( interrupt_id == INTS_ALL )
   \   000000   7C93         CMP.B   #0xff, R12
   \   000002   0420         JNE     ??osal_int_disable_0
    963            {
    964              HAL_DISABLE_INTERRUPTS();
   \   000004   32C2         dint
   \   000006   0343         nop
    965              return ( SUCCESS );
   \   000008   4C43         MOV.B   #0x0, R12
   \   00000A   1001         RETA
    966            }
    967            else
    968            {
    969              return ( INVALID_INTERRUPT_ID );
   \                     ??osal_int_disable_0:
   \   00000C                REQUIRE ?Subroutine3
   \   00000C                // Fall through to label ?Subroutine3
    970            }
    971          }
    972          
    973          /*********************************************************************
    974           * @fn      osal_init_system
    975           *
    976           * @brief
    977           *
    978           *   This function initializes the "task" system by creating the
    979           *   tasks defined in the task table (OSAL_Tasks.h).
    980           *
    981           * @param   void
    982           *
    983           * @return  SUCCESS
    984           */

   \                                 In  segment CODE, align 2
    985          uint8 osal_init_system( void )
   \                     osal_init_system:
    986          {
    987            // Initialize the Memory Allocation System
    988            osal_mem_init();
   \   000000   ........     CALLA   #osal_mem_init
    989          
    990            // Initialize the message queue
    991            osal_qHead = NULL;
   \   000004   8243....     MOV.W   #0x0, &osal_qHead
    992          
    993            // Initialize the timers
    994            osalTimerInit();
   \   000008   ........     CALLA   #osalTimerInit
    995          
    996            // Initialize the Power Management System
    997            osal_pwrmgr_init();
   \   00000C   ........     CALLA   #osal_pwrmgr_init
    998          
    999            // Initialize the system tasks.
   1000            osalInitTasks();
   \   000010   ........     CALLA   #osalInitTasks
   1001          
   1002            // Setup efficient search for the first free block of heap.
   1003            osal_mem_kick();
   \   000014   ........     CALLA   #osal_mem_kick
   1004          
   1005            return ( SUCCESS );
   \   000018   4C43         MOV.B   #0x0, R12
   \   00001A   1001         RETA
   1006          }
   1007          
   1008          /*********************************************************************
   1009           * @fn      osal_start_system
   1010           *
   1011           * @brief
   1012           *
   1013           *   This function is the main loop function of the task system (if
   1014           *   ZBIT and UBIT are not defined). This Function doesn't return.
   1015           *
   1016           * @param   void
   1017           *
   1018           * @return  none
   1019           */

   \                                 In  segment CODE, align 2
   1020          void osal_start_system( void )
   \                     osal_start_system:
   \                     ??osal_start_system_0:
   1021          {
   1022          #if !defined ( ZBIT ) && !defined ( UBIT )
   1023            for(;;)  // Forever Loop
   1024          #endif
   1025            {
   1026              osal_run_system();
   \   000000   ........     CALLA   #osal_run_system
   \   000004   FD3F         JMP     ??osal_start_system_0
   \   000006   0343         NOP
   1027            }
   1028          }
   1029          
   1030          /*********************************************************************
   1031           * @fn      osal_run_system
   1032           *
   1033           * @brief
   1034           *
   1035           *   This function will make one pass through the OSAL taskEvents table
   1036           *   and call the task_event_processor() function for the first task that
   1037           *   is found with at least one event pending. If there are no pending
   1038           *   events (all tasks), this function puts the processor into Sleep.
   1039           *
   1040           * @param   void
   1041           *
   1042           * @return  none
   1043           */

   \                                 In  segment CODE, align 2
   1044          void osal_run_system( void )
   \                     osal_run_system:
   1045          {
   \   000000   1B15         PUSHM.W #0x2, R11
   1046            uint8 idx = 0;
   \   000002   4A43         MOV.B   #0x0, R10
   1047          
   1048            osalTimeUpdate();
   \   000004   ........     CALLA   #osalTimeUpdate
   1049            Hal_ProcessPoll();
   \   000008   ........     CALLA   #Hal_ProcessPoll
   1050          
   1051            do {
   1052              if (tasksEvents[idx])  // Task is highest priority that is ready.
   \                     ??osal_run_system_0:
   \   00000C   1F42....     MOV.W   &tasksEvents, R15
   \   000010   4B4A         MOV.B   R10, R11
   \   000012   0B5B         RLA.W   R11
   \   000014   0F5B         ADD.W   R11, R15
   \   000016   8F930000     CMP.W   #0x0, 0(R15)
   \   00001A   0420         JNE     ??osal_run_system_1
   1053              {
   1054                break;
   1055              }
   1056            } while (++idx < tasksCnt);
   \   00001C   5A53         ADD.B   #0x1, R10
   \   00001E   5A92....     CMP.B   &tasksCnt, R10
   \   000022   F42B         JNC     ??osal_run_system_0
   1057          
   1058            if (idx < tasksCnt)
   \                     ??osal_run_system_1:
   \   000024   5A92....     CMP.B   &tasksCnt, R10
   \   000028   222C         JC      ??osal_run_system_2
   1059            {
   1060              uint16 events;
   1061              halIntState_t intState;
   1062          
   1063              HAL_ENTER_CRITICAL_SECTION(intState);
   \   00002A   0F42         MOV.W   SR, R15
   \   00002C   32C2         dint
   \   00002E   0343         nop
   1064              events = tasksEvents[idx];
   \   000030   4A4A         MOV.B   R10, R10
   \   000032   0B4A         MOV.W   R10, R11
   \   000034   0B5B         RLA.W   R11
   \   000036   1E42....     MOV.W   &tasksEvents, R14
   \   00003A   0E5B         ADD.W   R11, R14
   \   00003C   2D4E         MOV.W   @R14, R13
   1065              tasksEvents[idx] = 0;  // Clear the Events for this task.
   \   00003E   8E430000     MOV.W   #0x0, 0(R14)
   1066              HAL_EXIT_CRITICAL_SECTION(intState);
   \   000042   024F         MOV.W   R15, SR
   1067          
   1068              activeTaskID = idx;
   \   000044   C24A....     MOV.B   R10, &activeTaskID
   1069              events = (tasksArr[idx])( idx, events );
   \   000048   4C4A         MOV.B   R10, R12
   \   00004A   5A06         RLAM.W  #0x2, R10
   \   00004C   1E4A....     MOV.W   tasksArr(R10), R14
   \   000050   1F4A....     MOV.W   tasksArr + 2(R10), R15
   \   000054   ........     CALLA   #?IndCallR15
   1070              activeTaskID = TASK_NO_TASK;
   \   000058   F243....     MOV.B   #0xff, &activeTaskID
   1071          
   1072              HAL_ENTER_CRITICAL_SECTION(intState);
   \   00005C   0F42         MOV.W   SR, R15
   \   00005E   32C2         dint
   \   000060   0343         nop
   1073              tasksEvents[idx] |= events;  // Add back unprocessed events to the current task.
   \   000062   1E42....     MOV.W   &tasksEvents, R14
   \   000066   0E5B         ADD.W   R11, R14
   \   000068   8EDC0000     BIS.W   R12, 0(R14)
   1074              HAL_EXIT_CRITICAL_SECTION(intState);
   \   00006C   024F         MOV.W   R15, SR
   1075            }
   1076          #if defined( POWER_SAVING )
   1077            else  // Complete pass through all task events with no activity?
   1078            {
   1079              osal_pwrmgr_powerconserve();  // Put the processor/system into sleep
   1080            }
   1081          #endif
   1082          
   1083            /* Yield in case cooperative scheduling is being used. */
   1084          #if defined (configUSE_PREEMPTION) && (configUSE_PREEMPTION == 0)
   1085            {
   1086              osal_task_yield();
   1087            }
   1088          #endif
   1089          }
   \                     ??osal_run_system_2:
   \   00006E   1A17         POPM.W  #0x2, R11
   \   000070   1001         RETA
   1090          
   1091          /*********************************************************************
   1092           * @fn      osal_buffer_uint32
   1093           *
   1094           * @brief
   1095           *
   1096           *   Buffer an uint32 value - LSB first.
   1097           *
   1098           * @param   buf - buffer
   1099           * @param   val - uint32 value
   1100           *
   1101           * @return  pointer to end of destination buffer
   1102           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine0:
   \   000000   CC4F0000     MOV.B   R15, 0(R12)
   \   000004   1C53         ADD.W   #0x1, R12
   \   000006   1001         RETA

   \                                 In  segment CODE, align 2
   1103          uint8* osal_buffer_uint32( uint8 *buf, uint32 val )
   \                     osal_buffer_uint32:
   1104          {
   1105            *buf++ = BREAK_UINT32( val, 0 );
   \   000000   ........     CALLA   #?Subroutine5
   1106            *buf++ = BREAK_UINT32( val, 1 );
   1107            *buf++ = BREAK_UINT32( val, 2 );
   \                     ??CrossCallReturnLabel_1:
   \   000004   CC4F0000     MOV.B   R15, 0(R12)
   \   000008   1C53         ADD.W   #0x1, R12
   1108            *buf++ = BREAK_UINT32( val, 3 );
   \   00000A   8F10         SWPB    R15
   \   00000C   ....         JMP     ?Subroutine0
   \   00000E   0343         NOP
   1109          
   1110            return buf;
   1111          }

   \                                 In  segment CODE, align 2
   \                     ?Subroutine5:
   \   000000   CC4E0000     MOV.B   R14, 0(R12)
   \   000004   1C53         ADD.W   #0x1, R12
   \   000006   0D4E         MOV.W   R14, R13
   \   000008                RPT     #0x8
   \   000008   47190D10     RRUX.W  R13
   \   00000C   CC4D0000     MOV.B   R13, 0(R12)
   \   000010   1C53         ADD.W   #0x1, R12
   \   000012   1001         RETA
   1112          
   1113          /*********************************************************************
   1114           * @fn      osal_buffer_uint24
   1115           *
   1116           * @brief
   1117           *
   1118           *   Buffer an uint24 value - LSB first. Note that type uint24 is
   1119           *   typedef to uint32 in comdef.h
   1120           *
   1121           * @param   buf - buffer
   1122           * @param   val - uint24 value
   1123           *
   1124           * @return  pointer to end of destination buffer
   1125           */

   \                                 In  segment CODE, align 2, keep-with-next
   1126          uint8* osal_buffer_uint24( uint8 *buf, uint24 val )
   \                     osal_buffer_uint24:
   1127          {
   1128            *buf++ = BREAK_UINT32( val, 0 );
   \   000000   ........     CALLA   #?Subroutine5
   1129            *buf++ = BREAK_UINT32( val, 1 );
   1130            *buf++ = BREAK_UINT32( val, 2 );
   \                     ??CrossCallReturnLabel_0:
   \   000004                REQUIRE ?Subroutine0
   \   000004                // Fall through to label ?Subroutine0
   1131          
   1132            return buf;
   1133          }
   1134          
   1135          /*********************************************************************
   1136           * @fn      osal_isbufset
   1137           *
   1138           * @brief
   1139           *
   1140           *   Is all of the array elements set to a value?
   1141           *
   1142           * @param   buf - buffer to check
   1143           * @param   val - value to check each array element for
   1144           * @param   len - length to check
   1145           *
   1146           * @return  TRUE if all "val"
   1147           *          FALSE otherwise
   1148           */

   \                                 In  segment CODE, align 2
   1149          uint8 osal_isbufset( uint8 *buf, uint8 val, uint8 len )
   \                     osal_isbufset:
   1150          {
   \   000000   0A12         PUSH.W  R10
   1151            uint8 x;
   1152          
   1153            if ( buf == NULL )
   \   000002   0C93         CMP.W   #0x0, R12
   \   000004   0A24         JEQ     ??osal_isbufset_1
   1154            {
   1155              return ( FALSE );
   1156            }
   1157          
   1158            for ( x = 0; x < len; x++ )
   \   000006   4F43         MOV.B   #0x0, R15
   \   000008   013C         JMP     ??osal_isbufset_2
   \                     ??osal_isbufset_0:
   \   00000A   5F53         ADD.B   #0x1, R15
   \                     ??osal_isbufset_2:
   \   00000C   4F9E         CMP.B   R14, R15
   \   00000E   072C         JC      ??osal_isbufset_3
   1159            {
   1160              // Check for non-initialized value
   1161              if ( buf[x] != val )
   \   000010   0A4C         MOV.W   R12, R10
   \   000012   0A5F         ADD.W   R15, R10
   \   000014   CA9D0000     CMP.B   R13, 0(R10)
   \   000018   F827         JEQ     ??osal_isbufset_0
   1162              {
   1163                return ( FALSE );
   \                     ??osal_isbufset_1:
   \   00001A   4C43         MOV.B   #0x0, R12
   \   00001C   013C         JMP     ??osal_isbufset_4
   1164              }
   1165            }
   1166            return ( TRUE );
   \                     ??osal_isbufset_3:
   \   00001E   5C43         MOV.B   #0x1, R12
   \                     ??osal_isbufset_4:
   \   000020   3A41         POP.W   R10
   \   000022   1001         RETA
   1167          }
   1168          
   1169          /*********************************************************************
   1170           * @fn      osal_self
   1171           *
   1172           * @brief
   1173           *
   1174           *   This function returns the task ID of the current (active) task.
   1175           *
   1176           * @param   void
   1177           *
   1178           * @return   active task ID or TASK_NO_TASK if no task is active
   1179           */

   \                                 In  segment CODE, align 2
   1180          uint8 osal_self( void )
   \                     osal_self:
   1181          {
   1182            return ( activeTaskID );
   \   000000   5C42....     MOV.B   &activeTaskID, R12
   \   000004   1001         RETA
   1183          }

   \                                 In  segment DATA16_ID, align 1, align-sorted
   \                     `?<Initializer for activeTaskID>`:
   \   000000   FF           DC8 255

   \                                 In  segment DATA16_C, align 1, align-sorted
   \   000000   00           DC8 ""

   \                                 In  segment DATA16_C, align 1, align-sorted
   \   000000   00           DC8 ""

   \                                 In  segment DATA16_C, align 1, align-sorted
   \   000000   00           DC8 ""

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "0">`:
   \   000000   3000         DC8 "0"
   1184          
   1185          /*********************************************************************
   1186           */

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      50  _ltoa
            50 -> _itoa
            50 -> strcat
            50 -> strcpy
            50 -> strlen
       4  osal_buffer_uint24
       4  osal_buffer_uint32
       4  osal_build_uint16
       8  osal_build_uint32
       4  osal_clear_event
       4  osal_init_system
             4 -> osalInitTasks
             4 -> osalTimerInit
             4 -> osal_mem_init
             4 -> osal_mem_kick
             4 -> osal_pwrmgr_init
       4  osal_int_disable
       4  osal_int_enable
       6  osal_isbufset
       4  osal_isr_register
       4  osal_memcmp
       4  osal_memcpy
      12  osal_memdup
            12 -> osal_mem_alloc
            12 -> osal_memcpy
       4  osal_memset
             4 -> memset
       6  osal_msg_allocate
             6 -> osal_mem_alloc
       4  osal_msg_deallocate
             4 -> osal_mem_free
       4  osal_msg_dequeue
       4  osal_msg_enqueue
       8  osal_msg_enqueue_max
       6  osal_msg_extract
       4  osal_msg_find
       4  osal_msg_push
      12  osal_msg_receive
            12 -> osal_clear_event
            12 -> osal_msg_extract
            12 -> osal_set_event
       6  osal_msg_send
             6 -> osal_msg_deallocate
             6 -> osal_msg_enqueue
             6 -> osal_set_event
       4  osal_rand
             4 -> Onboard_rand
       4  osal_revmemcpy
       8  osal_run_system
             8 -- Indirect call
             8 -> Hal_ProcessPoll
             8 -> osalTimeUpdate
       4  osal_self
       4  osal_set_event
       4  osal_start_system
             4 -> osal_run_system
       4  osal_strlen
             4 -> strlen


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       1  ?<Constant "">
       1  ?<Constant "">_1
       1  ?<Constant "">_2
       2  ?<Constant "0">
       1  ?<Initializer for activeTaskID>
       6  ??Subroutine12_0
       8  ?Subroutine0
       6  ?Subroutine1
       2  ?Subroutine10
      14  ?Subroutine11
       6  ?Subroutine2
       6  ?Subroutine3
       6  ?Subroutine4
      20  ?Subroutine5
      10  ?Subroutine6
       8  ?Subroutine7
      14  ?Subroutine8
       8  ?Subroutine9
     346  _ltoa
       1  activeTaskID
       4  osal_buffer_uint24
      16  osal_buffer_uint32
      16  osal_build_uint16
      76  osal_build_uint32
      28  osal_clear_event
      28  osal_init_system
      12  osal_int_disable
      14  osal_int_enable
      36  osal_isbufset
       4  osal_isr_register
      22  osal_memcmp
      18  osal_memcpy
      32  osal_memdup
       6  osal_memset
      44  osal_msg_allocate
      32  osal_msg_deallocate
      30  osal_msg_dequeue
      40  osal_msg_enqueue
      56  osal_msg_enqueue_max
      40  osal_msg_extract
      36  osal_msg_find
      18  osal_msg_push
      88  osal_msg_receive
      78  osal_msg_send
       2  osal_qHead
       4  osal_rand
      24  osal_revmemcpy
     114  osal_run_system
       6  osal_self
      32  osal_set_event
       8  osal_start_system
       4  osal_strlen

 
 1 426 bytes in segment CODE
     5 bytes in segment DATA16_C
     1 byte  in segment DATA16_I
     1 byte  in segment DATA16_ID
     2 bytes in segment DATA16_Z
 
 1 426 bytes of CODE  memory
     6 bytes of CONST memory
     3 bytes of DATA  memory

Errors: none
Warnings: none
