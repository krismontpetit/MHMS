///////////////////////////////////////////////////////////////////////////////
//                                                                            /
// IAR C/C++ Compiler V5.51.2.50607/W32 for MSP430      26/Apr/2013  14:00:06 /
// Copyright 1996-2012 IAR Systems AB.                                        /
//                                                                            /
//    __rt_version  =  3                                                      /
//    __double_size =  32                                                     /
//    __reg_r4      =  free                                                   /
//    __reg_r5      =  free                                                   /
//    __pic         =  no                                                     /
//    __core        =  430X                                                   /
//    __data_model  =  small                                                  /
//    Source file   =  C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5. /
//                     1\Components\osal\mcu\msp430\OSAL_Nv.c                 /
//    Command line  =  -f C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2 /
//                     .5.1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\Source\zap /
//                     .cfg (-DTVSA_DEVICE_ID=0x0016 -DTVSA_DONGLE=1          /
//                     -DHAL_UART=1 -DZAP_PHY_SPI=1                           /
//                     -DZAP_PHY_UART=!ZAP_PHY_SPI -DZAP_PHY_RESET_ZNP=TRUE   /
//                     -DZAP_ZNP_MT=FALSE -DZAP_APP_MSG=FALSE                 /
//                     -DZAP_SBL_PROXY=FALSE -DZAP_AUTO_CFG=TRUE              /
//                     -DZAP_AUTO_START=TRUE -DZAP_NV_RESTORE=FALSE           /
//                     -DLCD_SUPPORTED -DZAP_AF_DATA_REQ_FRAG=FALSE           /
//                     -DZAP_AF_DATA_REQ_AREQ=!ZAP_AF_DATA_REQ_FRAG           /
//                     -DZAP_ZDO_STARTUP_AREQ=TRUE -DZAP_AF_FUNC              /
//                     -DZAP_SAPI_FUNC -DZAP_SYS_FUNC -DZAP_UTIL_FUNC         /
//                     -DZAP_ZDO_FUNC -DSECURE=0 -DZG_SECURE_DYNAMIC=0        /
//                     "-DDEFAULT_CHANLIST=(uint32)0x00000800"                /
//                     -DZDAPP_CONFIG_PAN_ID=0xFFFF -DPOLL_RATE=1000          /
//                     -DNWK_START_DELAY=100 -DMAX_BINDING_CLUSTER_IDS=4)     /
//                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5. /
//                     1\Components\osal\mcu\msp430\OSAL_Nv.c -lC             /
//                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5. /
//                     1\Projects\zstack\ZAP\TVSA\EXP5438\Routinator\List\    /
//                     -lA C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430- /
//                     2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\Routinator\List /
//                     \ --remarks --diag_suppress Pe001,Pe193,Pe236,Pe826    /
//                     -o C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2 /
//                     .5.1\Projects\zstack\ZAP\TVSA\EXP5438\Routinator\Obj\  /
//                     --debug -D__MSP430F5438A__ -e --double=32 --clib -I    /
//                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5. /
//                     1\Projects\zstack\ZAP\TVSA\EXP5438\ -I                 /
//                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5. /
//                     1\Projects\zstack\ZAP\TVSA\EXP5438\..\Source\ -I       /
//                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5. /
//                     1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\Source\ -I    /
//                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5. /
//                     1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Comp /
//                     onents\hal\target\MSP5438ZAP\ -I                       /
//                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5. /
//                     1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Comp /
//                     onents\hal\include\ -I C:\Users\student\Documents\GitH /
//                     ub\MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5 /
//                     438\..\..\..\..\..\Components\mac\include\ -I          /
//                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5. /
//                     1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Comp /
//                     onents\mt\ -I C:\Users\student\Documents\GitHub\MHMS\Z /
//                     AP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\..\.. /
//                     \..\..\..\Components\osal\include\ -I                  /
//                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5. /
//                     1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Comp /
//                     onents\osal\mcu\msp430\ -I                             /
//                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5. /
//                     1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Comp /
//                     onents\services\saddr\ -I C:\Users\student\Documents\G /
//                     itHub\MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\E /
//                     XP5438\..\..\..\..\..\Components\services\sdata\ -I    /
//                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5. /
//                     1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Comp /
//                     onents\stack\af\ -I C:\Users\student\Documents\GitHub\ /
//                     MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438 /
//                     \..\..\..\..\..\Components\stack\nwk\ -I               /
//                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5. /
//                     1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Comp /
//                     onents\stack\sapi\ -I C:\Users\student\Documents\GitHu /
//                     b\MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP54 /
//                     38\..\..\..\..\..\Components\stack\sec\ -I             /
//                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5. /
//                     1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Comp /
//                     onents\stack\sys\ -I C:\Users\student\Documents\GitHub /
//                     \MHMS\ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP543 /
//                     8\..\..\..\..\..\Components\stack\zdo\ -I              /
//                     C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5. /
//                     1\Projects\zstack\ZAP\TVSA\EXP5438\..\..\..\..\..\Comp /
//                     onents\zmac\ -I C:\Users\student\Documents\GitHub\MHMS /
//                     \ZAP-MSP430-2.5.1\Projects\zstack\ZAP\TVSA\EXP5438\..\ /
//                     ..\..\..\..\Components\zmac\f8w\ --core=430X           /
//                     --data_model=small -Ohz --multiplier=32                /
//                     --multiplier_location=4C0 --require_prototypes         /
//                     --hw_workaround=CPU40 --hw_workaround=CPU42            /
//    List file     =  C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5. /
//                     1\Projects\zstack\ZAP\TVSA\EXP5438\Routinator\List\OSA /
//                     L_Nv.s43                                               /
//                                                                            /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////

        NAME OSAL_Nv

        RTMODEL "__SystemLibrary", "CLib"
        RTMODEL "__core", "430X"
        RTMODEL "__data_model", "small"
        RTMODEL "__double_size", "32"
        RTMODEL "__pic", "no"
        RTMODEL "__reg_r4", "free"
        RTMODEL "__reg_r5", "free"
        RTMODEL "__rt_version", "3"

        RSEG CSTACK:DATA:SORT:NOROOT(0)

        EXTERN ?cstart_init_zero
        EXTERN ?longjmp_r4
        EXTERN ?longjmp_r5
        EXTERN ?setjmp_r4
        EXTERN ?setjmp_r5

        PUBWEAK ?setjmp_save_r4
        PUBWEAK ?setjmp_save_r5
        PUBLIC _nvBuf
        FUNCTION calcChkF,0203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        FUNCTION compactPage,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 32, STACK
        FUNCTION erasePage,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 8, STACK
        FUNCTION findItem,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 12, STACK
        FUNCTION hotItem,0203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        FUNCTION hotItemUpdate,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 6, STACK
        FUNCTION initItem,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 24, STACK
        FUNCTION initNV,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 20, STACK
        FUNCTION initPage,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 26, STACK
        PUBLIC osal_nv_delete
        FUNCTION osal_nv_delete,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 14, STACK
        PUBLIC osal_nv_init
        FUNCTION osal_nv_init,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC osal_nv_item_init
        FUNCTION osal_nv_item_init,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 14, STACK
        PUBLIC osal_nv_item_len
        FUNCTION osal_nv_item_len,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 16, STACK
        PUBLIC osal_nv_read
        FUNCTION osal_nv_read,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 14, STACK
        PUBLIC osal_nv_write
        FUNCTION osal_nv_write,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 40, STACK
        FUNCTION readHdr,0203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        FUNCTION setItem,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 20, STACK
        FUNCTION setPageUse,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 12, STACK
        FUNCTION writeItem,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 34, STACK
        FUNCTION xferBuf,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 8, STACK
        
          CFI Names cfiNames0
          CFI StackFrame CFA SP DATA
          CFI Resource PC:20, SP:20, SR:16, R4L:16, R4H:4, R4:20, R5L:16, R5H:4
          CFI Resource R5:20, R6L:16, R6H:4, R6:20, R7L:16, R7H:4, R7:20, R8L:16
          CFI Resource R8H:4, R8:20, R9L:16, R9H:4, R9:20, R10L:16, R10H:4
          CFI Resource R10:20, R11L:16, R11H:4, R11:20, R12L:16, R12H:4, R12:20
          CFI Resource R13L:16, R13H:4, R13:20, R14L:16, R14H:4, R14:20, R15L:16
          CFI Resource R15H:4, R15:20
          CFI ResourceParts R4 R4H, R4L
          CFI ResourceParts R5 R5H, R5L
          CFI ResourceParts R6 R6H, R6L
          CFI ResourceParts R7 R7H, R7L
          CFI ResourceParts R8 R8H, R8L
          CFI ResourceParts R9 R9H, R9L
          CFI ResourceParts R10 R10H, R10L
          CFI ResourceParts R11 R11H, R11L
          CFI ResourceParts R12 R12H, R12L
          CFI ResourceParts R13 R13H, R13L
          CFI ResourceParts R14 R14H, R14L
          CFI ResourceParts R15 R15H, R15L
          CFI EndNames cfiNames0
        
          CFI Common cfiCommon0 Using cfiNames0
          CFI CodeAlign 2
          CFI DataAlign 2
          CFI ReturnAddress PC CODE
          CFI CFA SP+4
          CFI PC Frame(CFA, -4)
          CFI SR Undefined
          CFI R4L SameValue
          CFI R4H 0
          CFI R4 Concat
          CFI R5L SameValue
          CFI R5H 0
          CFI R5 Concat
          CFI R6L SameValue
          CFI R6H 0
          CFI R6 Concat
          CFI R7L SameValue
          CFI R7H 0
          CFI R7 Concat
          CFI R8L SameValue
          CFI R8H 0
          CFI R8 Concat
          CFI R9L SameValue
          CFI R9H 0
          CFI R9 Concat
          CFI R10L SameValue
          CFI R10H 0
          CFI R10 Concat
          CFI R11L SameValue
          CFI R11H 0
          CFI R11 Concat
          CFI R12L Undefined
          CFI R12H Undefined
          CFI R12 Undefined
          CFI R13L Undefined
          CFI R13H Undefined
          CFI R13 Undefined
          CFI R14L Undefined
          CFI R14H Undefined
          CFI R14 Undefined
          CFI R15L Undefined
          CFI R15H Undefined
          CFI R15 Undefined
          CFI EndCommon cfiCommon0
        
        
          CFI Common cfiCommon1 Using cfiNames0
          CFI CodeAlign 2
          CFI DataAlign 2
          CFI ReturnAddress PC CODE
          CFI CFA SP+4
          CFI PC Frame(CFA, -4)
          CFI SR Undefined
          CFI R4L SameValue
          CFI R4H 0
          CFI R4 Concat
          CFI R5L SameValue
          CFI R5H 0
          CFI R5 Concat
          CFI R6L SameValue
          CFI R6H 0
          CFI R6 Concat
          CFI R7L SameValue
          CFI R7H 0
          CFI R7 Concat
          CFI R8L SameValue
          CFI R8H 0
          CFI R8 Concat
          CFI R9L SameValue
          CFI R9H 0
          CFI R9 Concat
          CFI R10L SameValue
          CFI R10H 0
          CFI R10 Concat
          CFI R11L SameValue
          CFI R11H 0
          CFI R11 Concat
          CFI R12L SameValue
          CFI R12H 0
          CFI R12 Concat
          CFI R13L SameValue
          CFI R13H 0
          CFI R13 Concat
          CFI R14L SameValue
          CFI R14H 0
          CFI R14 Concat
          CFI R15L SameValue
          CFI R15H 0
          CFI R15 Concat
          CFI EndCommon cfiCommon1
        
        EXTERN flashWrite
        FUNCTION flashWrite,0202H
        EXTERN flashErasePage
        FUNCTION flashErasePage,0202H
        EXTERN HalAdcCheckVdd
        FUNCTION HalAdcCheckVdd,0202H

// C:\Users\student\Documents\GitHub\MHMS\ZAP-MSP430-2.5.1\Components\osal\mcu\msp430\OSAL_Nv.c
//    1 /******************************************************************************
//    2   Filename:       OSAL_Nv.c
//    3   Revised:        $Date: 2011-06-05 18:52:21 -0700 (Sun, 05 Jun 2011) $
//    4   Revision:       $Revision: 26212 $
//    5 
//    6   Description:    This module contains the OSAL non-volatile memory functions.
//    7 
//    8 
//    9   Copyright 2006-2011 Texas Instruments Incorporated. All rights reserved.
//   10 
//   11   IMPORTANT: Your use of this Software is limited to those specific rights
//   12   granted under the terms of a software license agreement between the user
//   13   who downloaded the software, his/her employer (which must be your employer)
//   14   and Texas Instruments Incorporated (the "License"). You may not use this
//   15   Software unless you agree to abide by the terms of the License. The License
//   16   limits your use, and you acknowledge, that the Software may not be modified,
//   17   copied or distributed unless embedded on a Texas Instruments microcontroller
//   18   or used solely and exclusively in conjunction with a Texas Instruments radio
//   19   frequency transceiver, which is integrated into your product. Other than for
//   20   the foregoing purpose, you may not use, reproduce, copy, prepare derivative
//   21   works of, modify, distribute, perform, display or sell this Software and/or
//   22   its documentation for any purpose.
//   23 
//   24   YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
//   25   PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
//   26   INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
//   27   NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
//   28   TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
//   29   NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
//   30   LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
//   31   INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
//   32   OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
//   33   OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
//   34   (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
//   35 
//   36   Should you have any questions regarding your right to use this Software,
//   37   contact Texas Instruments Incorporated at www.TI.com.
//   38 ******************************************************************************/
//   39 
//   40 /******************************************************************************
//   41   Notes:
//   42     - A trick buried deep in initPage() requires that the MSB of the NV Item Id
//   43       is to be reserved for use by this module.
//   44 ******************************************************************************/
//   45 
//   46 /*********************************************************************
//   47  * INCLUDES
//   48  */
//   49 
//   50 #include "hal_adc.h"
//   51 #include "hal_board_cfg.h"
//   52 #include "MSP430FlashUtil.h"
//   53 #include "OSAL_Nv.h"
//   54 #include "ZComDef.h"
//   55 
//   56 /*********************************************************************
//   57  * CONSTANTS
//   58  */
//   59 
//   60 /* Physical pages per OSAL logical page - increase to get bigger OSAL_NV_ITEMs.
//   61  * Changing this number requires a corresponding change in the linker file, currently
//   62  * $PROJ_DIR$\..\..\..\Tools\"Processor Specific Name"\"Specific Name".xcl
//   63  */
//   64 #ifndef OSAL_NV_PHY_PER_PG
//   65   #define OSAL_NV_PHY_PER_PG    2
//   66 #endif
//   67 
//   68 #define OSAL_NV_PAGES_USED     (HAL_NV_PAGE_CNT / OSAL_NV_PHY_PER_PG)
//   69 #if (OSAL_NV_PAGES_USED < 2)
//   70 #error Need to increase the NV_PG_CNT or decrease the OSAL_NV_PHY_PER_PG.
//   71 #endif
//   72 
//   73 #if (HAL_NV_PAGE_CNT != (OSAL_NV_PAGES_USED * OSAL_NV_PHY_PER_PG))
//   74 #error HAL_NV_PAGE_CNT must be a multiple of OSAL_NV_PHY_PER_PG
//   75 #endif
//   76 
//   77 #define OSAL_NV_PAGE_SIZE      (OSAL_NV_PHY_PER_PG * HAL_FLASH_PAGE_SIZE)
//   78 
//   79 #define OSAL_NV_ACTIVE          0x00
//   80 #define OSAL_NV_ERASED          0xFF
//   81 #define OSAL_NV_ERASED_ID       0xFFFF
//   82 #define OSAL_NV_ZEROED_ID       0x0000
//   83 // Reserve MSB of Id to signal a search for the "old" source copy (new write interrupted/failed.)
//   84 #define OSAL_NV_SOURCE_ID       0x8000
//   85 
//   86 // In case pages 0-1 are ever used, define a null page value.
//   87 #define OSAL_NV_PAGE_NULL       OSAL_NV_PAGES_USED
//   88 
//   89 // In case item Id 0 is ever used, define a null item value.
//   90 #define OSAL_NV_ITEM_NULL       0
//   91 
//   92 #define OSAL_NV_WORD_SIZE       HAL_FLASH_WORD_SIZE
//   93 
//   94 #define OSAL_NV_PAGE_HDR_OFFSET 0
//   95 
//   96 #define OSAL_NV_MAX_HOT         3

        RSEG DATA16_C:CONST:SORT:NOROOT(1)
//   97 static const uint16 hotIds[OSAL_NV_MAX_HOT] = {
hotIds:
        DC16 130, 58, 59
//   98   ZCD_NV_NWKKEY,
//   99   ZCD_NV_NWK_ACTIVE_KEY_INFO,
//  100   ZCD_NV_NWK_ALTERN_KEY_INFO,
//  101 };
//  102 
//  103 /*********************************************************************
//  104  * MACROS
//  105  */
//  106 
//  107 #define OSAL_NV_CHECK_BUS_VOLTAGE  HalAdcCheckVdd(VDD_MIN_NV)
//  108 
//  109 #define OSAL_NV_DATA_SIZE( LEN )  \ 
//  110    ((((LEN) + OSAL_NV_WORD_SIZE - 1) / OSAL_NV_WORD_SIZE) * OSAL_NV_WORD_SIZE)
//  111 
//  112 #define OSAL_NV_ITEM_SIZE( LEN )  \ 
//  113   (((((LEN) + OSAL_NV_WORD_SIZE - 1) / OSAL_NV_WORD_SIZE) * OSAL_NV_WORD_SIZE) + OSAL_NV_HDR_SIZE)
//  114 
//  115 #define COMPACT_PAGE_CLEANUP( COM_PG ) st ( \ 
//  116   /* In order to recover from a page compaction that is interrupted,\ 
//  117    * the logic in osal_nv_init() depends upon the following order:\ 
//  118    * 1. State of the target of compaction is changed to ePgInUse.\ 
//  119    * 2. Compacted page is erased.\ 
//  120    */\ 
//  121   setPageUse( pgRes, TRUE );  /* Mark the reserve page as being in use. */\ 
//  122   erasePage( (COM_PG) ); \ 
//  123   \ 
//  124   pgRes = (COM_PG);           /* Set the reserve page to be the newly erased page. */\ 
//  125 )
//  126 
//  127 // The NV pages must be located in lower flash to simplify read/write operations to using pointers.
//  128 #define OSAL_NV_PAGE_TO_PTR(pg) \ 
//  129   ((uint8 *)((uint8 *)((HAL_NV_PAGE_BEG + ((pg) * OSAL_NV_PHY_PER_PG)) * HAL_FLASH_PAGE_SIZE)))
//  130 
//  131 /*********************************************************************
//  132  * TYPEDEFS
//  133  */
//  134 
//  135 typedef struct
//  136 {
//  137   uint16 id;
//  138   uint16 len;   // Enforce Flash-WORD size on len.
//  139   uint16 chk;   // Byte-wise checksum of the 'len' data bytes of the item.
//  140   uint16 stat;  // Item status.
//  141 } osalNvHdr_t;
//  142 // Struct member offsets.
//  143 #define OSAL_NV_HDR_ID    0
//  144 #define OSAL_NV_HDR_LEN   2
//  145 #define OSAL_NV_HDR_CHK   4
//  146 #define OSAL_NV_HDR_STAT  6
//  147 
//  148 #define OSAL_NV_HDR_ITEM  2  // Length of any item of a header struct.
//  149 #define OSAL_NV_HDR_SIZE  8
//  150 #define OSAL_NV_HDR_HALF (OSAL_NV_HDR_SIZE / 2)
//  151 
//  152 typedef struct
//  153 {
//  154   uint16 active;
//  155   uint16 inUse;
//  156   uint16 xfer;
//  157   uint16 spare;
//  158 } osalNvPgHdr_t;
//  159 // Struct member offsets.
//  160 #define OSAL_NV_PG_ACTIVE 0
//  161 #define OSAL_NV_PG_INUSE  2
//  162 #define OSAL_NV_PG_XFER   4
//  163 #define OSAL_NV_PG_SPARE  6
//  164 
//  165 #define OSAL_NV_PAGE_HDR_SIZE  8
//  166 #define OSAL_NV_PAGE_HDR_HALF (OSAL_NV_PAGE_HDR_SIZE / 2)
//  167 
//  168 typedef enum
//  169 {
//  170   eNvXfer,
//  171   eNvZero
//  172 } eNvHdrEnum;
//  173 
//  174 typedef enum
//  175 {
//  176   ePgActive,
//  177   ePgInUse,
//  178   ePgXfer,
//  179   ePgSpare
//  180 } ePgHdrEnum;
//  181 
//  182 /*********************************************************************
//  183  * GLOBAL VARIABLES
//  184  */
//  185 
//  186 #ifndef OAD_KEEP_NV_PAGES
//  187 // When NV pages are to remain intact during OAD download,
//  188 // the image itself should not include NV pages.
//  189 #pragma location="ZIGNV_ADDRESS_SPACE"

        RSEG ZIGNV_ADDRESS_SPACE:DATA:SORT:NOROOT(0)
//  190 __no_init uint8 _nvBuf[OSAL_NV_PAGES_USED * OSAL_NV_PAGE_SIZE];
_nvBuf:
        DS8 12288
//  191 #pragma required=_nvBuf
//  192 #endif // OAD_KEEP_NV_PAGES
//  193 
//  194 /*********************************************************************
//  195  * LOCAL VARIABLES
//  196  */
//  197 
//  198 // Offset into the page of the first available erased space.

        RSEG DATA16_Z:DATA:SORT:NOROOT(1)
        REQUIRE ?cstart_init_zero
//  199 static uint16 pgOff[OSAL_NV_PAGES_USED];
pgOff:
        DS8 24
        REQUIRE _nvBuf
//  200 
//  201 // Count of the bytes lost for the zeroed-out items.

        RSEG DATA16_Z:DATA:SORT:NOROOT(1)
        REQUIRE ?cstart_init_zero
//  202 static uint16 pgLost[OSAL_NV_PAGES_USED];
pgLost:
        DS8 24
//  203 

        RSEG DATA16_Z:DATA:SORT:NOROOT(0)
        REQUIRE ?cstart_init_zero
//  204 static uint8 pgRes;  // Page reserved for item compacting transfer.
pgRes:
        DS8 1
//  205 
//  206 // NV page and offsets for hot items.

        RSEG DATA16_Z:DATA:SORT:NOROOT(0)
        REQUIRE ?cstart_init_zero
//  207 static uint8 hotPg[OSAL_NV_MAX_HOT];
hotPg:
        DS8 3

        RSEG DATA16_Z:DATA:SORT:NOROOT(1)
        REQUIRE ?cstart_init_zero
//  208 static uint16 hotOff[OSAL_NV_MAX_HOT];
hotOff:
        DS8 6
//  209 
//  210 /*********************************************************************
//  211  * LOCAL FUNCTIONS
//  212  */
//  213 
//  214 static uint8  initNV( void );
//  215 
//  216 static void   setPageUse( uint8 pg, uint8 inUse );
//  217 static uint16 initPage( uint8 pg, uint16 id, uint8 findDups );
//  218 static void   erasePage( uint8 pg );
//  219 static uint8  compactPage( uint8 srcPg, uint16 skipId );
//  220 
//  221 static uint16 findItem( uint16 id, uint8 *findPg );
//  222 static uint8  initItem( uint8 flag, uint16 id, uint16 len, void *buf );
//  223 static void   setItem( uint8 pg, uint16 offset, eNvHdrEnum stat );
//  224 
//  225 static uint16 calcChkB( uint16 len, uint8 *buf );
//  226 static uint16 calcChkF( uint8 pg, uint16 offset, uint16 len );
//  227 
//  228 static void   readHdr( uint8 pg, uint16 offset, uint8 *buf );
//  229 
//  230 static void   writeBuf( uint8 pg, uint16 offset, uint16 len, uint8 *buf );
//  231 static void   xferBuf( uint8 srcPg, uint16 srcOff, uint8 dstPg, uint16 dstOff, uint16 len );
//  232 
//  233 static uint8  writeItem( uint8 pg, uint16 id, uint16 len, void *buf, uint8 flag );
//  234 static uint8  hotItem(uint16 id);
//  235 static void   hotItemUpdate(uint8 pg, uint16 off, uint16 id);
//  236 
//  237 /*********************************************************************
//  238  * @fn      initNV
//  239  *
//  240  * @brief   Initialize the NV flash pages.
//  241  *
//  242  * @param   none
//  243  *
//  244  * @return  TRUE
//  245  */
//  246 static uint8 initNV( void )
//  247 {
//  248   osalNvPgHdr_t pgHdr;
//  249   uint8 oldPg = OSAL_NV_PAGE_NULL;
//  250   uint8 findDups = FALSE;
//  251   uint8 pg;
//  252 
//  253   pgRes = OSAL_NV_PAGE_NULL;
//  254 
//  255   for ( pg = 0; pg < OSAL_NV_PAGES_USED; pg++ )
//  256   {
//  257     readHdr( pg, OSAL_NV_PAGE_HDR_OFFSET, (uint8 *)(&pgHdr) );
//  258 
//  259     if ( pgHdr.active == OSAL_NV_ERASED_ID )
//  260     {
//  261       if ( pgRes == OSAL_NV_PAGE_NULL )
//  262       {
//  263         pgRes = pg;
//  264       }
//  265       else
//  266       {
//  267         setPageUse( pg, TRUE );
//  268       }
//  269     }
//  270     // An Xfer from this page was in progress.
//  271     else if ( pgHdr.xfer != OSAL_NV_ERASED_ID )
//  272     {
//  273       oldPg = pg;
//  274     }
//  275   }
//  276 
//  277   // If a page compaction was interrupted before the old page was erased.
//  278   if ( oldPg != OSAL_NV_PAGE_NULL )
//  279   {
//  280     /* Interrupted compaction before the target of compaction was put in use;
//  281      * so erase the target of compaction and start again.
//  282      */
//  283     if ( pgRes != OSAL_NV_PAGE_NULL )
//  284     {
//  285       erasePage( pgRes );
//  286       (void)compactPage( oldPg, OSAL_NV_ITEM_NULL );
//  287     }
//  288     /* Interrupted compaction after the target of compaction was put in use,
//  289      * but before the old page was erased; so erase it now and create a new reserve page.
//  290      */
//  291     else
//  292     {
//  293       erasePage( oldPg );
//  294       pgRes = oldPg;
//  295     }
//  296   }
//  297   else if ( pgRes != OSAL_NV_PAGE_NULL )
//  298   {
//  299     erasePage( pgRes );  // The last page erase could have been interrupted by a power-cycle.
//  300   }
//  301   /* else if there is no reserve page, COMPACT_PAGE_CLEANUP() must have succeeded to put the old
//  302    * reserve page (i.e. the target of the compacted items) into use but got interrupted by a reset
//  303    * while trying to erase the page to be compacted. Such a page should only contain duplicate items
//  304    * (i.e. all items will be marked 'Xfer') and thus should have the lost count equal to the page
//  305    * size less the page header.
//  306    */
//  307 
//  308   for ( pg = 0; pg < OSAL_NV_PAGES_USED; pg++ )
//  309   {
//  310     // Calculate page offset and lost bytes - any "old" item triggers an N^2 re-scan from start.
//  311     if ( initPage( pg, OSAL_NV_ITEM_NULL, findDups ) != OSAL_NV_ITEM_NULL )
//  312     {
//  313       findDups = TRUE;
//  314       pg = (256 - 1);  // Pre-decrement so that loop increment will start over at zero.
//  315       continue;
//  316     }
//  317   }
//  318 
//  319   if (findDups)
//  320   {
//  321     // Final pass to calculate page lost after invalidating duplicate items.
//  322     for ( pg = 0; pg < OSAL_NV_PAGES_USED; pg++ )
//  323     {
//  324       (void)initPage( pg, OSAL_NV_ITEM_NULL, FALSE );
//  325     }
//  326   }
//  327 
//  328   if ( pgRes == OSAL_NV_PAGE_NULL )
//  329   {
//  330     uint8 idx, mostLost = 0;
//  331 
//  332     for ( idx = 0; idx < OSAL_NV_PAGES_USED; idx++ )
//  333     {
//  334       // Is this the page that was compacted?
//  335       if (pgLost[idx] == (OSAL_NV_PAGE_SIZE - OSAL_NV_PAGE_HDR_SIZE))
//  336       {
//  337         mostLost = idx;
//  338         break;
//  339       }
//  340       /* This check is not expected to be necessary because the above test should always succeed
//  341        * with an early loop exit.
//  342        */
//  343       else if (pgLost[idx] > pgLost[mostLost])
//  344       {
//  345         mostLost = idx;
//  346       }
//  347     }
//  348 
//  349     pgRes = mostLost;
//  350     erasePage( pgRes );  // The last page erase had been interrupted by a power-cycle.
//  351   }
//  352 
//  353   return TRUE;
//  354 }
//  355 
//  356 /*********************************************************************
//  357  * @fn      setPageUse
//  358  *
//  359  * @brief   Set page header active/inUse state according to 'inUse'.
//  360  *
//  361  * @param   pg - Valid NV page to verify and init.
//  362  * @param   inUse - Boolean TRUE if inUse, FALSE if only active.
//  363  *
//  364  * @return  none
//  365  */
//  366 static void setPageUse( uint8 pg, uint8 inUse )
//  367 {
//  368   osalNvPgHdr_t pgHdr;
//  369 
//  370   pgHdr.active = OSAL_NV_ZEROED_ID;
//  371 
//  372   if ( inUse )
//  373   {
//  374     pgHdr.inUse = OSAL_NV_ZEROED_ID;
//  375   }
//  376   else
//  377   {
//  378     pgHdr.inUse = OSAL_NV_ERASED_ID;
//  379   }
//  380 
//  381   flashWrite(OSAL_NV_PAGE_TO_PTR(pg)+OSAL_NV_PAGE_HDR_OFFSET, OSAL_NV_HDR_HALF, (uint8 *)(&pgHdr));
//  382 }
//  383 
//  384 /*********************************************************************
//  385  * @fn      initPage
//  386  *
//  387  * @brief   Walk the page items; calculate checksums, lost bytes & page offset.
//  388  *
//  389  * @param   pg - Valid NV page to verify and init.
//  390  * @param   id - Valid NV item Id to use function as a "findItem".
//  391  *               If set to NULL then just perform the page initialization.
//  392  * @param   findDups - TRUE on recursive call from initNV() to find and zero-out duplicate items
//  393  *                     left from a write that is interrupted by a reset/power-cycle.
//  394  *                     FALSE otherwise.
//  395  *
//  396  * @return  If 'id' is non-NULL and good checksums are found, return the offset
//  397  *          of the data corresponding to item Id; else OSAL_NV_ITEM_NULL.
//  398  */
//  399 static uint16 initPage( uint8 pg, uint16 id, uint8 findDups )
//  400 {
//  401   uint16 offset = OSAL_NV_PAGE_HDR_SIZE;
//  402   uint16 sz, lost = 0;
//  403   osalNvHdr_t hdr;
//  404 
//  405   do
//  406   {
//  407     readHdr( pg, offset, (uint8 *)(&hdr) );
//  408 
//  409     if ( hdr.id == OSAL_NV_ERASED_ID )
//  410     {
//  411       break;
//  412     }
//  413 
//  414     // Get the actual size in bytes which is the ceiling(hdr.len)
//  415     sz = OSAL_NV_DATA_SIZE( hdr.len );
//  416 
//  417     // A bad 'len' write has blown away the rest of the page.
//  418     if (sz > (OSAL_NV_PAGE_SIZE - OSAL_NV_HDR_SIZE - offset))
//  419     {
//  420       lost += (OSAL_NV_PAGE_SIZE - offset);
//  421       offset = OSAL_NV_PAGE_SIZE;
//  422       break;
//  423     }
//  424 
//  425     offset += OSAL_NV_HDR_SIZE;
//  426 
//  427     if ( hdr.id != OSAL_NV_ZEROED_ID )
//  428     {
//  429       /* This trick allows function to do double duty for findItem() without
//  430        * compromising its essential functionality at powerup initialization.
//  431        */
//  432       if ( id != OSAL_NV_ITEM_NULL )
//  433       {
//  434         /* This trick allows asking to find the old/transferred item in case
//  435          * of a successful new item write that gets interrupted before the
//  436          * old item can be zeroed out.
//  437          */
//  438         if ( (id & 0x7fff) == hdr.id )
//  439         {
//  440           if ( (((id & OSAL_NV_SOURCE_ID) == 0) && (hdr.stat == OSAL_NV_ERASED_ID)) ||
//  441                (((id & OSAL_NV_SOURCE_ID) != 0) && (hdr.stat != OSAL_NV_ERASED_ID)) )
//  442           {
//  443             return offset;
//  444           }
//  445         }
//  446       }
//  447       // When invoked from the osal_nv_init(), verify checksums and find & zero any duplicates.
//  448       else
//  449       {
//  450         if ( hdr.chk == calcChkF( pg, offset, hdr.len ) )
//  451         {
//  452           if ( findDups )
//  453           {
//  454             if ( hdr.stat == OSAL_NV_ERASED_ID )
//  455             {
//  456               /* The trick of setting the MSB of the item Id causes the logic
//  457                * immediately above to return a valid page only if the header 'stat'
//  458                * indicates that it was the older item being transferred.
//  459                */
//  460               uint8 findPg;
//  461               uint16 off = findItem( (hdr.id | OSAL_NV_SOURCE_ID), &findPg );
//  462 
//  463               if ( off != OSAL_NV_ITEM_NULL )
//  464               {
//  465                 setItem( findPg, off, eNvZero );  // Mark old duplicate as invalid.
//  466               }
//  467             }
//  468           }
//  469           // Any "old" item immediately exits and triggers the N^2 exhaustive initialization.
//  470           else if ( hdr.stat != OSAL_NV_ERASED_ID )
//  471           {
//  472             return OSAL_NV_ERASED_ID;
//  473           }
//  474         }
//  475         else
//  476         {
//  477           setItem( pg, offset, eNvZero );  // Mark bad checksum as invalid.
//  478           lost += (OSAL_NV_HDR_SIZE + sz);
//  479         }
//  480       }
//  481     }
//  482     else
//  483     {
//  484       lost += (OSAL_NV_HDR_SIZE + sz);
//  485     }
//  486     offset += sz;
//  487 
//  488   } while (offset < (OSAL_NV_PAGE_SIZE - OSAL_NV_HDR_SIZE));
//  489 
//  490   pgOff[pg] = offset;
//  491   pgLost[pg] = lost;
//  492 
//  493   return OSAL_NV_ITEM_NULL;
//  494 }
//  495 
//  496 /*********************************************************************
//  497  * @fn      erasePage
//  498  *
//  499  * @brief   Erases a page in Flash.
//  500  *
//  501  * @param   pg - Valid NV page to erase.
//  502  *
//  503  * @return  none
//  504  */
//  505 static void erasePage( uint8 pg )
//  506 {
//  507   uint8 *addr = OSAL_NV_PAGE_TO_PTR(pg);
//  508   uint8 cnt = OSAL_NV_PHY_PER_PG;
//  509 
//  510   do {
//  511     flashErasePage(addr);
//  512     addr += HAL_FLASH_PAGE_SIZE;
//  513   } while (--cnt);
//  514 
//  515   pgOff[pg] = OSAL_NV_PAGE_HDR_SIZE;
//  516   pgLost[pg] = 0;
//  517 }
//  518 
//  519 /*********************************************************************
//  520  * @fn      compactPage
//  521  *
//  522  * @brief   Compacts the page specified.
//  523  *
//  524  * @param   srcPg - Valid NV page to erase.
//  525  * @param   skipId - Item Id to not compact.
//  526  *
//  527  * @return  TRUE if valid items from 'srcPg' are successully compacted onto the 'pgRes';
//  528  *          FALSE otherwise.
//  529  *          Note that on a failure, this could loop, re-erasing the 'pgRes' and re-compacting with
//  530  *          the risk of infinitely looping on HAL flash failure.
//  531  *          Worst case scenario: HAL flash starts failing in general, perhaps low Vdd?
//  532  *          All page compactions will fail which will cause all osal_nv_write() calls to return
//  533  *          NV_OPER_FAILED.
//  534  *          Eventually, all pages in use may also be in the state of "pending compaction" where
//  535  *          the page header member OSAL_NV_PG_XFER is zeroed out.
//  536  *          During this "HAL flash brown-out", the code will run and OTA should work (until low Vdd
//  537  *          causes an actual chip brown-out, of course.) Although no new NV items will be created
//  538  *          or written, the last value written with a return value of SUCCESS can continue to be
//  539  *          read successfully.
//  540  *          If eventually HAL flash starts working again, all of the pages marked as
//  541  *          "pending compaction" may or may not be eventually compacted. But, initNV() will
//  542  *          deterministically clean-up one page pending compaction per power-cycle
//  543  *          (if HAL flash is working.) Nevertheless, one erased reserve page will be maintained
//  544  *          through such a scenario.
//  545  */
//  546 static uint8 compactPage( uint8 srcPg, uint16 skipId )
//  547 {
//  548   uint16 srcOff = OSAL_NV_PAGE_HDR_SIZE;
//  549   uint8 rtrn = TRUE;
//  550 
//  551   while ( srcOff < (OSAL_NV_PAGE_SIZE - OSAL_NV_HDR_SIZE ) )
//  552   {
//  553     osalNvHdr_t hdr;
//  554     uint16 sz, dstOff = pgOff[pgRes];
//  555 
//  556     readHdr( srcPg, srcOff, (uint8 *)(&hdr) );
//  557 
//  558     if ( hdr.id == OSAL_NV_ERASED_ID )
//  559     {
//  560       break;
//  561     }
//  562 
//  563     // Get the actual size in bytes which is the ceiling(hdr.len)
//  564     sz = OSAL_NV_DATA_SIZE( hdr.len );
//  565 
//  566     if ( (sz > (OSAL_NV_PAGE_SIZE - OSAL_NV_HDR_SIZE - srcOff)) ||
//  567          (sz > (OSAL_NV_PAGE_SIZE - OSAL_NV_HDR_SIZE - dstOff)) )
//  568     {
//  569       break;
//  570     }
//  571 
//  572     srcOff += OSAL_NV_HDR_SIZE;
//  573 
//  574     if ( (hdr.id != OSAL_NV_ZEROED_ID) && (hdr.id != skipId) )
//  575     {
//  576       if ( hdr.chk == calcChkF( srcPg, srcOff, hdr.len ) )
//  577       {
//  578         /* Prevent excessive re-writes to item header caused by numerous, rapid, & successive
//  579          * OSAL_Nv interruptions caused by resets.
//  580          */
//  581         if ( hdr.stat == OSAL_NV_ERASED_ID )
//  582         {
//  583           setItem( srcPg, srcOff, eNvXfer );
//  584         }
//  585 
//  586         if ( writeItem( pgRes, hdr.id, hdr.len, NULL, FALSE ) )
//  587         {
//  588           uint16 chk;
//  589 
//  590           dstOff += OSAL_NV_HDR_SIZE;
//  591           xferBuf( srcPg, srcOff, pgRes, dstOff, sz );
//  592           // Calculate and write the new checksum.
//  593           chk = calcChkF( pgRes, dstOff, hdr.len );
//  594           dstOff -= OSAL_NV_HDR_SIZE;
//  595           flashWrite(OSAL_NV_PAGE_TO_PTR(pgRes) + dstOff + OSAL_NV_HDR_CHK, OSAL_NV_HDR_ITEM,
//  596                                                                             (uint8 *)(&chk));
//  597           chk = hdr.chk;
//  598           readHdr( pgRes, dstOff, (uint8 *)(&hdr) );
//  599 
//  600           if ( chk != hdr.chk )
//  601           {
//  602             rtrn = FALSE;
//  603             break;
//  604           }
//  605           else
//  606           {
//  607             hotItemUpdate(pgRes, dstOff+OSAL_NV_HDR_SIZE, hdr.id);
//  608           }
//  609         }
//  610         else
//  611         {
//  612           rtrn = FALSE;
//  613           break;
//  614         }
//  615       }
//  616     }
//  617 
//  618     srcOff += sz;
//  619   }
//  620 
//  621   if (rtrn == FALSE)
//  622   {
//  623     erasePage(pgRes);
//  624   }
//  625   else if (skipId == OSAL_NV_ITEM_NULL)
//  626   {
//  627     COMPACT_PAGE_CLEANUP(srcPg);
//  628   }
//  629   // else invoking function must cleanup.
//  630 
//  631   return rtrn;
//  632 }
//  633 
//  634 /*********************************************************************
//  635  * @fn      findItem
//  636  *
//  637  * @brief   Find an item Id in NV and return the page and offset to its data.
//  638  *
//  639  * @param   id - Valid NV item Id.
//  640  *
//  641  * @return  Offset of data corresponding to item Id, if found;
//  642  *          otherwise OSAL_NV_ITEM_NULL.
//  643  *
//  644  *          The page containing the item, if found;
//  645  *          otherwise no valid assignment made - left equal to item Id.
//  646  *
//  647  */
//  648 static uint16 findItem( uint16 id, uint8 *findPg )
//  649 {
//  650   uint16 off;
//  651   uint8 pg;
//  652 
//  653   for ( pg = 0; pg < OSAL_NV_PAGES_USED; pg++ )
//  654   {
//  655     if ( (off = initPage( pg, id, FALSE )) != OSAL_NV_ITEM_NULL )
//  656     {
//  657       *findPg = pg;
//  658       return off;
//  659     }
//  660   }
//  661 
//  662   // Now attempt to find the item as the "old" item of a failed/interrupted NV write.
//  663   if ( (id & OSAL_NV_SOURCE_ID) == 0 )
//  664   {
//  665     return findItem( (id | OSAL_NV_SOURCE_ID), findPg );
//  666   }
//  667   else
//  668   {
//  669     *findPg = OSAL_NV_PAGE_NULL;
//  670     return OSAL_NV_ITEM_NULL;
//  671   }
//  672 }
//  673 
//  674 /*********************************************************************
//  675  * @fn      initItem
//  676  *
//  677  * @brief   An NV item is created and initialized with the data passed to the function, if any.
//  678  *
//  679  * @param   flag - TRUE if the 'buf' parameter contains data for the call to writeItem().
//  680  *                 (i.e. if invoked from osal_nv_item_init() ).
//  681  *                 FALSE if writeItem() should just write the header and the 'buf' parameter
//  682  *                 is ok to use as a return value of the page number to be cleaned with
//  683  *                 COMPACT_PAGE_CLEANUP().
//  684  *                 (i.e. if invoked from osal_nv_write() ).
//  685  * @param   id  - Valid NV item Id.
//  686  * @param   len - Item data length.
//  687  * @param  *buf - Pointer to item initalization data. Set to NULL if none.
//  688  *
//  689  * @return  The OSAL Nv page number if item write and read back checksums ok;
//  690  *          OSAL_NV_PAGE_NULL otherwise.
//  691  */
//  692 static uint8 initItem( uint8 flag, uint16 id, uint16 len, void *buf )
//  693 {
//  694   uint16 sz = OSAL_NV_ITEM_SIZE( len );
//  695   uint8 rtrn = OSAL_NV_PAGE_NULL;
//  696   uint8 cnt = OSAL_NV_PAGES_USED;
//  697   uint8 pg = pgRes+1;  // Set to 1 after the reserve page to even wear across all available pages.
//  698 
//  699   do {
//  700     if (pg >= OSAL_NV_PAGES_USED)
//  701     {
//  702       pg = 0;
//  703     }
//  704     if ( pg != pgRes )
//  705     {
//  706       if ( sz <= (OSAL_NV_PAGE_SIZE - pgOff[pg] + pgLost[pg]) )
//  707       {
//  708         break;
//  709       }
//  710     }
//  711     pg++;
//  712   } while (--cnt);
//  713 
//  714   if (cnt)
//  715   {
//  716     // Item fits if an old page is compacted.
//  717     if ( sz > (OSAL_NV_PAGE_SIZE - pgOff[pg]) )
//  718     {
//  719       // Mark the old page as being in process of compaction.
//  720       sz = OSAL_NV_ZEROED_ID;
//  721       flashWrite(OSAL_NV_PAGE_TO_PTR(pg) + OSAL_NV_PAGE_HDR_OFFSET + OSAL_NV_PG_XFER,
//  722                                            OSAL_NV_HDR_ITEM, (uint8 *)(&sz));
//  723 
//  724       /* First the old page is compacted, then the new item will be the last one written to what
//  725        * had been the reserved page.
//  726        */
//  727       if (compactPage( pg, id ))
//  728       {
//  729         if ( writeItem( pgRes, id, len, buf, flag ) )
//  730         {
//  731           rtrn = pgRes;
//  732         }
//  733 
//  734         if ( flag == FALSE )
//  735         {
//  736           /* Overload 'buf' as an OUT parameter to pass back to the calling function
//  737            * the old page to be cleaned up.
//  738            */
//  739           *(uint8 *)buf = pg;
//  740         }
//  741         else
//  742         {
//  743           /* Safe to do the compacted page cleanup even if writeItem() above failed because the
//  744            * item does not yet exist since this call with flag==TRUE is from osal_nv_item_init().
//  745            */
//  746           COMPACT_PAGE_CLEANUP( pg );
//  747         }
//  748       }
//  749     }
//  750     else
//  751     {
//  752       if ( writeItem( pg, id, len, buf, flag ) )
//  753       {
//  754         rtrn = pg;
//  755       }
//  756     }
//  757   }
//  758 
//  759   return rtrn;
//  760 }
//  761 
//  762 /*********************************************************************
//  763  * @fn      setItem
//  764  *
//  765  * @brief   Set an item Id or status to mark its state.
//  766  *
//  767  * @param   pg - Valid NV page.
//  768  * @param   offset - Valid offset into the page of the item data - the header
//  769  *                   offset is calculated from this.
//  770  * @param   stat - Valid enum value for the item status.
//  771  *
//  772  * @return  none
//  773  */

        RSEG CODE:CODE:NOROOT(1)
//  774 static void setItem( uint8 pg, uint16 offset, eNvHdrEnum stat )
setItem:
          CFI Block cfiBlock0 Using cfiCommon0
          CFI Function setItem
//  775 {
        FUNCALL setItem, readHdr
        LOCFRAME CSTACK, 20, STACK
        FUNCALL setItem, flashWrite
        LOCFRAME CSTACK, 20, STACK
        FUNCALL setItem, flashWrite
        LOCFRAME CSTACK, 20, STACK
        PUSHM.W #0x4, R11
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+12
        SUB.W   #0x8, SP
          CFI CFA SP+20
        MOV.B   R12, R11
        MOV.W   R13, R8
        MOV.B   R14, R10
//  776   osalNvHdr_t hdr;
//  777 
//  778   offset -= OSAL_NV_HDR_SIZE;
        SUB.W   #0x8, R8
//  779   readHdr( pg, offset, (uint8 *)(&hdr) );
        MOV.W   SP, R9
        ADD.W   #0x0, R9
        MOV.W   R9, R14
        MOV.W   R8, R13
        CALLA   #readHdr
//  780 
//  781   if ( stat == eNvXfer )
        RLA.W   R11
        MOV.W   R11, R12
        CALLA   #??Subroutine2_1
??CrossCallReturnLabel_21:
        ADD.W   R8, R12
        CMP.B   #0x0, R10
        JNE     ??setItem_0
//  782   {
//  783     hdr.stat = OSAL_NV_ACTIVE;
        MOV.W   #0x0, 0x6(SP)
//  784     flashWrite(OSAL_NV_PAGE_TO_PTR(pg) + offset + OSAL_NV_HDR_STAT, OSAL_NV_HDR_ITEM,
//  785                                                              (uint8 *)(&(hdr.stat)));
        ADD.W   #0x6, R9
        MOV.W   R9, R14
        MOV.W   #0x2, R13
        ADD.W   #0x6, R12
        CALLA   #flashWrite
        JMP     ??setItem_1
//  786   }
//  787   else // if ( stat == eNvZero )
//  788   {
//  789     uint16 sz = ((hdr.len + (OSAL_NV_WORD_SIZE-1)) / OSAL_NV_WORD_SIZE) * OSAL_NV_WORD_SIZE +
//  790                                                                           OSAL_NV_HDR_SIZE;
??setItem_0:
        MOV.W   0x2(SP), R10
        ADD.W   #0x8, R10
//  791     hdr.id = 0;
        MOV.W   #0x0, 0(SP)
//  792     flashWrite(OSAL_NV_PAGE_TO_PTR(pg) + offset, OSAL_NV_HDR_ITEM, (uint8*)(&hdr));
        MOV.W   R9, R14
        MOV.W   #0x2, R13
        CALLA   #flashWrite
//  793     pgLost[pg] += sz;
        ADD.W   R10, pgLost(R11)
          CFI EndBlock cfiBlock0
//  794   }
//  795 }
??setItem_1:
        REQUIRE ?Subroutine0
        // Fall through to label ?Subroutine0

        RSEG CODE:CODE:NOROOT(1)
?Subroutine0:
          CFI Block cfiBlock1 Using cfiCommon0
          CFI NoFunction
          CFI CFA SP+20
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
        ADD.W   #0x8, SP
          CFI CFA SP+12
        POPM.W  #0x4, R11
          CFI CFA SP+4
          CFI R8L SameValue
          CFI R9L SameValue
          CFI R10L SameValue
          CFI R11L SameValue
        RETA
          CFI EndBlock cfiBlock1

        RSEG CODE:CODE:NOROOT(1)
calcChkF:
          CFI Block cfiBlock2 Using cfiCommon0
          CFI Function calcChkF
        MOV.B   R12, R15
        RLA.W   R15
        ADD.W   #0x65, R15
        RPT     #0x9
        RLAX.W  R15
        ADD.W   R13, R15
        MOV.W   #0x0, R12
        JMP     ??calcChkF_1
??calcChkF_0:
        MOV.B   @R15+, R13
        ADD.W   R13, R12
??calcChkF_1:
        MOV.W   R14, R13
        ADD.W   #0xffff, R14
        CMP.W   #0x0, R13
        JNE     ??calcChkF_0
        RETA
          CFI EndBlock cfiBlock2

        RSEG CODE:CODE:NOROOT(1)
initPage:
          CFI Block cfiBlock3 Using cfiCommon0
          CFI Function initPage
        FUNCALL initPage, readHdr
        LOCFRAME CSTACK, 26, STACK
        FUNCALL initPage, calcChkF
        LOCFRAME CSTACK, 26, STACK
        FUNCALL initPage, findItem
        LOCFRAME CSTACK, 26, STACK
        FUNCALL initPage, setItem
        LOCFRAME CSTACK, 26, STACK
        FUNCALL initPage, setItem
        LOCFRAME CSTACK, 26, STACK
        PUSHM.W #0x6, R11
          CFI R6L Frame(CFA, -16)
          CFI R7L Frame(CFA, -14)
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+16
        SUB.W   #0xa, SP
          CFI CFA SP+26
        MOV.B   R12, R10
        MOV.W   R13, R11
        MOV.B   R14, R8
        MOV.W   #0x8, R9
        MOV.W   #0x0, R6
??initPage_0:
        CALLA   #?Subroutine4
??CrossCallReturnLabel_15:
        CMP.W   #0xffff, 0x2(SP)
        JEQ     ??initPage_1
        CALLA   #?Subroutine7
??CrossCallReturnLabel_5:
        JC      ??initPage_2
        ADD.W   #0x400, R6
        SUB.W   R9, R6
        MOV.W   #0x400, R9
        JMP     ??initPage_1
??initPage_2:
        ADD.W   #0x8, R9
        CMP.W   #0x0, 0x2(SP)
        JEQ     ??initPage_3
        CMP.W   #0x0, R11
        JEQ     ??initPage_4
        MOV.W   R11, R15
        AND.W   #0x7fff, R15
        CMP.W   0x2(SP), R15
        JNE     ??initPage_5
        MOV.W   0x8(SP), R15
        CMP.W   #0x0, R11
        JL      ??initPage_6
        CMP.W   #0xffff, R15
        JNE     ??initPage_5
        JMP     ??initPage_7
??initPage_6:
        CMP.W   #0xffff, R15
        JEQ     ??initPage_5
??initPage_7:
        MOV.W   R9, R12
        JMP     ??initPage_8
??initPage_4:
        CALLA   #?Subroutine5
??CrossCallReturnLabel_0:
        JNE     ??initPage_9
        MOV.W   0x8(SP), R15
        CMP.B   #0x0, R8
        JEQ     ??initPage_10
        CMP.W   #0xffff, R15
        JNE     ??initPage_5
        MOV.W   SP, R13
        ADD.W   #0x0, R13
        MOV.W   0x2(SP), R12
        BIS.W   #0x8000, R12
        CALLA   #findItem
        MOV.W   R12, R13
        CMP.W   #0x0, R12
        JEQ     ??initPage_5
        MOV.B   #0x1, R14
        CALLA   #??Subroutine8_0
??CrossCallReturnLabel_17:
        JMP     ??initPage_5
??initPage_10:
        CMP.W   #0xffff, R15
        JEQ     ??initPage_5
        MOV.W   #0xffff, R12
        JMP     ??initPage_8
??initPage_9:
        MOV.B   #0x1, R14
        MOV.W   R9, R13
        MOV.B   R10, R12
        CALLA   #setItem
        MOV.W   R7, R15
        JMP     ??initPage_11
??initPage_3:
        MOV.W   R14, R15
??initPage_11:
        ADD.W   #0x8, R15
        ADD.W   R15, R6
??initPage_5:
        ADD.W   R7, R9
        CMP.W   #0x3f8, R9
        JNC     ??initPage_0
??initPage_1:
        RLA.W   R10
        MOV.W   R9, pgOff(R10)
        MOV.W   R6, pgLost(R10)
        MOV.W   #0x0, R12
??initPage_8:
        ADD.W   #0xa, SP
          CFI CFA SP+16
        POPM.W  #0x6, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R6L SameValue
          CFI R7L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock3

        RSEG CODE:CODE:NOROOT(1)
?Subroutine4:
          CFI Block cfiCond4 Using cfiCommon0
          CFI Function initPage
          CFI Conditional ??CrossCallReturnLabel_15
          CFI R6L Frame(CFA, -16)
          CFI R7L Frame(CFA, -14)
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+30
          CFI Block cfiCond5 Using cfiCommon0
          CFI (cfiCond5) Function compactPage
          CFI (cfiCond5) Conditional ??CrossCallReturnLabel_14
          CFI (cfiCond5) R4L Frame(CFA, -20)
          CFI (cfiCond5) R5L Frame(CFA, -18)
          CFI (cfiCond5) R6L Frame(CFA, -16)
          CFI (cfiCond5) R7L Frame(CFA, -14)
          CFI (cfiCond5) R8L Frame(CFA, -12)
          CFI (cfiCond5) R9L Frame(CFA, -10)
          CFI (cfiCond5) R10L Frame(CFA, -8)
          CFI (cfiCond5) R11L Frame(CFA, -6)
          CFI (cfiCond5) CFA SP+34
          CFI Block cfiPicker6 Using cfiCommon1
          CFI (cfiPicker6) NoFunction
          CFI (cfiPicker6) Picker
        MOV.W   SP, R14
        ADD.W   #0x6, R14
          CFI EndBlock cfiCond4
          CFI EndBlock cfiCond5
          CFI EndBlock cfiPicker6
        REQUIRE ??Subroutine12_0
        // Fall through to label ??Subroutine12_0

        RSEG CODE:CODE:NOROOT(1)
??Subroutine12_0:
          CFI Block cfiCond7 Using cfiCommon0
          CFI Function writeItem
          CFI Conditional ??CrossCallReturnLabel_13
          CFI R4L Frame(CFA, -20)
          CFI R5L Frame(CFA, -18)
          CFI R6L Frame(CFA, -16)
          CFI R7L Frame(CFA, -14)
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+36
          CFI Block cfiCond8 Using cfiCommon0
          CFI (cfiCond8) Function initPage
          CFI (cfiCond8) Conditional ??CrossCallReturnLabel_15
          CFI (cfiCond8) R6L Frame(CFA, -16)
          CFI (cfiCond8) R7L Frame(CFA, -14)
          CFI (cfiCond8) R8L Frame(CFA, -12)
          CFI (cfiCond8) R9L Frame(CFA, -10)
          CFI (cfiCond8) R10L Frame(CFA, -8)
          CFI (cfiCond8) R11L Frame(CFA, -6)
          CFI (cfiCond8) CFA SP+30
          CFI Block cfiCond9 Using cfiCommon0
          CFI (cfiCond9) Function compactPage
          CFI (cfiCond9) Conditional ??CrossCallReturnLabel_14
          CFI (cfiCond9) R4L Frame(CFA, -20)
          CFI (cfiCond9) R5L Frame(CFA, -18)
          CFI (cfiCond9) R6L Frame(CFA, -16)
          CFI (cfiCond9) R7L Frame(CFA, -14)
          CFI (cfiCond9) R8L Frame(CFA, -12)
          CFI (cfiCond9) R9L Frame(CFA, -10)
          CFI (cfiCond9) R10L Frame(CFA, -8)
          CFI (cfiCond9) R11L Frame(CFA, -6)
          CFI (cfiCond9) CFA SP+34
          CFI Block cfiPicker10 Using cfiCommon1
          CFI (cfiPicker10) NoFunction
          CFI (cfiPicker10) Picker
        MOV.W   R9, R13
          CFI EndBlock cfiCond7
          CFI EndBlock cfiCond8
          CFI EndBlock cfiCond9
          CFI EndBlock cfiPicker10
        REQUIRE ??Subroutine4_0
        // Fall through to label ??Subroutine4_0

        RSEG CODE:CODE:NOROOT(1)
??Subroutine4_0:
          CFI Block cfiCond11 Using cfiCommon0
          CFI Function writeItem
          CFI Conditional ??CrossCallReturnLabel_12
          CFI R4L Frame(CFA, -20)
          CFI R5L Frame(CFA, -18)
          CFI R6L Frame(CFA, -16)
          CFI R7L Frame(CFA, -14)
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+36
          CFI Block cfiCond12 Using cfiCommon0
          CFI (cfiCond12) Function osal_nv_write
          CFI (cfiCond12) Conditional ??CrossCallReturnLabel_11
          CFI (cfiCond12) R4L Frame(CFA, -20)
          CFI (cfiCond12) R5L Frame(CFA, -18)
          CFI (cfiCond12) R6L Frame(CFA, -16)
          CFI (cfiCond12) R7L Frame(CFA, -14)
          CFI (cfiCond12) R8L Frame(CFA, -12)
          CFI (cfiCond12) R9L Frame(CFA, -10)
          CFI (cfiCond12) R10L Frame(CFA, -8)
          CFI (cfiCond12) R11L Frame(CFA, -6)
          CFI (cfiCond12) CFA SP+44
          CFI Block cfiCond13 Using cfiCommon0
          CFI (cfiCond13) Function writeItem
          CFI (cfiCond13) Conditional ??CrossCallReturnLabel_13
          CFI (cfiCond13) R4L Frame(CFA, -20)
          CFI (cfiCond13) R5L Frame(CFA, -18)
          CFI (cfiCond13) R6L Frame(CFA, -16)
          CFI (cfiCond13) R7L Frame(CFA, -14)
          CFI (cfiCond13) R8L Frame(CFA, -12)
          CFI (cfiCond13) R9L Frame(CFA, -10)
          CFI (cfiCond13) R10L Frame(CFA, -8)
          CFI (cfiCond13) R11L Frame(CFA, -6)
          CFI (cfiCond13) CFA SP+36
          CFI Block cfiCond14 Using cfiCommon0
          CFI (cfiCond14) Function initPage
          CFI (cfiCond14) Conditional ??CrossCallReturnLabel_15
          CFI (cfiCond14) R6L Frame(CFA, -16)
          CFI (cfiCond14) R7L Frame(CFA, -14)
          CFI (cfiCond14) R8L Frame(CFA, -12)
          CFI (cfiCond14) R9L Frame(CFA, -10)
          CFI (cfiCond14) R10L Frame(CFA, -8)
          CFI (cfiCond14) R11L Frame(CFA, -6)
          CFI (cfiCond14) CFA SP+30
          CFI Block cfiCond15 Using cfiCommon0
          CFI (cfiCond15) Function compactPage
          CFI (cfiCond15) Conditional ??CrossCallReturnLabel_14
          CFI (cfiCond15) R4L Frame(CFA, -20)
          CFI (cfiCond15) R5L Frame(CFA, -18)
          CFI (cfiCond15) R6L Frame(CFA, -16)
          CFI (cfiCond15) R7L Frame(CFA, -14)
          CFI (cfiCond15) R8L Frame(CFA, -12)
          CFI (cfiCond15) R9L Frame(CFA, -10)
          CFI (cfiCond15) R10L Frame(CFA, -8)
          CFI (cfiCond15) R11L Frame(CFA, -6)
          CFI (cfiCond15) CFA SP+34
          CFI Block cfiPicker16 Using cfiCommon1
          CFI (cfiPicker16) NoFunction
          CFI (cfiPicker16) Picker
        MOV.B   R10, R12
        BRA     #readHdr
          CFI EndBlock cfiCond11
          CFI EndBlock cfiCond12
          CFI EndBlock cfiCond13
          CFI EndBlock cfiCond14
          CFI EndBlock cfiCond15
          CFI EndBlock cfiPicker16

        RSEG CODE:CODE:NOROOT(1)
findItem:
          CFI Block cfiBlock17 Using cfiCommon0
          CFI Function findItem
        FUNCALL findItem, initPage
        LOCFRAME CSTACK, 12, STACK
        PUSHM.W #0x4, R11
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+12
        MOV.W   R12, R10
        MOV.W   R13, R11
        JMP     ??findItem_2
??findItem_1:
        BIS.W   #0x8000, R10
??findItem_2:
        MOV.B   #0x0, R8
??findItem_0:
        MOV.B   #0x0, R14
        MOV.W   R10, R13
        MOV.B   R8, R12
        CALLA   #initPage
        CMP.W   #0x0, R12
        JEQ     ??findItem_3
        MOV.B   R8, 0(R11)
        JMP     ??findItem_4
??findItem_3:
        ADD.B   #0x1, R8
        CMP.B   #0xc, R8
        JNC     ??findItem_0
        CMP.W   #0x0, R10
        JGE     ??findItem_1
        MOV.B   #0xc, 0(R11)
        MOV.W   #0x0, R12
??findItem_4:
        POPM.W  #0x4, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock17
//  796 
//  797 /*********************************************************************
//  798  * @fn      calcChkB
//  799  *
//  800  * @brief   Calculates the data checksum over the 'buf' parameter.
//  801  *
//  802  * @param   len - Byte count of the data to be checksummed.
//  803  * @param   buf - Data buffer to be checksummed.
//  804  *
//  805  * @return  Calculated checksum of the data bytes.
//  806  */
//  807 static uint16 calcChkB( uint16 len, uint8 *buf )
//  808 {
//  809   uint8 fill = len % OSAL_NV_WORD_SIZE;
//  810   uint16 chk;
//  811 
//  812   if ( !buf )
//  813   {
//  814     chk = len * OSAL_NV_ERASED;
//  815   }
//  816   else
//  817   {
//  818     chk = 0;
//  819     while ( len-- )
//  820     {
//  821       chk += *buf++;
//  822     }
//  823   }
//  824 
//  825   // calcChkF() will calculate over OSAL_NV_WORD_SIZE alignment.
//  826   if ( fill )
//  827   {
//  828     chk += (OSAL_NV_WORD_SIZE - fill) * OSAL_NV_ERASED;
//  829   }
//  830 
//  831   return chk;
//  832 }
//  833 
//  834 /*********************************************************************
//  835  * @fn      calcChkF
//  836  *
//  837  * @brief   Calculates the data checksum by reading the data bytes from NV.
//  838  *
//  839  * @param   pg - A valid NV Flash page.
//  840  * @param   offset - A valid offset into the page.
//  841  * @param   len - Byte count of the data to be checksummed.
//  842  *
//  843  * @return  Calculated checksum of the data bytes.
//  844  */
//  845 static uint16 calcChkF( uint8 pg, uint16 offset, uint16 len )
//  846 {
//  847   uint8 *addr = OSAL_NV_PAGE_TO_PTR( pg ) + offset;
//  848   uint16 chk = 0;
//  849 
//  850   len = (len + (OSAL_NV_WORD_SIZE-1)) / OSAL_NV_WORD_SIZE;
//  851 
//  852   while ( len-- )
//  853   {
//  854     chk += *addr++;
//  855   }
//  856 
//  857   return chk;
//  858 }
//  859 
//  860 /*********************************************************************
//  861  * @fn      readHdr
//  862  *
//  863  * @brief   Reads "sizeof( osalNvHdr_t )" bytes from NV.
//  864  *
//  865  * @param   pg - Valid NV page.
//  866  * @param   offset - Valid offset into the page.
//  867  * @param   buf - Valid buffer space of at least sizeof( osalNvHdr_t ) bytes.
//  868  *
//  869  * @return  none
//  870  */
//  871 static void readHdr( uint8 pg, uint16 offset, uint8 *buf )
//  872 {
//  873   uint8 *addr = OSAL_NV_PAGE_TO_PTR( pg ) + offset;
//  874   uint8 len = OSAL_NV_HDR_SIZE;
//  875 
//  876   do
//  877   {
//  878     *buf++ = *addr++;
//  879   } while ( --len );
//  880 }
//  881 
//  882 /*********************************************************************
//  883  * @fn      writeBuf
//  884  *
//  885  * @brief   Writes a data buffer to NV.
//  886  *
//  887  * @param   dstPg - A valid NV Flash page.
//  888  * @param   offset - A valid offset into the page.
//  889  * @param   len  - Byte count of the data to write.
//  890  * @param   buf  - The data to write.
//  891  *
//  892  * @return  TRUE if data buf checksum matches read back checksum, else FALSE.
//  893  */
//  894 static void writeBuf( uint8 dstPg, uint16 dstOff, uint16 len, uint8 *buf )
//  895 {
//  896   uint8 *addr;
//  897   uint8 idx, rem, tmp[OSAL_NV_WORD_SIZE];
//  898 
//  899   rem = dstOff % OSAL_NV_WORD_SIZE;
//  900   if ( rem )
//  901   {
//  902     dstOff -= rem;
//  903     addr = OSAL_NV_PAGE_TO_PTR( dstPg ) + dstOff;
//  904 
//  905     for ( idx = 0; idx < rem; idx++ )
//  906     {
//  907       tmp[idx] = *addr++;
//  908     }
//  909 
//  910     while ( (idx < OSAL_NV_WORD_SIZE) && len )
//  911     {
//  912       tmp[idx++] = *buf++;
//  913       len--;
//  914     }
//  915 
//  916     while ( idx < OSAL_NV_WORD_SIZE )
//  917     {
//  918       tmp[idx++] = OSAL_NV_ERASED;
//  919     }
//  920 
//  921     flashWrite(OSAL_NV_PAGE_TO_PTR(dstPg) + dstOff, OSAL_NV_WORD_SIZE, tmp);
//  922     dstOff += OSAL_NV_WORD_SIZE;
//  923   }
//  924 
//  925   rem = len % OSAL_NV_WORD_SIZE;
//  926   len = (len / OSAL_NV_WORD_SIZE) * OSAL_NV_WORD_SIZE;
//  927   flashWrite(OSAL_NV_PAGE_TO_PTR(dstPg) + dstOff, len, buf);
//  928 
//  929   if ( rem )
//  930   {
//  931     dstOff += len;
//  932     buf += len;
//  933 
//  934     for ( idx = 0; idx < rem; idx++ )
//  935     {
//  936       tmp[idx] = *buf++;
//  937     }
//  938 
//  939     while ( idx < OSAL_NV_WORD_SIZE )
//  940     {
//  941       tmp[idx++] = OSAL_NV_ERASED;
//  942     }
//  943 
//  944     flashWrite(OSAL_NV_PAGE_TO_PTR(dstPg) + dstOff, OSAL_NV_WORD_SIZE, tmp);
//  945   }
//  946 }
//  947 
//  948 /*********************************************************************
//  949  * @fn      xferBuf
//  950  *
//  951  * @brief   Xfers an NV buffer from one location to another, enforcing OSAL_NV_WORD_SIZE writes.
//  952  *
//  953  * @return  none
//  954  */
//  955 static void xferBuf( uint8 srcPg, uint16 srcOff, uint8 dstPg, uint16 dstOff, uint16 len )
//  956 {
//  957   uint8 *addr;
//  958   uint8 idx, rem, tmp[OSAL_NV_WORD_SIZE];
//  959 
//  960   rem = dstOff % OSAL_NV_WORD_SIZE;
//  961   if ( rem )
//  962   {
//  963     dstOff -= rem;
//  964     addr = OSAL_NV_PAGE_TO_PTR( dstPg ) + dstOff;
//  965 
//  966     for ( idx = 0; idx < rem; idx++ )
//  967     {
//  968       tmp[idx] = *addr++;
//  969     }
//  970 
//  971     addr = OSAL_NV_PAGE_TO_PTR( srcPg ) + srcOff;
//  972 
//  973     while ( (idx < OSAL_NV_WORD_SIZE) && len )
//  974     {
//  975       tmp[idx++] = *addr++;
//  976       srcOff++;
//  977       len--;
//  978     }
//  979 
//  980     while ( idx < OSAL_NV_WORD_SIZE )
//  981     {
//  982       tmp[idx++] = OSAL_NV_ERASED;
//  983     }
//  984 
//  985     flashWrite(OSAL_NV_PAGE_TO_PTR(dstPg) + dstOff, OSAL_NV_WORD_SIZE, tmp);
//  986     dstOff += OSAL_NV_WORD_SIZE;
//  987   }
//  988 
//  989   rem = len % OSAL_NV_WORD_SIZE;
//  990   len = (len / OSAL_NV_WORD_SIZE) * OSAL_NV_WORD_SIZE;
//  991   addr = OSAL_NV_PAGE_TO_PTR( srcPg ) + srcOff;
//  992   flashWrite(OSAL_NV_PAGE_TO_PTR(dstPg) + dstOff, len, addr);
//  993 
//  994   if ( rem )
//  995   {
//  996     dstOff += len;
//  997     addr += len;
//  998 
//  999     for ( idx = 0; idx < rem; idx++ )
// 1000     {
// 1001       tmp[idx] = *addr++;
// 1002     }
// 1003 
// 1004     while ( idx < OSAL_NV_WORD_SIZE )
// 1005     {
// 1006       tmp[idx++] = OSAL_NV_ERASED;
// 1007     }
// 1008 
// 1009     flashWrite(OSAL_NV_PAGE_TO_PTR(dstPg) + dstOff, OSAL_NV_WORD_SIZE, tmp);
// 1010   }
// 1011 }
// 1012 
// 1013 /*********************************************************************
// 1014  * @fn      writeItem
// 1015  *
// 1016  * @brief   Writes an item header/data combo to the specified NV page.
// 1017  *
// 1018  * @param   pg - Valid NV Flash page.
// 1019  * @param   id - Valid NV item Id.
// 1020  * @param   len  - Byte count of the data to write.
// 1021  * @param   buf  - The data to write. If NULL, no data/checksum write.
// 1022  * @param   flag - TRUE if the checksum should be written, FALSE otherwise.
// 1023  *
// 1024  * @return  TRUE if header/data to write matches header/data read back, else FALSE.
// 1025  */
// 1026 static uint8 writeItem( uint8 pg, uint16 id, uint16 len, void *buf, uint8 flag )
// 1027 {
// 1028   uint16 offset = pgOff[pg];
// 1029   uint8 rtrn = FALSE;
// 1030   osalNvHdr_t hdr;
// 1031 
// 1032   hdr.id = id;
// 1033   hdr.len = len;
// 1034 
// 1035   flashWrite(OSAL_NV_PAGE_TO_PTR(pg) + offset, OSAL_NV_HDR_HALF, (uint8 *)(&hdr));
// 1036   readHdr( pg, offset, (uint8 *)(&hdr) );
// 1037 
// 1038   if ( (hdr.id == id) && (hdr.len == len) )
// 1039   {
// 1040     if ( flag )
// 1041     {
// 1042       uint16 chk = calcChkB( len, buf );
// 1043 
// 1044       offset += OSAL_NV_HDR_SIZE;
// 1045       if ( buf != NULL )
// 1046       {
// 1047         writeBuf( pg, offset, len, buf );
// 1048       }
// 1049 
// 1050       if ( chk == calcChkF( pg, offset, len ) )
// 1051       {
// 1052         flashWrite(OSAL_NV_PAGE_TO_PTR(pg) + offset - OSAL_NV_HDR_HALF, OSAL_NV_HDR_ITEM,
// 1053                                                                         (uint8 *)(&chk));
// 1054         readHdr( pg, (offset-OSAL_NV_HDR_SIZE), (uint8 *)(&hdr) );
// 1055 
// 1056         if ( chk == hdr.chk )
// 1057         {
// 1058           hotItemUpdate(pg, offset, hdr.id);
// 1059           rtrn = TRUE;
// 1060         }
// 1061       }
// 1062     }
// 1063     else
// 1064     {
// 1065       rtrn = TRUE;
// 1066     }
// 1067 
// 1068     len = OSAL_NV_ITEM_SIZE( hdr.len );
// 1069   }
// 1070   else
// 1071   {
// 1072     len = OSAL_NV_ITEM_SIZE( hdr.len );
// 1073 
// 1074     if (len > (OSAL_NV_PAGE_SIZE - pgOff[pg]))
// 1075     {
// 1076       len = (OSAL_NV_PAGE_SIZE - pgOff[pg]);
// 1077     }
// 1078 
// 1079     pgLost[pg] += len;
// 1080   }
// 1081   pgOff[pg] += len;
// 1082 
// 1083   return rtrn;
// 1084 }
// 1085 
// 1086 /*********************************************************************
// 1087  * @fn      hotItem
// 1088  *
// 1089  * @brief   Look for the parameter 'id' in the hot items array.
// 1090  *
// 1091  * @param   id - A valid NV item Id.
// 1092  *
// 1093  * @return  A valid index into the hot items if the item is hot; OSAL_NV_MAX_HOT if not.
// 1094  */

        RSEG CODE:CODE:NOROOT(1)
// 1095 static uint8 hotItem(uint16 id)
hotItem:
          CFI Block cfiBlock18 Using cfiCommon0
          CFI Function hotItem
// 1096 {
// 1097   uint8 hotIdx;
// 1098 
// 1099   for (hotIdx = 0; hotIdx < OSAL_NV_MAX_HOT; hotIdx++)
        MOV.B   #0x0, R14
// 1100   {
// 1101     if (hotIds[hotIdx] == id)
??hotItem_0:
        MOV.B   R14, R15
        RLA.W   R15
        CMP.W   R12, hotIds(R15)
        JEQ     ??hotItem_1
// 1102     {
// 1103       break;
// 1104     }
// 1105   }
        ADD.B   #0x1, R14
        CMP.B   #0x3, R14
        JNC     ??hotItem_0
// 1106 
// 1107   return hotIdx;
??hotItem_1:
        MOV.B   R14, R12
        RETA
          CFI EndBlock cfiBlock18
// 1108 }
// 1109 
// 1110 /*********************************************************************
// 1111  * @fn      hotItemUpdate
// 1112  *
// 1113  * @brief   If the parameter 'id' is a hot item, update the corresponding hot item data.
// 1114  *
// 1115  * @param   pg - The new NV page corresponding to the hot item.
// 1116  * @param   off - The new NV page offset corresponding to the hot item.
// 1117  * @param   id - A valid NV item Id.
// 1118  *
// 1119  * @return  none
// 1120  */
// 1121 static void hotItemUpdate(uint8 pg, uint16 off, uint16 id)
// 1122 {
// 1123   uint8 hotIdx = hotItem(id);
// 1124 
// 1125   if (hotIdx < OSAL_NV_MAX_HOT)
// 1126   {
// 1127     {
// 1128       hotPg[hotIdx] = pg;
// 1129       hotOff[hotIdx] = off;
// 1130     }
// 1131   }
// 1132 }
// 1133 
// 1134 /*********************************************************************
// 1135  * @fn      osal_nv_init
// 1136  *
// 1137  * @brief   Initialize NV service.
// 1138  *
// 1139  * @param   p - Not used.
// 1140  *
// 1141  * @return  none
// 1142  */
// 1143 void osal_nv_init( void *p )
// 1144 {
// 1145   (void)p;  // Suppress Lint warning.
// 1146   (void)initNV();  // Always returns TRUE after pages have been erased.
// 1147 }
// 1148 
// 1149 /*********************************************************************
// 1150  * @fn      osal_nv_item_init
// 1151  *
// 1152  * @brief   If the NV item does not already exist, it is created and
// 1153  *          initialized with the data passed to the function, if any.
// 1154  *          This function must be called before calling osal_nv_read() or
// 1155  *          osal_nv_write().
// 1156  *
// 1157  * @param   id  - Valid NV item Id.
// 1158  * @param   len - Item length.
// 1159  * @param  *buf - Pointer to item initalization data. Set to NULL if none.
// 1160  *
// 1161  * @return  NV_ITEM_UNINIT - Id did not exist and was created successfully.
// 1162  *          SUCCESS       - Id already existed, no action taken.
// 1163  *          NV_OPER_FAILED - Failure to find or create Id.
// 1164  */
// 1165 uint8 osal_nv_item_init( uint16 id, uint16 len, void *buf )
// 1166 {
// 1167   uint8 findPg;
// 1168   uint16 offset;
// 1169 
// 1170   if ( !OSAL_NV_CHECK_BUS_VOLTAGE )
// 1171   {
// 1172     return NV_OPER_FAILED;
// 1173   }
// 1174   else if ((offset = findItem(id, &findPg)) != OSAL_NV_ITEM_NULL)
// 1175   {
// 1176     // Re-populate the NV hot item data if the corresponding items are already established.
// 1177     hotItemUpdate(findPg, offset, id);
// 1178 
// 1179     return SUCCESS;
// 1180   }
// 1181   else if ( initItem( TRUE, id, len, buf ) != OSAL_NV_PAGE_NULL )
// 1182   {
// 1183     return NV_ITEM_UNINIT;
// 1184   }
// 1185   else
// 1186   {
// 1187     return NV_OPER_FAILED;
// 1188   }
// 1189 }
// 1190 
// 1191 /*********************************************************************
// 1192  * @fn      osal_nv_item_len
// 1193  *
// 1194  * @brief   Get the data length of the item stored in NV memory.
// 1195  *
// 1196  * @param   id  - Valid NV item Id.
// 1197  *
// 1198  * @return  Item length, if found; zero otherwise.
// 1199  */

        RSEG CODE:CODE:NOROOT(1)
// 1200 uint16 osal_nv_item_len( uint16 id )
osal_nv_item_len:
          CFI Block cfiBlock19 Using cfiCommon0
          CFI Function osal_nv_item_len
// 1201 {
        FUNCALL osal_nv_item_len, hotItem
        LOCFRAME CSTACK, 16, STACK
        FUNCALL osal_nv_item_len, readHdr
        LOCFRAME CSTACK, 16, STACK
        FUNCALL osal_nv_item_len, findItem
        LOCFRAME CSTACK, 16, STACK
        PUSH.W  R10
          CFI R10L Frame(CFA, -6)
          CFI CFA SP+6
        SUB.W   #0xa, SP
          CFI CFA SP+16
        MOV.W   R12, R10
// 1202   uint8 findPg;
// 1203   osalNvHdr_t hdr;
// 1204   uint16 offset;
// 1205   uint8 hotIdx;
// 1206 
// 1207   if ((hotIdx = hotItem(id)) < OSAL_NV_MAX_HOT)
        CALLA   #?Subroutine9
??CrossCallReturnLabel_7:
        JC      ??osal_nv_item_len_2
// 1208   {
// 1209     findPg = hotPg[hotIdx];
        CALLA   #?Subroutine3
// 1210     offset = hotOff[hotIdx];
// 1211   }
// 1212   else if ((offset = findItem(id, &findPg)) == OSAL_NV_ITEM_NULL)
// 1213   {
// 1214     return 0;
// 1215   }
// 1216 
// 1217   readHdr( findPg, (offset - OSAL_NV_HDR_SIZE), (uint8 *)(&hdr) );
??osal_nv_item_len_0:
        MOV.W   SP, R14
        ADD.W   #0x2, R14
        SUB.W   #0x8, R12
        MOV.W   R12, R13
        MOV.B   @SP, R12
        CALLA   #readHdr
// 1218   return hdr.len;
        MOV.W   0x4(SP), R12
??osal_nv_item_len_1:
        ADD.W   #0xa, SP
          CFI CFA SP+6
        POP.W   R10
          CFI R10L SameValue
          CFI CFA SP+4
        RETA
          CFI R10L Frame(CFA, -6)
          CFI CFA SP+16
??osal_nv_item_len_2:
        CALLA   #?Subroutine6
??CrossCallReturnLabel_2:
        JNE     ??osal_nv_item_len_0
        MOV.W   #0x0, R12
        JMP     ??osal_nv_item_len_1
        NOP
          CFI EndBlock cfiBlock19
// 1219 }

        RSEG CODE:CODE:NOROOT(1)
osal_nv_delete:
          CFI Block cfiBlock20 Using cfiCommon0
          CFI Function osal_nv_delete
        FUNCALL osal_nv_delete, findItem
        LOCFRAME CSTACK, 14, STACK
        FUNCALL osal_nv_delete, osal_nv_item_len
        LOCFRAME CSTACK, 14, STACK
        FUNCALL osal_nv_delete, setItem
        LOCFRAME CSTACK, 14, STACK
        FUNCALL osal_nv_delete, findItem
        LOCFRAME CSTACK, 14, STACK
        PUSHM.W #0x4, R11
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+12
        SUB.W   #0x2, SP
          CFI CFA SP+14
        MOV.W   R12, R10
        MOV.W   R13, R11
        MOV.W   SP, R13
        ADD.W   #0x0, R13
        CALLA   #findItem
        MOV.W   R12, R8
        CMP.W   #0x0, R12
        JNE     ??osal_nv_delete_1
        MOV.B   #0x9, R12
        JMP     ??osal_nv_delete_0
??osal_nv_delete_1:
        MOV.W   R10, R12
        CALLA   #osal_nv_item_len
        CMP.W   R11, R12
        JEQ     ??osal_nv_delete_2
        MOV.B   #0xc, R12
        JMP     ??osal_nv_delete_0
??osal_nv_delete_2:
        MOV.B   #0x1, R14
        MOV.W   R8, R13
        CALLA   #??Subroutine8_0
??CrossCallReturnLabel_16:
        CALLA   #?Subroutine6
??CrossCallReturnLabel_3:
        JNE     ??osal_nv_delete_3
        MOV.B   #0x0, R12
        JMP     ??osal_nv_delete_0
??osal_nv_delete_3:
        MOV.B   #0xa, R12
          CFI EndBlock cfiBlock20
??osal_nv_delete_0:
        REQUIRE ?Subroutine1
        // Fall through to label ?Subroutine1

        RSEG CODE:CODE:NOROOT(1)
?Subroutine1:
          CFI Block cfiBlock21 Using cfiCommon0
          CFI NoFunction
          CFI CFA SP+14
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
        ADD.W   #0x2, SP
          CFI CFA SP+12
        POPM.W  #0x4, R11
          CFI CFA SP+4
          CFI R8L SameValue
          CFI R9L SameValue
          CFI R10L SameValue
          CFI R11L SameValue
        RETA
          CFI EndBlock cfiBlock21
// 1220 
// 1221 /*********************************************************************
// 1222  * @fn      osal_nv_write
// 1223  *
// 1224  * @brief   Write a data item to NV. Function can write an entire item to NV or
// 1225  *          an element of an item by indexing into the item with an offset.
// 1226  *
// 1227  * @param   id  - Valid NV item Id.
// 1228  * @param   ndx - Index offset into item
// 1229  * @param   len - Length of data to write.
// 1230  * @param  *buf - Data to write.
// 1231  *
// 1232  * @return  SUCCESS if successful, NV_ITEM_UNINIT if item did not
// 1233  *          exist in NV and offset is non-zero, NV_OPER_FAILED if failure.
// 1234  */

        RSEG CODE:CODE:NOROOT(1)
?Subroutine8:
          CFI Block cfiCond22 Using cfiCommon0
          CFI Function osal_nv_write
          CFI Conditional ??osal_nv_write_9
          CFI R4L Frame(CFA, -20)
          CFI R5L Frame(CFA, -18)
          CFI R6L Frame(CFA, -16)
          CFI R7L Frame(CFA, -14)
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+40
          CFI Block cfiCond23 Using cfiCommon0
          CFI (cfiCond23) Function osal_nv_write
          CFI (cfiCond23) Conditional ??osal_nv_write_2
          CFI (cfiCond23) R4L Frame(CFA, -20)
          CFI (cfiCond23) R5L Frame(CFA, -18)
          CFI (cfiCond23) R6L Frame(CFA, -16)
          CFI (cfiCond23) R7L Frame(CFA, -14)
          CFI (cfiCond23) R8L Frame(CFA, -12)
          CFI (cfiCond23) R9L Frame(CFA, -10)
          CFI (cfiCond23) R10L Frame(CFA, -8)
          CFI (cfiCond23) R11L Frame(CFA, -6)
          CFI (cfiCond23) CFA SP+40
          CFI Block cfiPicker24 Using cfiCommon1
          CFI (cfiPicker24) NoFunction
          CFI (cfiPicker24) Picker
// 1235 uint8 osal_nv_write( uint16 id, uint16 ndx, uint16 len, void *buf )
// 1236 {
// 1237   uint8 rtrn = SUCCESS;
// 1238 
// 1239   if ( !OSAL_NV_CHECK_BUS_VOLTAGE )
// 1240   {
// 1241     return NV_OPER_FAILED;
// 1242   }
// 1243   else if ( len != 0 )
// 1244   {
// 1245     osalNvHdr_t hdr;
// 1246     uint16 origOff, srcOff;
// 1247     uint16 cnt, chk;
// 1248     uint8 *addr, *ptr, srcPg;
// 1249 
// 1250     origOff = srcOff = findItem( id, &srcPg );
// 1251     if ( srcOff == OSAL_NV_ITEM_NULL )
// 1252     {
// 1253       return NV_ITEM_UNINIT;
// 1254     }
// 1255 
// 1256     readHdr( srcPg, (srcOff - OSAL_NV_HDR_SIZE), (uint8 *)(&hdr) );
// 1257     if ( hdr.len < (ndx + len) )
// 1258     {
// 1259       return NV_OPER_FAILED;
// 1260     }
// 1261 
// 1262     addr = OSAL_NV_PAGE_TO_PTR( srcPg ) + srcOff + ndx;
// 1263     ptr = buf;
// 1264     cnt = len;
// 1265     chk = 0;
// 1266     while ( cnt-- )
// 1267     {
// 1268       if ( *addr != *ptr )
// 1269       {
// 1270         chk = 1;  // Mark that at least one byte is different.
// 1271         // Calculate expected checksum after transferring old data and writing new data.
// 1272         hdr.chk -= *addr;
// 1273         hdr.chk += *ptr;
// 1274       }
// 1275       addr++;
// 1276       ptr++;
// 1277     }
// 1278 
// 1279     if ( chk != 0 )  // If the buffer to write is different in one or more bytes.
// 1280     {
// 1281       uint8 comPg = OSAL_NV_PAGE_NULL;
// 1282       uint8 dstPg = initItem( FALSE, id, hdr.len, &comPg );
// 1283 
// 1284       if ( dstPg != OSAL_NV_PAGE_NULL )
// 1285       {
// 1286         uint16 tmp = OSAL_NV_DATA_SIZE( hdr.len );
// 1287         uint16 dstOff = pgOff[dstPg] - tmp;
// 1288         srcOff = origOff;
// 1289         chk = hdr.chk;
// 1290 
// 1291         /* Prevent excessive re-writes to item header caused by numerous, rapid, & successive
// 1292          * OSAL_Nv interruptions caused by resets.
// 1293          */
// 1294         if ( hdr.stat == OSAL_NV_ERASED_ID )
// 1295         {
// 1296           setItem( srcPg, srcOff, eNvXfer );
// 1297         }
// 1298 
// 1299         xferBuf( srcPg, srcOff, dstPg, dstOff, ndx );
// 1300         srcOff += ndx;
// 1301         dstOff += ndx;
// 1302 
// 1303         writeBuf( dstPg, dstOff, len, buf );
// 1304         srcOff += len;
// 1305         dstOff += len;
// 1306 
// 1307         xferBuf( srcPg, srcOff, dstPg, dstOff, (hdr.len-ndx-len) );
// 1308 
// 1309         // Calculate and write the new checksum.
// 1310         dstOff = pgOff[dstPg] - tmp;
// 1311         tmp = calcChkF( dstPg, dstOff, hdr.len );
// 1312         dstOff -= OSAL_NV_HDR_SIZE;
// 1313         flashWrite(OSAL_NV_PAGE_TO_PTR(dstPg) + dstOff + OSAL_NV_HDR_CHK, OSAL_NV_HDR_ITEM,
// 1314                                                                           (uint8 *)(&tmp));
// 1315         readHdr( dstPg, dstOff, (uint8 *)(&hdr) );
// 1316 
// 1317         if ( chk != hdr.chk )
// 1318         {
// 1319           rtrn = NV_OPER_FAILED;
// 1320         }
// 1321         else
// 1322         {
// 1323           hotItemUpdate(dstPg, dstOff+OSAL_NV_HDR_SIZE, hdr.id);
// 1324         }
// 1325       }
// 1326       else
// 1327       {
// 1328         rtrn = NV_OPER_FAILED;
// 1329       }
// 1330 
// 1331       if ( comPg != OSAL_NV_PAGE_NULL )
// 1332       {
// 1333         /* Even though the page compaction succeeded, if the new item is coming from the compacted
// 1334          * page and writing the new value failed, then the compaction must be aborted.
// 1335          */
// 1336         if ( (srcPg == comPg) && (rtrn == NV_OPER_FAILED) )
// 1337         {
// 1338           erasePage( pgRes );
// 1339         }
// 1340         else
// 1341         {
// 1342           COMPACT_PAGE_CLEANUP( comPg );
// 1343         }
// 1344       }
// 1345 
// 1346       /* Zero of the old item must wait until after compact page cleanup has finished - if the item
// 1347        * is zeroed before and cleanup is interrupted by a power-cycle, the new item can be lost.
// 1348        */
// 1349       if ( (srcPg != comPg) && (rtrn != NV_OPER_FAILED) )
// 1350       {
// 1351         setItem( srcPg, origOff, eNvZero );
        MOV.W   R11, R13
          CFI EndBlock cfiCond22
          CFI EndBlock cfiCond23
          CFI EndBlock cfiPicker24
        REQUIRE ??Subroutine8_0
        // Fall through to label ??Subroutine8_0

        RSEG CODE:CODE:NOROOT(1)
??Subroutine8_0:
          CFI Block cfiCond25 Using cfiCommon0
          CFI Function initPage
          CFI Conditional ??CrossCallReturnLabel_17
          CFI R6L Frame(CFA, -16)
          CFI R7L Frame(CFA, -14)
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+30
          CFI Block cfiCond26 Using cfiCommon0
          CFI (cfiCond26) Function osal_nv_delete
          CFI (cfiCond26) Conditional ??CrossCallReturnLabel_16
          CFI (cfiCond26) R8L Frame(CFA, -12)
          CFI (cfiCond26) R9L Frame(CFA, -10)
          CFI (cfiCond26) R10L Frame(CFA, -8)
          CFI (cfiCond26) R11L Frame(CFA, -6)
          CFI (cfiCond26) CFA SP+18
          CFI Block cfiCond27 Using cfiCommon0
          CFI (cfiCond27) Function osal_nv_write
          CFI (cfiCond27) Conditional ??osal_nv_write_9
          CFI (cfiCond27) R4L Frame(CFA, -20)
          CFI (cfiCond27) R5L Frame(CFA, -18)
          CFI (cfiCond27) R6L Frame(CFA, -16)
          CFI (cfiCond27) R7L Frame(CFA, -14)
          CFI (cfiCond27) R8L Frame(CFA, -12)
          CFI (cfiCond27) R9L Frame(CFA, -10)
          CFI (cfiCond27) R10L Frame(CFA, -8)
          CFI (cfiCond27) R11L Frame(CFA, -6)
          CFI (cfiCond27) CFA SP+40
          CFI Block cfiCond28 Using cfiCommon0
          CFI (cfiCond28) Function osal_nv_write
          CFI (cfiCond28) Conditional ??osal_nv_write_2
          CFI (cfiCond28) R4L Frame(CFA, -20)
          CFI (cfiCond28) R5L Frame(CFA, -18)
          CFI (cfiCond28) R6L Frame(CFA, -16)
          CFI (cfiCond28) R7L Frame(CFA, -14)
          CFI (cfiCond28) R8L Frame(CFA, -12)
          CFI (cfiCond28) R9L Frame(CFA, -10)
          CFI (cfiCond28) R10L Frame(CFA, -8)
          CFI (cfiCond28) R11L Frame(CFA, -6)
          CFI (cfiCond28) CFA SP+40
          CFI Block cfiPicker29 Using cfiCommon1
          CFI (cfiPicker29) NoFunction
          CFI (cfiPicker29) Picker
        MOV.B   0x4(SP), R12
        BRA     #setItem
          CFI EndBlock cfiCond25
          CFI EndBlock cfiCond26
          CFI EndBlock cfiCond27
          CFI EndBlock cfiCond28
          CFI EndBlock cfiPicker29

        RSEG CODE:CODE:NOROOT(1)
?Subroutine6:
          CFI Block cfiCond30 Using cfiCommon0
          CFI Function osal_nv_item_len
          CFI Conditional ??CrossCallReturnLabel_2
          CFI R10L Frame(CFA, -6)
          CFI CFA SP+20
          CFI Block cfiCond31 Using cfiCommon0
          CFI (cfiCond31) Function osal_nv_delete
          CFI (cfiCond31) Conditional ??CrossCallReturnLabel_3
          CFI (cfiCond31) R8L Frame(CFA, -12)
          CFI (cfiCond31) R9L Frame(CFA, -10)
          CFI (cfiCond31) R10L Frame(CFA, -8)
          CFI (cfiCond31) R11L Frame(CFA, -6)
          CFI (cfiCond31) CFA SP+18
          CFI Block cfiCond32 Using cfiCommon0
          CFI (cfiCond32) Function osal_nv_item_init
          CFI (cfiCond32) Conditional ??CrossCallReturnLabel_4
          CFI (cfiCond32) R8L Frame(CFA, -12)
          CFI (cfiCond32) R9L Frame(CFA, -10)
          CFI (cfiCond32) R10L Frame(CFA, -8)
          CFI (cfiCond32) R11L Frame(CFA, -6)
          CFI (cfiCond32) CFA SP+18
          CFI Block cfiPicker33 Using cfiCommon1
          CFI (cfiPicker33) NoFunction
          CFI (cfiPicker33) Picker
        MOV.W   SP, R13
        ADD.W   #0x4, R13
        MOV.W   R10, R12
        CALLA   #findItem
        CMP.W   #0x0, R12
        RETA
          CFI EndBlock cfiCond30
          CFI EndBlock cfiCond31
          CFI EndBlock cfiCond32
          CFI EndBlock cfiPicker33

        RSEG CODE:CODE:NOROOT(1)
osal_nv_read:
          CFI Block cfiBlock34 Using cfiCommon0
          CFI Function osal_nv_read
        FUNCALL osal_nv_read, hotItem
        LOCFRAME CSTACK, 14, STACK
        FUNCALL osal_nv_read, findItem
        LOCFRAME CSTACK, 14, STACK
        PUSHM.W #0x4, R11
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+12
        SUB.W   #0x2, SP
          CFI CFA SP+14
        MOV.W   R12, R8
        MOV.W   R13, R9
        MOV.W   R14, R10
        MOV.W   R15, R11
        CALLA   #?Subroutine9
??CrossCallReturnLabel_8:
        JC      ??osal_nv_read_2
        CALLA   #?Subroutine3
??osal_nv_read_0:
        CALLA   #?Subroutine10
??CrossCallReturnLabel_19:
        ADD.W   R12, R14
        ADD.W   R9, R14
        JMP     ??osal_nv_read_3
??osal_nv_read_2:
        MOV.W   SP, R13
        ADD.W   #0x0, R13
        MOV.W   R8, R12
        CALLA   #findItem
        CMP.W   #0x0, R12
        JNE     ??osal_nv_read_0
        MOV.B   #0xa, R12
        JMP     ??osal_nv_read_4
??osal_nv_read_1:
        MOV.B   @R14+, 0(R11)
        ADD.W   #0x1, R11
??osal_nv_read_3:
        MOV.W   R10, R15
        ADD.W   #0xffff, R10
        CMP.W   #0x0, R15
        JNE     ??osal_nv_read_1
        MOV.B   #0x0, R12
??osal_nv_read_4:
        JMP     ?Subroutine1
        NOP
          CFI EndBlock cfiBlock34

        RSEG CODE:CODE:NOROOT(1)
?Subroutine10:
          CFI Block cfiCond35 Using cfiCommon0
          CFI Function osal_nv_read
          CFI Conditional ??CrossCallReturnLabel_19
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+18
          CFI Block cfiCond36 Using cfiCommon0
          CFI (cfiCond36) Function osal_nv_write
          CFI (cfiCond36) Conditional ??CrossCallReturnLabel_20
          CFI (cfiCond36) R4L Frame(CFA, -20)
          CFI (cfiCond36) R5L Frame(CFA, -18)
          CFI (cfiCond36) R6L Frame(CFA, -16)
          CFI (cfiCond36) R7L Frame(CFA, -14)
          CFI (cfiCond36) R8L Frame(CFA, -12)
          CFI (cfiCond36) R9L Frame(CFA, -10)
          CFI (cfiCond36) R10L Frame(CFA, -8)
          CFI (cfiCond36) R11L Frame(CFA, -6)
          CFI (cfiCond36) CFA SP+40
          CFI Block cfiPicker37 Using cfiCommon1
          CFI (cfiPicker37) NoFunction
          CFI (cfiPicker37) Picker
        MOV.B   0x4(SP), R14
          CFI EndBlock cfiCond35
          CFI EndBlock cfiCond36
          CFI EndBlock cfiPicker37
        REQUIRE ??Subroutine15_0
        // Fall through to label ??Subroutine15_0

        RSEG CODE:CODE:NOROOT(1)
??Subroutine15_0:
          CFI Block cfiCond38 Using cfiCommon0
          CFI Function xferBuf
          CFI Conditional ??CrossCallReturnLabel_18
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+12
          CFI Block cfiCond39 Using cfiCommon0
          CFI (cfiCond39) Function osal_nv_read
          CFI (cfiCond39) Conditional ??CrossCallReturnLabel_19
          CFI (cfiCond39) R8L Frame(CFA, -12)
          CFI (cfiCond39) R9L Frame(CFA, -10)
          CFI (cfiCond39) R10L Frame(CFA, -8)
          CFI (cfiCond39) R11L Frame(CFA, -6)
          CFI (cfiCond39) CFA SP+18
          CFI Block cfiCond40 Using cfiCommon0
          CFI (cfiCond40) Function osal_nv_write
          CFI (cfiCond40) Conditional ??CrossCallReturnLabel_20
          CFI (cfiCond40) R4L Frame(CFA, -20)
          CFI (cfiCond40) R5L Frame(CFA, -18)
          CFI (cfiCond40) R6L Frame(CFA, -16)
          CFI (cfiCond40) R7L Frame(CFA, -14)
          CFI (cfiCond40) R8L Frame(CFA, -12)
          CFI (cfiCond40) R9L Frame(CFA, -10)
          CFI (cfiCond40) R10L Frame(CFA, -8)
          CFI (cfiCond40) R11L Frame(CFA, -6)
          CFI (cfiCond40) CFA SP+40
          CFI Block cfiPicker41 Using cfiCommon1
          CFI (cfiPicker41) NoFunction
          CFI (cfiPicker41) Picker
        RLA.W   R14
        ADD.W   #0x65, R14
        RPT     #0x9
        RLAX.W  R14
        RETA
          CFI EndBlock cfiCond38
          CFI EndBlock cfiCond39
          CFI EndBlock cfiCond40
          CFI EndBlock cfiPicker41

        RSEG CODE:CODE:NOROOT(1)
?Subroutine9:
          CFI Block cfiCond42 Using cfiCommon0
          CFI Function osal_nv_item_len
          CFI Conditional ??CrossCallReturnLabel_7
          CFI R10L Frame(CFA, -6)
          CFI CFA SP+20
          CFI Block cfiCond43 Using cfiCommon0
          CFI (cfiCond43) Function osal_nv_read
          CFI (cfiCond43) Conditional ??CrossCallReturnLabel_8
          CFI (cfiCond43) R8L Frame(CFA, -12)
          CFI (cfiCond43) R9L Frame(CFA, -10)
          CFI (cfiCond43) R10L Frame(CFA, -8)
          CFI (cfiCond43) R11L Frame(CFA, -6)
          CFI (cfiCond43) CFA SP+18
          CFI Block cfiCond44 Using cfiCommon0
          CFI (cfiCond44) Function hotItemUpdate
          CFI (cfiCond44) Conditional ??CrossCallReturnLabel_9
          CFI (cfiCond44) R10L Frame(CFA, -6)
          CFI (cfiCond44) CFA SP+10
          CFI Block cfiPicker45 Using cfiCommon1
          CFI (cfiPicker45) NoFunction
          CFI (cfiPicker45) Picker
        CALLA   #hotItem
        CMP.B   #0x3, R12
        RETA
          CFI EndBlock cfiCond42
          CFI EndBlock cfiCond43
          CFI EndBlock cfiCond44
          CFI EndBlock cfiPicker45

        RSEG CODE:CODE:NOROOT(1)
?Subroutine3:
          CFI Block cfiCond46 Using cfiCommon0
          CFI Function osal_nv_item_len
          CFI Conditional ??osal_nv_item_len_0
          CFI R10L Frame(CFA, -6)
          CFI CFA SP+20
          CFI Block cfiCond47 Using cfiCommon0
          CFI (cfiCond47) Function osal_nv_read
          CFI (cfiCond47) Conditional ??osal_nv_read_0
          CFI (cfiCond47) R8L Frame(CFA, -12)
          CFI (cfiCond47) R9L Frame(CFA, -10)
          CFI (cfiCond47) R10L Frame(CFA, -8)
          CFI (cfiCond47) R11L Frame(CFA, -6)
          CFI (cfiCond47) CFA SP+18
          CFI Block cfiPicker48 Using cfiCommon1
          CFI (cfiPicker48) NoFunction
          CFI (cfiPicker48) Picker
        MOV.B   R12, R12
        MOV.B   hotPg(R12), 0x4(SP)
        RLA.W   R12
        MOV.W   hotOff(R12), R12
        RETA
          CFI EndBlock cfiCond46
          CFI EndBlock cfiCond47
          CFI EndBlock cfiPicker48

        RSEG CODE:CODE:NOROOT(1)
setPageUse:
          CFI Block cfiBlock49 Using cfiCommon0
          CFI Function setPageUse
        FUNCALL setPageUse, flashWrite
        LOCFRAME CSTACK, 12, STACK
        SUB.W   #0x8, SP
          CFI CFA SP+12
        MOV.W   #0x0, 0(SP)
        CMP.B   #0x0, R13
        JNE     ??setPageUse_0
        MOV.W   #0xffff, R15
        JMP     ??setPageUse_1
??setPageUse_0:
        MOV.W   #0x0, R15
??setPageUse_1:
        MOV.W   R15, 0x2(SP)
        MOV.W   SP, R14
        ADD.W   #0x0, R14
        MOV.W   #0x4, R13
        CALLA   #?Subroutine2
??CrossCallReturnLabel_26:
        CALLA   #flashWrite
        ADD.W   #0x8, SP
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock49

        RSEG CODE:CODE:NOROOT(1)
erasePage:
          CFI Block cfiBlock50 Using cfiCommon0
          CFI Function erasePage
        FUNCALL erasePage, flashErasePage
        LOCFRAME CSTACK, 8, STACK
        FUNCALL erasePage, flashErasePage
        LOCFRAME CSTACK, 8, STACK
        PUSHM.W #0x2, R11
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+8
        MOV.B   R12, R10
        RLA.W   R10
        MOV.W   R10, R11
        ADD.W   #0x65, R11
        RPT     #0x9
        RLAX.W  R11
        MOV.W   R11, R12
        CALLA   #flashErasePage
        ADD.W   #0x200, R11
        MOV.W   R11, R12
        CALLA   #flashErasePage
        MOV.W   #0x8, pgOff(R10)
        MOV.W   #0x0, pgLost(R10)
        POPM.W  #0x2, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock50

        RSEG CODE:CODE:NOROOT(1)
hotItemUpdate:
          CFI Block cfiBlock51 Using cfiCommon0
          CFI Function hotItemUpdate
        FUNCALL hotItemUpdate, hotItem
        LOCFRAME CSTACK, 6, STACK
        PUSH.W  R10
          CFI R10L Frame(CFA, -6)
          CFI CFA SP+6
        MOV.B   R12, R10
        MOV.W   R14, R12
        CALLA   #?Subroutine9
??CrossCallReturnLabel_9:
        JC      ??hotItemUpdate_0
        MOV.B   R12, R12
        MOV.B   R10, hotPg(R12)
        RLA.W   R12
        MOV.W   R13, hotOff(R12)
??hotItemUpdate_0:
        POP.W   R10
          CFI R10L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock51

        RSEG CODE:CODE:NOROOT(1)
xferBuf:
          CFI Block cfiBlock52 Using cfiCommon0
          CFI Function xferBuf
        FUNCALL xferBuf, flashWrite
        LOCFRAME CSTACK, 8, STACK
        PUSHM.W #0x2, R11
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+8
        MOV.B   R12, R10
        MOV.B   R14, R12
        MOV.W   0x8(SP), R11
        MOV.B   R10, R14
        CALLA   #??Subroutine15_0
??CrossCallReturnLabel_18:
        ADD.W   R13, R14
        MOV.W   R11, R13
        CALLA   #??Subroutine2_0
??CrossCallReturnLabel_23:
        ADD.W   R15, R12
        CALLA   #flashWrite
        POPM.W  #0x2, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock52

        RSEG CODE:CODE:NOROOT(1)
writeItem:
          CFI Block cfiBlock53 Using cfiCommon0
          CFI Function writeItem
        FUNCALL writeItem, flashWrite
        LOCFRAME CSTACK, 32, STACK
        FUNCALL writeItem, readHdr
        LOCFRAME CSTACK, 32, STACK
        FUNCALL writeItem, flashWrite
        LOCFRAME CSTACK, 32, STACK
        FUNCALL writeItem, calcChkF
        LOCFRAME CSTACK, 32, STACK
        FUNCALL writeItem, flashWrite
        LOCFRAME CSTACK, 32, STACK
        FUNCALL writeItem, readHdr
        LOCFRAME CSTACK, 32, STACK
        FUNCALL writeItem, hotItemUpdate
        LOCFRAME CSTACK, 32, STACK
        PUSHM.W #0x8, R11
          CFI R4L Frame(CFA, -20)
          CFI R5L Frame(CFA, -18)
          CFI R6L Frame(CFA, -16)
          CFI R7L Frame(CFA, -14)
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+20
        PUSH.W  R13
          CFI CFA SP+22
        SUB.W   #0xa, SP
          CFI CFA SP+32
        MOV.B   R12, R10
        MOV.W   R14, R11
        MOV.W   R15, R5
        MOV.B   R12, R8
        RLA.W   R8
        MOV.W   pgOff(R8), R9
        MOV.B   #0x0, R6
        MOV.W   0xa(SP), 0x2(SP)
        MOV.W   R14, 0x4(SP)
        MOV.W   R8, R7
        ADD.W   #0x65, R7
        RPT     #0x9
        RLAX.W  R7
        MOV.W   SP, R4
        ADD.W   #0x2, R4
        MOV.W   R4, R14
        MOV.W   #0x4, R13
        MOV.W   R7, R12
        ADD.W   R9, R12
        CALLA   #flashWrite
        MOV.W   R4, R14
        CALLA   #??Subroutine12_0
??CrossCallReturnLabel_13:
        MOV.W   0x4(SP), R15
        CMP.W   0xa(SP), 0x2(SP)
        JNE     ??writeItem_2
        CMP.W   R11, R15
        JNE     ??writeItem_2
        CMP.B   #0x0, 0x20(SP)
        JEQ     ??writeItem_1
        MOV.W   R5, R15
        MOV.W   R11, R13
        CMP.W   #0x0, R5
        JNE     ??writeItem_3
        PUSH.W  SR
          CFI CFA SP+34
        DINT
        NOP
        MOV.W   R11, &0x4c0
        MOV.W   #0xff, &0x4c8
        MOV.W   &0x4ca, R12
        POP.W   SR
          CFI CFA SP+32
        JMP     ??writeItem_4
??writeItem_3:
        MOV.W   #0x0, R12
        JMP     ??writeItem_5
??writeItem_0:
        MOV.B   @R15+, R14
        ADD.W   R14, R12
??writeItem_5:
        MOV.W   R13, R14
        ADD.W   #0xffff, R13
        CMP.W   #0x0, R14
        JNE     ??writeItem_0
??writeItem_4:
        MOV.W   R12, 0(SP)
        ADD.W   #0x8, R9
        ADD.W   R9, R7
        CMP.W   #0x0, R5
        JEQ     ??writeItem_6
        MOV.W   R5, R14
        MOV.W   R11, R13
        MOV.W   R7, R12
        CALLA   #flashWrite
??writeItem_6:
        MOV.W   R11, R14
        MOV.W   R9, R13
        MOV.B   R10, R12
        CALLA   #calcChkF
        CMP.W   R12, 0(SP)
        JNE     ??writeItem_7
        MOV.W   SP, R14
        ADD.W   #0x0, R14
        MOV.W   #0x2, R13
        SUB.W   #0x4, R7
        MOV.W   R7, R12
        CALLA   #flashWrite
        MOV.W   R4, R14
        MOV.W   R9, R13
        SUB.W   #0x8, R13
        CALLA   #??Subroutine4_0
??CrossCallReturnLabel_12:
        CMP.W   0x6(SP), 0(SP)
        JNE     ??writeItem_7
        MOV.W   0x2(SP), R14
        MOV.W   R9, R13
        MOV.B   R10, R12
        CALLA   #hotItemUpdate
??writeItem_1:
        MOV.B   #0x1, R6
??writeItem_7:
        MOV.W   0x4(SP), R11
        ADD.W   #0x8, R11
        JMP     ??writeItem_8
??writeItem_2:
        MOV.W   R15, R11
        ADD.W   #0x8, R11
        MOV.W   #0x400, R15
        SUB.W   pgOff(R8), R15
        CMP.W   R11, R15
        JC      ??writeItem_9
        MOV.W   R15, R11
??writeItem_9:
        ADD.W   R11, pgLost(R8)
??writeItem_8:
        ADD.W   R11, pgOff(R8)
        MOV.B   R6, R12
        ADD.W   #0xc, SP
          CFI CFA SP+20
        POPM.W  #0x8, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R4L SameValue
          CFI R5L SameValue
          CFI R6L SameValue
          CFI R7L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock53

        RSEG CODE:CODE:NOROOT(1)
compactPage:
          CFI Block cfiBlock54 Using cfiCommon0
          CFI Function compactPage
        FUNCALL compactPage, readHdr
        LOCFRAME CSTACK, 30, STACK
        FUNCALL compactPage, calcChkF
        LOCFRAME CSTACK, 30, STACK
        FUNCALL compactPage, setItem
        LOCFRAME CSTACK, 30, STACK
        FUNCALL compactPage, writeItem
        LOCFRAME CSTACK, 32, STACK
        FUNCALL compactPage, xferBuf
        LOCFRAME CSTACK, 32, STACK
        FUNCALL compactPage, calcChkF
        LOCFRAME CSTACK, 32, STACK
        FUNCALL compactPage, flashWrite
        LOCFRAME CSTACK, 32, STACK
        FUNCALL compactPage, readHdr
        LOCFRAME CSTACK, 32, STACK
        FUNCALL compactPage, hotItemUpdate
        LOCFRAME CSTACK, 30, STACK
        FUNCALL compactPage, setPageUse
        LOCFRAME CSTACK, 30, STACK
        FUNCALL compactPage, erasePage
        LOCFRAME CSTACK, 30, STACK
        FUNCALL compactPage, erasePage
        LOCFRAME CSTACK, 30, STACK
        PUSHM.W #0x8, R11
          CFI R4L Frame(CFA, -20)
          CFI R5L Frame(CFA, -18)
          CFI R6L Frame(CFA, -16)
          CFI R7L Frame(CFA, -14)
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+20
        SUB.W   #0xa, SP
          CFI CFA SP+30
        MOV.B   R12, R10
        MOV.W   R13, R8
        MOV.W   #0x8, R9
        MOV.B   #0x1, R4
        MOV.W   #pgRes, R11
??compactPage_0:
        MOV.B   @R11, R15
        RLA.W   R15
        MOV.W   pgOff(R15), R6
        CALLA   #?Subroutine4
??CrossCallReturnLabel_14:
        CMP.W   #0xffff, 0x2(SP)
        JEQ     ??compactPage_2
        CALLA   #?Subroutine7
??CrossCallReturnLabel_6:
        JNC     ??compactPage_2
        MOV.W   #0x3f8, R15
        SUB.W   R6, R15
        CMP.W   R14, R15
        JNC     ??compactPage_2
        ADD.W   #0x8, R9
        CMP.W   #0x0, 0x2(SP)
        JEQ     ??compactPage_3
        CMP.W   R8, 0x2(SP)
        JEQ     ??compactPage_3
        CALLA   #?Subroutine5
??CrossCallReturnLabel_1:
        JNE     ??compactPage_3
        CMP.W   #0xffff, 0x8(SP)
        JNE     ??compactPage_4
        MOV.B   #0x0, R14
        MOV.W   R9, R13
        MOV.B   R10, R12
        CALLA   #setItem
??compactPage_4:
        PUSH.B  #0x0
          CFI CFA SP+32
        MOV.W   #0x0, R15
        MOV.W   0x6(SP), R14
        MOV.W   0x4(SP), R13
        MOV.B   @R11, R12
        CALLA   #writeItem
        ADD.W   #0x2, SP
          CFI CFA SP+30
        CMP.B   #0x0, R12
        JEQ     ??compactPage_5
        ADD.W   #0x8, R6
        PUSH.W  R7
          CFI CFA SP+32
        MOV.W   R6, R15
        MOV.B   @R11, R14
        MOV.W   R9, R13
        MOV.B   R10, R12
        CALLA   #xferBuf
        MOV.W   0x6(SP), R14
        MOV.W   R6, R13
        MOV.B   @R11, R12
        CALLA   #calcChkF
        MOV.W   R12, 0x2(SP)
        SUB.W   #0x8, R6
        MOV.W   SP, R14
        ADD.W   #0x2, R14
        MOV.W   #0x2, R13
        MOV.B   @R11, R12
        CALLA   #??Subroutine2_0
??CrossCallReturnLabel_24:
        ADD.W   R6, R12
        ADD.W   #0x4, R12
        CALLA   #flashWrite
        MOV.W   0x8(SP), 0x2(SP)
        MOV.W   SP, R14
        ADD.W   #0x4, R14
        MOV.W   R6, R13
        MOV.B   @R11, R12
        CALLA   #readHdr
        ADD.W   #0x2, SP
          CFI CFA SP+30
        CMP.W   0x6(SP), 0(SP)
        JNE     ??compactPage_5
        MOV.W   0x2(SP), R14
        ADD.W   #0x8, R6
        MOV.W   R6, R13
        MOV.B   @R11, R12
        CALLA   #hotItemUpdate
??compactPage_3:
        ADD.W   R7, R9
        CMP.W   #0x3f8, R9
        JNC     ??compactPage_0
??compactPage_2:
        CMP.W   #0x0, R8
        JNE     ??compactPage_1
        MOV.B   #0x1, R13
        MOV.B   @R11, R12
        CALLA   #?Subroutine11
??compactPage_1:
        MOV.B   R4, R12
        ADD.W   #0xa, SP
          CFI CFA SP+20
        POPM.W  #0x8, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R4L SameValue
          CFI R5L SameValue
          CFI R6L SameValue
          CFI R7L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI R4L Frame(CFA, -20)
          CFI R5L Frame(CFA, -18)
          CFI R6L Frame(CFA, -16)
          CFI R7L Frame(CFA, -14)
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+30
??compactPage_5:
        MOV.B   #0x0, R4
        MOV.B   @R11, R12
        CALLA   #erasePage
        JMP     ??compactPage_1
        NOP
          CFI EndBlock cfiBlock54

        RSEG CODE:CODE:NOROOT(1)
?Subroutine7:
          CFI Block cfiCond55 Using cfiCommon0
          CFI Function initPage
          CFI Conditional ??CrossCallReturnLabel_5
          CFI R6L Frame(CFA, -16)
          CFI R7L Frame(CFA, -14)
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+30
          CFI Block cfiCond56 Using cfiCommon0
          CFI (cfiCond56) Function compactPage
          CFI (cfiCond56) Conditional ??CrossCallReturnLabel_6
          CFI (cfiCond56) R4L Frame(CFA, -20)
          CFI (cfiCond56) R5L Frame(CFA, -18)
          CFI (cfiCond56) R6L Frame(CFA, -16)
          CFI (cfiCond56) R7L Frame(CFA, -14)
          CFI (cfiCond56) R8L Frame(CFA, -12)
          CFI (cfiCond56) R9L Frame(CFA, -10)
          CFI (cfiCond56) R10L Frame(CFA, -8)
          CFI (cfiCond56) R11L Frame(CFA, -6)
          CFI (cfiCond56) CFA SP+34
          CFI Block cfiPicker57 Using cfiCommon1
          CFI (cfiPicker57) NoFunction
          CFI (cfiPicker57) Picker
        MOV.W   0x8(SP), R14
        MOV.W   R14, R7
        MOV.W   #0x3f8, R15
        SUB.W   R9, R15
        CMP.W   R14, R15
        RETA
          CFI EndBlock cfiCond55
          CFI EndBlock cfiCond56
          CFI EndBlock cfiPicker57

        RSEG CODE:CODE:NOROOT(1)
?Subroutine5:
          CFI Block cfiCond58 Using cfiCommon0
          CFI Function initPage
          CFI Conditional ??CrossCallReturnLabel_0
          CFI R6L Frame(CFA, -16)
          CFI R7L Frame(CFA, -14)
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+30
          CFI Block cfiCond59 Using cfiCommon0
          CFI (cfiCond59) Function compactPage
          CFI (cfiCond59) Conditional ??CrossCallReturnLabel_1
          CFI (cfiCond59) R4L Frame(CFA, -20)
          CFI (cfiCond59) R5L Frame(CFA, -18)
          CFI (cfiCond59) R6L Frame(CFA, -16)
          CFI (cfiCond59) R7L Frame(CFA, -14)
          CFI (cfiCond59) R8L Frame(CFA, -12)
          CFI (cfiCond59) R9L Frame(CFA, -10)
          CFI (cfiCond59) R10L Frame(CFA, -8)
          CFI (cfiCond59) R11L Frame(CFA, -6)
          CFI (cfiCond59) CFA SP+34
          CFI Block cfiPicker60 Using cfiCommon1
          CFI (cfiPicker60) NoFunction
          CFI (cfiPicker60) Picker
        MOV.W   R9, R13
        MOV.B   R10, R12
        CALLA   #calcChkF
        CMP.W   R12, 0xa(SP)
        RETA
          CFI EndBlock cfiCond58
          CFI EndBlock cfiCond59
          CFI EndBlock cfiPicker60

        RSEG CODE:CODE:NOROOT(1)
?Subroutine2:
          CFI Block cfiCond61 Using cfiCommon0
          CFI Function readHdr
          CFI Conditional ??CrossCallReturnLabel_25
          CFI CFA SP+8
          CFI Block cfiCond62 Using cfiCommon0
          CFI (cfiCond62) Function setPageUse
          CFI (cfiCond62) Conditional ??CrossCallReturnLabel_26
          CFI (cfiCond62) CFA SP+16
          CFI Block cfiPicker63 Using cfiCommon1
          CFI (cfiPicker63) NoFunction
          CFI (cfiPicker63) Picker
        MOV.B   R12, R12
          CFI EndBlock cfiCond61
          CFI EndBlock cfiCond62
          CFI EndBlock cfiPicker63
        REQUIRE ??Subroutine2_0
        // Fall through to label ??Subroutine2_0

        RSEG CODE:CODE:NOROOT(1)
??Subroutine2_0:
          CFI Block cfiCond64 Using cfiCommon0
          CFI Function xferBuf
          CFI Conditional ??CrossCallReturnLabel_23
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+12
          CFI Block cfiCond65 Using cfiCommon0
          CFI (cfiCond65) Function compactPage
          CFI (cfiCond65) Conditional ??CrossCallReturnLabel_24
          CFI (cfiCond65) R4L Frame(CFA, -20)
          CFI (cfiCond65) R5L Frame(CFA, -18)
          CFI (cfiCond65) R6L Frame(CFA, -16)
          CFI (cfiCond65) R7L Frame(CFA, -14)
          CFI (cfiCond65) R8L Frame(CFA, -12)
          CFI (cfiCond65) R9L Frame(CFA, -10)
          CFI (cfiCond65) R10L Frame(CFA, -8)
          CFI (cfiCond65) R11L Frame(CFA, -6)
          CFI (cfiCond65) CFA SP+36
          CFI Block cfiCond66 Using cfiCommon0
          CFI (cfiCond66) Function readHdr
          CFI (cfiCond66) Conditional ??CrossCallReturnLabel_25
          CFI (cfiCond66) CFA SP+8
          CFI Block cfiCond67 Using cfiCommon0
          CFI (cfiCond67) Function setPageUse
          CFI (cfiCond67) Conditional ??CrossCallReturnLabel_26
          CFI (cfiCond67) CFA SP+16
          CFI Block cfiPicker68 Using cfiCommon1
          CFI (cfiPicker68) NoFunction
          CFI (cfiPicker68) Picker
        RLA.W   R12
          CFI EndBlock cfiCond64
          CFI EndBlock cfiCond65
          CFI EndBlock cfiCond66
          CFI EndBlock cfiCond67
          CFI EndBlock cfiPicker68
        REQUIRE ??Subroutine2_1
        // Fall through to label ??Subroutine2_1

        RSEG CODE:CODE:NOROOT(1)
??Subroutine2_1:
          CFI Block cfiCond69 Using cfiCommon0
          CFI Function setItem
          CFI Conditional ??CrossCallReturnLabel_21
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+24
          CFI Block cfiCond70 Using cfiCommon0
          CFI (cfiCond70) Function initItem
          CFI (cfiCond70) Conditional ??CrossCallReturnLabel_22
          CFI (cfiCond70) R4L Frame(CFA, -20)
          CFI (cfiCond70) R5L Frame(CFA, -18)
          CFI (cfiCond70) R6L Frame(CFA, -16)
          CFI (cfiCond70) R7L Frame(CFA, -14)
          CFI (cfiCond70) R8L Frame(CFA, -12)
          CFI (cfiCond70) R9L Frame(CFA, -10)
          CFI (cfiCond70) R10L Frame(CFA, -8)
          CFI (cfiCond70) R11L Frame(CFA, -6)
          CFI (cfiCond70) CFA SP+26
          CFI Block cfiCond71 Using cfiCommon0
          CFI (cfiCond71) Function xferBuf
          CFI (cfiCond71) Conditional ??CrossCallReturnLabel_23
          CFI (cfiCond71) R10L Frame(CFA, -8)
          CFI (cfiCond71) R11L Frame(CFA, -6)
          CFI (cfiCond71) CFA SP+12
          CFI Block cfiCond72 Using cfiCommon0
          CFI (cfiCond72) Function compactPage
          CFI (cfiCond72) Conditional ??CrossCallReturnLabel_24
          CFI (cfiCond72) R4L Frame(CFA, -20)
          CFI (cfiCond72) R5L Frame(CFA, -18)
          CFI (cfiCond72) R6L Frame(CFA, -16)
          CFI (cfiCond72) R7L Frame(CFA, -14)
          CFI (cfiCond72) R8L Frame(CFA, -12)
          CFI (cfiCond72) R9L Frame(CFA, -10)
          CFI (cfiCond72) R10L Frame(CFA, -8)
          CFI (cfiCond72) R11L Frame(CFA, -6)
          CFI (cfiCond72) CFA SP+36
          CFI Block cfiCond73 Using cfiCommon0
          CFI (cfiCond73) Function readHdr
          CFI (cfiCond73) Conditional ??CrossCallReturnLabel_25
          CFI (cfiCond73) CFA SP+8
          CFI Block cfiCond74 Using cfiCommon0
          CFI (cfiCond74) Function setPageUse
          CFI (cfiCond74) Conditional ??CrossCallReturnLabel_26
          CFI (cfiCond74) CFA SP+16
          CFI Block cfiPicker75 Using cfiCommon1
          CFI (cfiPicker75) NoFunction
          CFI (cfiPicker75) Picker
        ADD.W   #0x65, R12
        RPT     #0x9
        RLAX.W  R12
        RETA
          CFI EndBlock cfiCond69
          CFI EndBlock cfiCond70
          CFI EndBlock cfiCond71
          CFI EndBlock cfiCond72
          CFI EndBlock cfiCond73
          CFI EndBlock cfiCond74
          CFI EndBlock cfiPicker75

        RSEG CODE:CODE:NOROOT(1)
initItem:
          CFI Block cfiBlock76 Using cfiCommon0
          CFI Function initItem
        FUNCALL initItem, flashWrite
        LOCFRAME CSTACK, 22, STACK
        FUNCALL initItem, compactPage
        LOCFRAME CSTACK, 22, STACK
        FUNCALL initItem, writeItem
        LOCFRAME CSTACK, 24, STACK
        FUNCALL initItem, setPageUse
        LOCFRAME CSTACK, 22, STACK
        FUNCALL initItem, erasePage
        LOCFRAME CSTACK, 22, STACK
        FUNCALL initItem, writeItem
        LOCFRAME CSTACK, 24, STACK
        PUSHM.W #0x8, R11
          CFI R4L Frame(CFA, -20)
          CFI R5L Frame(CFA, -18)
          CFI R6L Frame(CFA, -16)
          CFI R7L Frame(CFA, -14)
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+20
        SUB.W   #0x2, SP
          CFI CFA SP+22
        MOV.B   R12, R9
        MOV.W   R13, R6
        MOV.W   R14, R7
        MOV.W   R15, R4
        MOV.W   R14, R15
        ADD.W   #0x8, R15
        MOV.W   R15, 0(SP)
        MOV.B   #0xc, R11
        MOV.B   R11, R14
        MOV.W   #pgRes, R8
        MOV.B   @R8, R10
        ADD.B   #0x1, R10
??initItem_0:
        CMP.B   R11, R10
        JNC     ??initItem_1
        MOV.B   #0x0, R10
??initItem_1:
        CMP.B   @R8, R10
        JEQ     ??initItem_2
        MOV.B   R10, R12
        RLA.W   R12
        MOV.W   #0x400, R15
        SUB.W   pgOff(R12), R15
        MOV.W   R15, R13
        ADD.W   pgLost(R12), R13
        CMP.W   @SP, R13
        JC      ??initItem_3
??initItem_2:
        ADD.B   #0x1, R10
        ADD.B   #0xff, R14
        JNE     ??initItem_0
        JMP     ??initItem_4
??initItem_3:
        CMP.B   #0x0, R14
        JEQ     ??initItem_4
        CMP.W   @SP, R15
        JC      ??initItem_5
        MOV.W   #0x0, 0(SP)
        MOV.W   SP, R14
        ADD.W   #0x0, R14
        MOV.W   #0x2, R13
        CALLA   #??Subroutine2_1
??CrossCallReturnLabel_22:
        ADD.W   #0x4, R12
        CALLA   #flashWrite
        MOV.W   R6, R13
        MOV.B   R10, R12
        CALLA   #compactPage
        CMP.B   #0x0, R12
        JEQ     ??initItem_4
        PUSH.B  R9
          CFI CFA SP+24
        MOV.W   R4, R15
        MOV.W   R7, R14
        MOV.W   R6, R13
        MOV.B   @R8, R12
        CALLA   #writeItem
        ADD.W   #0x2, SP
          CFI CFA SP+22
        CMP.B   #0x0, R12
        JEQ     ??initItem_6
        MOV.B   @R8, R11
??initItem_6:
        CMP.B   #0x0, R9
        JNE     ??initItem_7
        MOV.B   R10, 0(R4)
        JMP     ??initItem_4
??initItem_7:
        MOV.B   #0x1, R13
        MOV.B   @R8, R12
        CALLA   #?Subroutine11
??CrossCallReturnLabel_10:
        JMP     ??initItem_4
??initItem_5:
        PUSH.B  R9
          CFI CFA SP+24
        MOV.W   R4, R15
        MOV.W   R7, R14
        MOV.W   R6, R13
        MOV.B   R10, R12
        CALLA   #writeItem
        ADD.W   #0x2, SP
          CFI CFA SP+22
        CMP.B   #0x0, R12
        JEQ     ??initItem_4
        MOV.B   R10, R11
??initItem_4:
        MOV.B   R11, R12
        ADD.W   #0x2, SP
          CFI CFA SP+20
        POPM.W  #0x8, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R4L SameValue
          CFI R5L SameValue
          CFI R6L SameValue
          CFI R7L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock76

        RSEG CODE:CODE:NOROOT(1)
?Subroutine11:
          CFI Block cfiCond77 Using cfiCommon0
          CFI Function compactPage
          CFI Conditional ??compactPage_1
          CFI R4L Frame(CFA, -20)
          CFI R5L Frame(CFA, -18)
          CFI R6L Frame(CFA, -16)
          CFI R7L Frame(CFA, -14)
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+34
          CFI Block cfiCond78 Using cfiCommon0
          CFI (cfiCond78) Function initItem
          CFI (cfiCond78) Conditional ??CrossCallReturnLabel_10
          CFI (cfiCond78) R4L Frame(CFA, -20)
          CFI (cfiCond78) R5L Frame(CFA, -18)
          CFI (cfiCond78) R6L Frame(CFA, -16)
          CFI (cfiCond78) R7L Frame(CFA, -14)
          CFI (cfiCond78) R8L Frame(CFA, -12)
          CFI (cfiCond78) R9L Frame(CFA, -10)
          CFI (cfiCond78) R10L Frame(CFA, -8)
          CFI (cfiCond78) R11L Frame(CFA, -6)
          CFI (cfiCond78) CFA SP+26
          CFI Block cfiPicker79 Using cfiCommon1
          CFI (cfiPicker79) NoFunction
          CFI (cfiPicker79) Picker
        CALLA   #setPageUse
        MOV.B   R10, R12
        CALLA   #erasePage
        MOV.B   R10, &pgRes
        RETA
          CFI EndBlock cfiCond77
          CFI EndBlock cfiCond78
          CFI EndBlock cfiPicker79

        RSEG CODE:CODE:NOROOT(1)
osal_nv_write:
          CFI Block cfiBlock80 Using cfiCommon0
          CFI Function osal_nv_write
        FUNCALL osal_nv_write, HalAdcCheckVdd
        LOCFRAME CSTACK, 36, STACK
        FUNCALL osal_nv_write, findItem
        LOCFRAME CSTACK, 36, STACK
        FUNCALL osal_nv_write, readHdr
        LOCFRAME CSTACK, 36, STACK
        FUNCALL osal_nv_write, initItem
        LOCFRAME CSTACK, 36, STACK
        FUNCALL osal_nv_write, setItem
        LOCFRAME CSTACK, 36, STACK
        FUNCALL osal_nv_write, xferBuf
        LOCFRAME CSTACK, 38, STACK
        FUNCALL osal_nv_write, flashWrite
        LOCFRAME CSTACK, 38, STACK
        FUNCALL osal_nv_write, xferBuf
        LOCFRAME CSTACK, 40, STACK
        FUNCALL osal_nv_write, calcChkF
        LOCFRAME CSTACK, 40, STACK
        FUNCALL osal_nv_write, flashWrite
        LOCFRAME CSTACK, 40, STACK
        FUNCALL osal_nv_write, readHdr
        LOCFRAME CSTACK, 40, STACK
        FUNCALL osal_nv_write, hotItemUpdate
        LOCFRAME CSTACK, 36, STACK
        FUNCALL osal_nv_write, erasePage
        LOCFRAME CSTACK, 36, STACK
        FUNCALL osal_nv_write, setPageUse
        LOCFRAME CSTACK, 36, STACK
        FUNCALL osal_nv_write, erasePage
        LOCFRAME CSTACK, 36, STACK
        FUNCALL osal_nv_write, setItem
        LOCFRAME CSTACK, 36, STACK
        PUSHM.W #0x8, R11
          CFI R4L Frame(CFA, -20)
          CFI R5L Frame(CFA, -18)
          CFI R6L Frame(CFA, -16)
          CFI R7L Frame(CFA, -14)
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+20
        PUSH.W  R15
          CFI CFA SP+22
        SUB.W   #0xe, SP
          CFI CFA SP+36
        MOV.W   R12, R7
        MOV.W   R13, R8
        MOV.W   R14, R9
        MOV.B   #0x0, 0x4(SP)
        MOV.B   #0xb3, R12
        CALLA   #HalAdcCheckVdd
        CMP.B   #0x0, R12
        JEQ     ??osal_nv_write_1
        CMP.W   #0x0, R9
        JEQ     ??osal_nv_write_2
        MOV.W   SP, R13
        ADD.W   #0x0, R13
        MOV.W   R7, R12
        CALLA   #findItem
        MOV.W   R12, R11
        CMP.W   #0x0, R12
        JNE     ??osal_nv_write_3
        MOV.B   #0x9, R12
        JMP     ??osal_nv_write_4
??osal_nv_write_3:
        MOV.W   SP, R14
        ADD.W   #0x6, R14
        MOV.W   R12, R13
        SUB.W   #0x8, R13
        MOV.B   @SP, R12
        CALLA   #readHdr
        MOV.W   R8, R15
        ADD.W   R9, R15
        CMP.W   R15, 0x8(SP)
        JC      ??osal_nv_write_5
??osal_nv_write_1:
        MOV.B   #0xa, R12
        JMP     ??osal_nv_write_4
??osal_nv_write_5:
        CALLA   #?Subroutine10
??CrossCallReturnLabel_20:
        ADD.W   R11, R14
        ADD.W   R8, R14
        MOV.W   0xe(SP), R13
        MOV.W   R9, R10
        MOV.W   #0x0, R5
        JMP     ??osal_nv_write_6
??osal_nv_write_0:
        MOV.B   @R14, R15
        CMP.B   @R13, R15
        JEQ     ??osal_nv_write_7
        MOV.W   #0x1, R5
        SUB.W   R15, 0xa(SP)
        MOV.B   @R13, R15
        ADD.W   R15, 0xa(SP)
??osal_nv_write_7:
        ADD.W   #0x1, R14
        ADD.W   #0x1, R13
??osal_nv_write_6:
        MOV.W   R10, R15
        ADD.W   #0xffff, R10
        CMP.W   #0x0, R15
        JNE     ??osal_nv_write_0
        BIT.W   #0x1, R5
        JNC     ??osal_nv_write_2
        MOV.B   #0xc, 0x1(SP)
        MOV.W   SP, R15
        ADD.W   #0x1, R15
        MOV.W   0x8(SP), R14
        MOV.W   R7, R13
        MOV.B   #0x0, R12
        CALLA   #initItem
        MOV.B   R12, R10
        CMP.B   #0xc, R12
        JEQ     ??osal_nv_write_8
        MOV.W   0x8(SP), 0x2(SP)
        MOV.B   R12, R6
        RLA.W   R6
        MOV.W   pgOff(R6), R7
        SUB.W   0x2(SP), R7
        MOV.W   0xa(SP), R5
        CMP.W   #0xffff, 0xc(SP)
        JNE     ??osal_nv_write_9
        MOV.B   #0x0, R14
        CALLA   #?Subroutine8
??osal_nv_write_9:
        PUSH.W  R8
          CFI CFA SP+38
        MOV.W   R7, R15
        MOV.B   R10, R14
        MOV.W   R11, R13
        MOV.B   0x2(SP), R12
        CALLA   #xferBuf
        ADD.W   R8, R7
        MOV.W   R6, R4
        ADD.W   #0x65, R4
        RPT     #0x9
        RLAX.W  R4
        MOV.W   0x10(SP), R14
        MOV.W   R9, R13
        MOV.W   R4, R12
        ADD.W   R7, R12
        CALLA   #flashWrite
        MOV.W   0xa(SP), R15
        SUB.W   R8, R15
        SUB.W   R9, R15
        PUSH.W  R15
          CFI CFA SP+40
        ADD.W   R9, R7
        MOV.W   R7, R15
        MOV.B   R10, R14
        MOV.W   R11, R13
        ADD.W   R8, R13
        ADD.W   R9, R13
        MOV.B   0x4(SP), R12
        CALLA   #xferBuf
        MOV.W   pgOff(R6), R7
        SUB.W   0x6(SP), R7
        MOV.W   0xc(SP), R14
        MOV.W   R7, R13
        MOV.B   R10, R12
        CALLA   #calcChkF
        MOV.W   R12, 0x6(SP)
        SUB.W   #0x8, R7
        MOV.W   SP, R14
        ADD.W   #0x6, R14
        MOV.W   #0x2, R13
        ADD.W   R7, R4
        ADD.W   #0x4, R4
        MOV.W   R4, R12
        CALLA   #flashWrite
        MOV.W   SP, R14
        ADD.W   #0xa, R14
        MOV.W   R7, R13
        CALLA   #??Subroutine4_0
??CrossCallReturnLabel_11:
        ADD.W   #0x4, SP
          CFI CFA SP+36
        CMP.W   0xa(SP), R5
        JNE     ??osal_nv_write_8
        MOV.W   0x6(SP), R14
        ADD.W   #0x8, R7
        MOV.W   R7, R13
        MOV.B   R10, R12
        CALLA   #hotItemUpdate
        JMP     ??osal_nv_write_10
??osal_nv_write_8:
        MOV.B   #0xa, 0x4(SP)
??osal_nv_write_10:
        CMP.B   #0xc, 0x1(SP)
        JEQ     ??osal_nv_write_11
        CMP.B   0x1(SP), 0(SP)
        JNE     ??osal_nv_write_12
        CMP.B   #0xa, 0x4(SP)
        JNE     ??osal_nv_write_12
        MOV.B   &pgRes, R12
        CALLA   #erasePage
        JMP     ??osal_nv_write_2
??osal_nv_write_12:
        MOV.B   #0x1, R13
        MOV.B   &pgRes, R12
        CALLA   #setPageUse
        MOV.B   0x1(SP), R12
        CALLA   #erasePage
        MOV.B   0x1(SP), &pgRes
??osal_nv_write_11:
        CMP.B   0x1(SP), 0(SP)
        JEQ     ??osal_nv_write_2
        CMP.B   #0xa, 0x4(SP)
        JEQ     ??osal_nv_write_2
        MOV.B   #0x1, R14
        CALLA   #?Subroutine8
??osal_nv_write_2:
        MOV.B   0x4(SP), R12
??osal_nv_write_4:
        ADD.W   #0x10, SP
          CFI CFA SP+20
        POPM.W  #0x8, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R4L SameValue
          CFI R5L SameValue
          CFI R6L SameValue
          CFI R7L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock80

        RSEG CODE:CODE:NOROOT(1)
osal_nv_item_init:
          CFI Block cfiBlock81 Using cfiCommon0
          CFI Function osal_nv_item_init
        FUNCALL osal_nv_item_init, HalAdcCheckVdd
        LOCFRAME CSTACK, 14, STACK
        FUNCALL osal_nv_item_init, findItem
        LOCFRAME CSTACK, 14, STACK
        FUNCALL osal_nv_item_init, hotItemUpdate
        LOCFRAME CSTACK, 14, STACK
        FUNCALL osal_nv_item_init, initItem
        LOCFRAME CSTACK, 14, STACK
        PUSHM.W #0x4, R11
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+12
        SUB.W   #0x2, SP
          CFI CFA SP+14
        MOV.W   R12, R10
        MOV.W   R13, R11
        MOV.W   R14, R8
        MOV.B   #0xb3, R12
        CALLA   #HalAdcCheckVdd
        CMP.B   #0x0, R12
        JEQ     ??osal_nv_item_init_0
        CALLA   #?Subroutine6
??CrossCallReturnLabel_4:
        JEQ     ??osal_nv_item_init_1
        MOV.W   R10, R14
        MOV.W   R12, R13
        MOV.B   @SP, R12
        CALLA   #hotItemUpdate
        MOV.B   #0x0, R12
        JMP     ??osal_nv_item_init_2
??osal_nv_item_init_1:
        MOV.W   R8, R15
        MOV.W   R11, R14
        MOV.W   R10, R13
        MOV.B   #0x1, R12
        CALLA   #initItem
        CMP.B   #0xc, R12
        JEQ     ??osal_nv_item_init_0
        MOV.B   #0x9, R12
        JMP     ??osal_nv_item_init_2
??osal_nv_item_init_0:
        MOV.B   #0xa, R12
??osal_nv_item_init_2:
        BRA     #?Subroutine1
          CFI EndBlock cfiBlock81

        RSEG CODE:CODE:REORDER:NOROOT(1)
initNV:
          CFI Block cfiBlock82 Using cfiCommon0
          CFI Function initNV
        FUNCALL initNV, readHdr
        LOCFRAME CSTACK, 20, STACK
        FUNCALL initNV, setPageUse
        LOCFRAME CSTACK, 20, STACK
        FUNCALL initNV, erasePage
        LOCFRAME CSTACK, 20, STACK
        FUNCALL initNV, compactPage
        LOCFRAME CSTACK, 20, STACK
        FUNCALL initNV, erasePage
        LOCFRAME CSTACK, 20, STACK
        FUNCALL initNV, erasePage
        LOCFRAME CSTACK, 20, STACK
        FUNCALL initNV, initPage
        LOCFRAME CSTACK, 20, STACK
        FUNCALL initNV, initPage
        LOCFRAME CSTACK, 20, STACK
        FUNCALL initNV, erasePage
        LOCFRAME CSTACK, 20, STACK
        PUSHM.W #0x4, R11
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+12
        SUB.W   #0x8, SP
          CFI CFA SP+20
        MOV.B   #0xc, R10
        MOV.B   R10, R11
        MOV.B   #0x0, R8
        MOV.B   R10, &pgRes
        MOV.B   #0x0, R9
??initNV_0:
        MOV.W   SP, R14
        ADD.W   #0x0, R14
        MOV.W   #0x0, R13
        MOV.B   R9, R12
        CALLA   #readHdr
        CMP.W   #0xffff, 0(SP)
        JNE     ??initNV_4
        CMP.B   R10, &pgRes
        JNE     ??initNV_5
        MOV.B   R9, &pgRes
        JMP     ??initNV_6
??initNV_5:
        MOV.B   #0x1, R13
        MOV.B   R9, R12
        CALLA   #setPageUse
        JMP     ??initNV_6
??initNV_4:
        CMP.W   #0xffff, 0x4(SP)
        JEQ     ??initNV_6
        MOV.B   R9, R11
??initNV_6:
        ADD.B   #0x1, R9
        CMP.B   R10, R9
        JNC     ??initNV_0
        MOV.B   &pgRes, R12
        CMP.B   R10, R11
        JEQ     ??initNV_7
        CMP.B   R10, R12
        JEQ     ??initNV_8
        CALLA   #erasePage
        MOV.W   #0x0, R13
        MOV.B   R11, R12
        CALLA   #compactPage
        JMP     ??initNV_9
??initNV_8:
        MOV.B   R11, R12
        CALLA   #erasePage
        MOV.B   R11, &pgRes
        JMP     ??initNV_9
??initNV_7:
        CMP.B   R10, R12
        JEQ     ??initNV_9
        CALLA   #erasePage
??initNV_9:
        MOV.B   #0x0, R9
??initNV_1:
        MOV.B   R8, R14
        MOV.W   #0x0, R13
        MOV.B   R9, R12
        CALLA   #initPage
        CMP.W   #0x0, R12
        JEQ     ??initNV_10
        MOV.B   #0x1, R8
        MOV.B   #0xff, R9
??initNV_10:
        ADD.B   #0x1, R9
        CMP.B   R10, R9
        JNC     ??initNV_1
        BIT.B   #0x1, R8
        JNC     ??initNV_11
        MOV.B   #0x0, R9
??initNV_2:
        MOV.B   #0x0, R14
        MOV.W   #0x0, R13
        MOV.B   R9, R12
        CALLA   #initPage
        ADD.B   #0x1, R9
        CMP.B   R10, R9
        JNC     ??initNV_2
??initNV_11:
        CMP.B   R10, &pgRes
        JNE     ??initNV_12
        MOV.B   #0x0, R15
        MOV.B   #0x0, R14
??initNV_3:
        MOV.B   R14, R11
        RLA.W   R11
        MOV.W   pgLost(R11), R11
        CMP.W   #0x3f8, R11
        JNE     ??initNV_13
        MOV.B   R14, R15
        JMP     ??initNV_14
??initNV_13:
        MOV.B   R15, R13
        RLA.W   R13
        CMP.W   R11, pgLost(R13)
        JC      ??initNV_15
        MOV.B   R14, R15
??initNV_15:
        ADD.B   #0x1, R14
        CMP.B   R10, R14
        JNC     ??initNV_3
??initNV_14:
        MOV.B   R15, &pgRes
        MOV.B   R15, R12
        CALLA   #erasePage
??initNV_12:
        MOV.B   #0x1, R12
        BRA     #?Subroutine0
          CFI EndBlock cfiBlock82

        RSEG CODE:CODE:REORDER:NOROOT(1)
readHdr:
          CFI Block cfiBlock83 Using cfiCommon0
          CFI Function readHdr
        CALLA   #?Subroutine2
??CrossCallReturnLabel_25:
        ADD.W   R13, R12
        MOV.B   #0x8, R15
??readHdr_0:
        MOV.B   @R12+, 0(R14)
        ADD.W   #0x1, R14
        ADD.B   #0xff, R15
        JNE     ??readHdr_0
        RETA
          CFI EndBlock cfiBlock83

        RSEG CODE:CODE:REORDER:NOROOT(1)
osal_nv_init:
          CFI Block cfiBlock84 Using cfiCommon0
          CFI Function osal_nv_init
        FUNCALL osal_nv_init, initNV
        LOCFRAME CSTACK, 4, STACK
        BRA     #initNV
          CFI EndBlock cfiBlock84

        RSEG CODE:CODE:REORDER:NOROOT(1)
?setjmp_save_r4:
        REQUIRE ?setjmp_r4
        REQUIRE ?longjmp_r4

        RSEG CODE:CODE:REORDER:NOROOT(1)
?setjmp_save_r5:
        REQUIRE ?setjmp_r5
        REQUIRE ?longjmp_r5

        END
// 1352       }
// 1353     }
// 1354   }
// 1355 
// 1356   return rtrn;
// 1357 }
// 1358 
// 1359 /*********************************************************************
// 1360  * @fn      osal_nv_read
// 1361  *
// 1362  * @brief   Read data from NV. This function can be used to read an entire item from NV or
// 1363  *          an element of an item by indexing into the item with an offset.
// 1364  *          Read data is copied into *buf.
// 1365  *
// 1366  * @param   id  - Valid NV item Id.
// 1367  * @param   ndx - Index offset into item
// 1368  * @param   len - Length of data to read.
// 1369  * @param  *buf - Data is read into this buffer.
// 1370  *
// 1371  * @return  SUCCESS if NV data was copied to the parameter 'buf'.
// 1372  *          Otherwise, NV_OPER_FAILED for failure.
// 1373  */
// 1374 uint8 osal_nv_read( uint16 id, uint16 ndx, uint16 len, void *buf )
// 1375 {
// 1376   uint8 *addr, *ptr = (uint8 *)buf;
// 1377   uint8 findPg;
// 1378   uint16 offset;
// 1379   uint8 hotIdx;
// 1380 
// 1381   if ((hotIdx = hotItem(id)) < OSAL_NV_MAX_HOT)
// 1382   {
// 1383     findPg = hotPg[hotIdx];
// 1384     offset = hotOff[hotIdx];
// 1385   }
// 1386   else if ((offset = findItem(id, &findPg)) == OSAL_NV_ITEM_NULL)
// 1387   {
// 1388     return NV_OPER_FAILED;
// 1389   }
// 1390 
// 1391   addr = OSAL_NV_PAGE_TO_PTR(findPg) + offset + ndx;
// 1392   while ( len-- )
// 1393   {
// 1394     *ptr++ = *addr++;
// 1395   }
// 1396 
// 1397   return SUCCESS;
// 1398 }
// 1399 
// 1400 /*********************************************************************
// 1401  * @fn      osal_nv_delete
// 1402  *
// 1403  * @brief   Delete item from NV. This function will fail if the length
// 1404  *          parameter does not match the length of the item in NV.
// 1405  *
// 1406  * @param   id  - Valid NV item Id.
// 1407  * @param   len - Length of item to delete.
// 1408  *
// 1409  * @return  SUCCESS if item was deleted,
// 1410  *          NV_ITEM_UNINIT if item did not exist in NV,
// 1411  *          NV_BAD_ITEM_LEN if length parameter not correct,
// 1412  *          NV_OPER_FAILED if attempted deletion failed.
// 1413  */
// 1414 uint8 osal_nv_delete( uint16 id, uint16 len )
// 1415 {
// 1416   uint8 findPg;
// 1417   uint16 length;
// 1418   uint16 offset;
// 1419 
// 1420   offset = findItem( id, &findPg );
// 1421   if ( offset == OSAL_NV_ITEM_NULL )
// 1422   {
// 1423     // NV item does not exist
// 1424     return NV_ITEM_UNINIT;
// 1425   }
// 1426 
// 1427   length = osal_nv_item_len( id );
// 1428   if ( length != len )
// 1429   {
// 1430     // NV item has different length
// 1431     return NV_BAD_ITEM_LEN;
// 1432   }
// 1433 
// 1434   // Set item header ID to zero to 'delete' the item
// 1435   setItem( findPg, offset, eNvZero );
// 1436 
// 1437   // Verify that item has been removed
// 1438   offset = findItem( id, &findPg );
// 1439   if ( offset != OSAL_NV_ITEM_NULL )
// 1440   {
// 1441     // Still there
// 1442     return NV_OPER_FAILED;
// 1443   }
// 1444   else
// 1445   {
// 1446     // Yes, it's gone
// 1447     return SUCCESS;
// 1448   }
// 1449 }
// 1450 
// 1451 /*********************************************************************
// 1452  */
// 
//  2 360 bytes in segment CODE
//      6 bytes in segment DATA16_C
//     58 bytes in segment DATA16_Z
// 12 288 bytes in segment ZIGNV_ADDRESS_SPACE
// 
//  2 360 bytes of CODE  memory
//      6 bytes of CONST memory
// 12 346 bytes of DATA  memory
//
//Errors: none
//Warnings: none
